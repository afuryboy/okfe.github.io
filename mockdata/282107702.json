{"code":0,"data":"<h2>防冲突</h2>\n<p>underscore 使用 _ 作为函数的挂载对象，如果页面中已经存在了 <code>_</code> 对象，underscore 就会覆盖该对象，举个例子：</p>\n<pre><code class=\"language-js\">var _ = {value: 1 }\n\n// 引入 underscore 后\nconsole.log(_.value); // undefined\n</code></pre>\n<p>所以 underscore 提供了 noConflict 功能，可以放弃 underscore 的控制变量 <code>_</code>，返回 underscore 对象的引用。</p>\n<pre><code class=\"language-js\">var _ = {value: 1 }\n\n// 引入 underscore 后\n\n// 放弃 &quot;_&quot;，使用 &quot;$&quot;\nvar $ = _.noConflict();\n\nconsole.log(_.value); // 1\n\n// 使用 underscore 的方法\n$.each([1, 2, 3], alert);\n</code></pre>\n<p>那么 noConflict 函数是如何实现的呢？</p>\n<p>首先，在 underscore 执行的时候，会储存之前的 <code>_</code> 对象，然后当执行 noConflict 函数的时候，再将之前储存的 <code>_</code> 对象赋给全局对象，最后返回 underscore 对象。这样，我们就可以利用返回的 underscore 对象使用 underscore 提供的各种方法。</p>\n<pre><code class=\"language-js\">// 源码一开始的时候便储存之前的 _ 对象\nvar previousUnderscore = root._;\n\n_.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n};\n</code></pre>\n<p>是的，就是这么简单。你可以轻松为你的函数库添加防冲突功能。</p>\n<p>接下来我们看 underscore 中的一些功能函数。</p>\n<h2>_.identity</h2>\n<pre><code class=\"language-js\">_.identity = function(value) {\n    return value;\n};\n</code></pre>\n<p>看起来匪夷所思的一个函数，传入一个值，然后返回该值，为什么不直接使用该值呢？</p>\n<p>还记得我们在<a href=\"https://github.com/mqyqingfeng/Blog/issues/58\">《underscore 系列之内部函数 cb 和 optimizeCb》</a>中接触过这个函数吗？</p>\n<p>如果我们自己编写了一个 <code>_.map</code> 函数：</p>\n<pre><code class=\"language-js\">_.map = function(arr, iteratee){\n    return arr.map(iteratee)\n}\n</code></pre>\n<p>然而当我们这样使用 <code>_.map([1, 2, 3])</code> 时便会报错，因为我们没有传入 iteratee 函数，然而使用 underscore 却没有问题，结果是返回一个相同的新数组，原因就在于当 iteratee 为 undefined 的时候，underscore 视为传入了 <code>_.identity</code> 函数。就相当于：</p>\n<pre><code class=\"language-js\">_.map = function(arr, iteratee){\n    if (!iteratee) iteratee = _.identity\n    return arr.map(iteratee)\n}\n</code></pre>\n<p>简而言之，如果我们想要复制一个数组：</p>\n<pre><code class=\"language-js\">var clonedArr = [1, 2, 3].map(_.identity) // [1, 2, 3]\n</code></pre>\n<h2>_.constant</h2>\n<pre><code class=\"language-js\">_.constant = function(value) {\n    return function() {\n        return value;\n    };\n};\n</code></pre>\n<p>该函数传入一个 value，然后返回一个返回该 value 的函数，这又有什么用呢？我们来看个 demo：</p>\n<pre><code class=\"language-js\">var value = 1;\nvar getValue = _.constant(value);\n\nvalue = 2;\n\ngetValue(); // 1\ngetValue(); // 1\n</code></pre>\n<p>这很容易让人想到 ES6 的 const，我一开始以为就是用来表示 ES6 的 const ，后来看了这个函数起源的 issue，才发现并非如此，它其实像下面的 _.noop 函数一样可以作为默认函数使用。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">_.select(collection, filterFunction || function() { return true; })\n</code></pre>\n<p>我们根据 filterFunction 筛选 collection 中符合条件的元素，如果没有传 filterFunction，我们就返回所有的元素，如果有 <code>_.constant</code> 函数，我们可以将其简化为：</p>\n<pre><code class=\"language-js\">_.select(collection, filterFunction || _.constant(true))\n</code></pre>\n<p>尽管没有什么大的改变，但是语义更加明确。</p>\n<h2>_.noop</h2>\n<pre><code class=\"language-js\">_.noop = function(){};\n</code></pre>\n<p>一个空函数，看起来依旧没什么用……</p>\n<p>noop 函数可以用于作为默认值，这样就可以省去是否存在的判断，举个例子：</p>\n<pre><code class=\"language-js\">// 不使用 noop\nfunction a(value, callback){\n    // 每次使用 callback 都要判断一次\n    _.isFunction(callback) &amp;&amp; callback()\n}\n\n// 使用 noop\nfunction a(value, callback) {\n    // 判断一次\n    if(!_.isFunction(callback)) callback = _.noop;\n\n    // 以后都可以直接使用\n    callback()\n}\n</code></pre>\n<h2>deepGet</h2>\n<pre><code class=\"language-js\">var deepGet = function(obj, path) {\n    var length = path.length;\n    for (var i = 0; i &lt; length; i++) {\n        if (obj == null) return void 0;\n        obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n};\n</code></pre>\n<p>deepGet 用于获得对象深层次的值。举个例子：</p>\n<pre><code class=\"language-js\">var obj = { \n    value: { \n        deepValue: 2\n    } \n}\n\nconsole.log(deepGet(obj, ['value', 'deepValue']))\n</code></pre>\n<p>使用这个函数，可以避免深层次取值时，因为没有其中的一个属性，导致的报错。</p>\n<h2>shallowProperty</h2>\n<pre><code class=\"language-js\">var shallowProperty = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n};\n</code></pre>\n<p>shallowProperty 也是用于获取对象的属性，也许你会好奇在开发中，直接使用<code>.</code> 不就可以获取对象的属性了，为什么还要写成这样呢？我们来举个例子：</p>\n<pre><code class=\"language-js\">// 获取 arr 所有元素的 name 属性\nvar arr = [\n    {\n        value: 1,\n        name: 'Kevin'\n    },\n    {\n        value: 2,\n        name: 'Daisy'\n    }\n]\n\n// 普通方式\nvar names = arr.map(function(item){\n    return item.name;\n})\n\n// 使用 shallowProperty\nvar names = arr.map(shallowProperty('name'))\n</code></pre>\n<h2>_.property</h2>\n<pre><code class=\"language-js\">_.property = function(path) {\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n};\n</code></pre>\n<p><code>_.property</code> 结合了 deepGet 和 shallowProperty，可以获取元素深层次的值。上面一个例子也可以写成：</p>\n<pre><code class=\"language-js\">var names = arr.map(_.property('name'))\n</code></pre>\n<h2>_.propertyOf</h2>\n<pre><code class=\"language-js\">_.propertyOf = function(obj) {\n    if (obj == null) {\n        return function(){};\n    }\n    return function(path) {\n        return !Array.isArray(path) ? obj[path] : deepGet(obj, path);\n    };\n};\n</code></pre>\n<p><code>_.property</code> 返回一个函数，这个函数返回任何传入的对象的指定属性。</p>\n<p><code>_.propertyOf</code> 与 <code>_.property</code> 相反。需要一个对象，并返回一个函数，这个函数将返回一个提供的属性的值。</p>\n<p>我们写个例子：</p>\n<pre><code class=\"language-js\">// 获取 person 对象的所有属性值\nvar person = {\n    name: 'Kevin',\n    age: '18'\n};\n\n// 普通方式\nvar values = Object.keys(person).map((key) =&gt; person[key]); // [&quot;Kevin&quot;, &quot;18&quot;]\n\n// 使用 _.propertyOf\nvar values = Object.keys(person).map(_.propertyOf(person)); // [&quot;Kevin&quot;, &quot;18&quot;\n</code></pre>\n<h2>_.random</h2>\n<p>返回一个 min 和 max 之间的随机整数。如果你只传递一个参数，那么将返回 0 和这个参数之间的整数。</p>\n<pre><code class=\"language-js\">_.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n</code></pre>\n<p>注意：该随机值有可能是 min 或 max。</p>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}