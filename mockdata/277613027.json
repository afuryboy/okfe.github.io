{"code":0,"data":"<h2>前言</h2>\n<p>仅看 cb 和 optimizeCb 两个函数的名字，你可能想不到这是用来做什么的，尽管你可能想到 cb 是 callback 的缩写。</p>\n<p>如果直接讲解源码，你可能想不明白为什么要这么写，所以我们从 _.map 函数开始讲起。</p>\n<h2>_.map</h2>\n<p>_.map 类似于 <code>Array.prototype.map</code>，但更加健壮和完善。我们看下 _.map 的源码：</p>\n<pre><code class=\"language-js\">// 简化过，这里仅假设 obj 是数组\n_.map = function (obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n\n    var length = obj.length, results = Array(length);\n    for (var index = 0; index &lt; length; index++) {\n        results[index] = iteratee(obj[index], index, obj);\n    }\n\n    return results;\n};\n</code></pre>\n<p>map 方法除了传入要处理的数组之外，还有两个参数 iteratee 和 context，类似于 <code>Array.prototype.map</code> 中的其他两个参数，其中 iteratee 表示处理函数，context 表示指定的执行上下文，即 this 的值。</p>\n<p>然后在源码中，我们看到，我们将 iteratee 和 context 传入一个 cb 函数，然后覆盖掉 iteratee 函数，然后将这个函数用作最终的处理函数。</p>\n<p>实际上，需要这么麻烦吗？不就是使用 iteratee 函数处理每次迭代的值吗？不就是通过 context 指定 this 的值吗？我们可以直接这样写呐：</p>\n<pre><code class=\"language-js\">_.map = function (obj, iteratee, context) {\n    var length = obj.length, results = Array(length);\n    for (var index = 0; index &lt; length; index++) {\n        results[index] = iteratee.call(context, obj[index], index, obj);\n    }\n    return results;\n};\n\n// [2, 3, 4]\nconsole.log(_.map([1, 2, 3], function(item){\n    return item + 1;\n})) \n\n// [2, 3, 4]\nconsole.log(_.map([1, 2, 3], function(item){\n    return item + this.value;\n}, {value: 1})) \n</code></pre>\n<p>你看看也没有什么问题呐，可是，万一 iteratee 我们不传入一个函数呢？比如我们什么也不传，或者传入一个对象，又或者传入一个字符串、数字呢？</p>\n<p>如果用我们的方法自然是会报错的，那 underscore 呢？</p>\n<pre><code class=\"language-js\">// 使用 underscore\n\n// 什么也不传\nvar result = _.map([1,2,3]); // [1, 2, 3]\n\n// 传入一个对象\nvar result = _.map([{name:'Kevin'}, {name: 'Daisy', age: 18}], {name: 'Daisy'}); // [false, true]\n\nvar result = _.map([{name: 'Kevin'}, {name: 'Daisy'}], 'name'); // ['Kevin', 'daisy']\n</code></pre>\n<p>我们会发现，underscore 竟然还能根据传入的值的类型不同，实现的效果不同。我们总结下：</p>\n<ol>\n<li>当 iteratee 不传时，返回一个相同的数组。</li>\n<li>当 iteratee 为一个函数，正常处理。</li>\n<li>当 iteratee 为一个对象，返回元素是否匹配指定的对象。</li>\n<li>当 iteratee 为字符串，返回元素对应的属性值的集合。</li>\n</ol>\n<p>由此，我们可以推测在 underscore 的 cb 函数中，有对 iteratee 值类型的判断，然后根据不同的类型，返回不同的 iteratee 函数。</p>\n<h2>cb</h2>\n<p>所以我们来看看 cb 函数的源码：</p>\n<pre><code class=\"language-js\">var cb = function(value, context, argCount) {\n    \n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n\n    if (value == null) return _.identity;\n\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n\n    if (_.isObject(value) &amp;&amp; !_.isArray(value)) return _.matcher(value);\n\n    return _.property(value);\n};\n</code></pre>\n<p>这一看就牵扯到了 8 个函数！不要害怕，我们一个一个看。</p>\n<h2>_.iteratee</h2>\n<pre><code class=\"language-js\">if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n</code></pre>\n<p>我们看看 _.iteratee 的源码：</p>\n<pre><code class=\"language-js\">_.iteratee = builtinIteratee = function(value, context) {\n    return cb(value, context, Infinity);\n};\n</code></pre>\n<p>因为 <code>_.iteratee = builtinIteratee</code> 的缘故，<code>_.iteratee !== builtinIteratee</code> 值为 false，所以正常情况下 <code>_.iteratee(value, context)</code> 并不会执行。</p>\n<p>但是如果我们在外部修改了 _.iteratee 函数，结果便会为 true，cb 函数直接返回 <code>_.iteratee(value, context)</code>。</p>\n<p>这个意思其实是说用我们自定义的 _.iteratee 函数来处理 value 和 context。</p>\n<p>试想我们并不需要现在 _.map 这么强大的功能，我只希望当 value 是一个函数，就用该函数处理数组元素，如果不是函数，就直接返回当前元素，我们可以这样修改：</p>\n<pre><code class=\"language-html\">&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;underscore map&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script src=&quot;../vender/underscore.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n    _.iteratee = function(value, context) {\n        if (typeof value === 'function') {\n            return function(...rest) {\n                return value.call(context, ...rest)\n            };\n        }\n        return function(value) {\n            return value;\n        };\n    };\n\n    // 如果 map 的第二个参数不是函数，就返回该元素\n    console.log(_.map([1, 2, 3], 'name')); // [1, 2, 3]\n\n    // 如果 map 的第二个参数是函数，就使用该函数处理数组元素\n    var result = _.map([1, 2, 3], function(item) {\n        return item + 1;\n    });\n\n    console.log(result); // [2, 3, 4]\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>当然更多的情况是自定义对不同的 value 使用不同的处理函数，值得注意的是，underscore 中的多个函数都是用了 cb 函数，而因为 cb 函数使用了 _.iteratee 函数，如果你修改这个函数，其实会影响多个函数，这些函数基本都属于集合函数，具体包括 map、find、filter、reject、every、some、max、min、sortBy、groupBy、indexBy、countBy、sortedIndex、partition、和 unique。</p>\n<h2>_.identity</h2>\n<pre><code class=\"language-js\">if (value == null) return _.identity;\n</code></pre>\n<p>让我们看看 _.identity 的源码：</p>\n<pre><code class=\"language-js\">_.identity = function(value) {\n    return value;\n};\n</code></pre>\n<p>这也就是为什么当 map 的第二个参数什么都不传的时候，结果会是一个相同数组的原因。</p>\n<pre><code class=\"language-js\">_.map([1,2,3]); // [1, 2, 3]\n</code></pre>\n<p>如果直接看这个函数，可能觉得没有什么用，但用在这里，却又十分的合适。</p>\n<h2>optimizeCb</h2>\n<pre><code class=\"language-js\">if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n</code></pre>\n<p>当 value 是一个函数的时候，就传入 optimizeCb 函数，我们来看看 optimizeCb 函数：</p>\n<pre><code class=\"language-js\">var optimizeCb = function(func, context, argCount) {\n    // 如果没有传入 context，就返回 func 函数\n    if (context === void 0) return func;\n    switch (argCount) {\n        case 1:\n            return function(value) {\n                return func.call(context, value);\n            };\n        case null:\n        case 3:\n            return function(value, index, collection) {\n                return func.call(context, value, index, collection);\n            };\n        case 4:\n            return function(accumulator, value, index, collection) {\n                return func.call(context, accumulator, value, index, collection);\n            };\n    }\n    return function() {\n        return func.apply(context, arguments);\n    };\n};\n</code></pre>\n<p>也许你会好奇，为什么我要对 argCount 进行判断呢？就不能直接返回吗？比如这样：</p>\n<pre><code class=\"language-js\">var optimizeCb = function(func, context) {\n    // 如果没有传入 context，就返回 func 函数\n    if (context === void 0) return func;\n    return function() {\n        return func.apply(context, arguments);\n    };\n};\n</code></pre>\n<p>当然没有问题，但为什么 underscore 要这样做呢？其实就是为了避免使用 arguments，提高一点性能而已，如果不是写一个库，其实还真是没有必要做到这点。</p>\n<p>而为什么当参数是 3 个时候，参数名称分别是 value, index, collection ，又为什么没有参数为 2 的情况呢？其实这都是根据 underscore 函数用到的情况，没有函数用到两个参数，于是就省略了，像 map 函数就会用到 3 个参数，就根据这三个参数的名字起了这里的变量名啦。</p>\n<h2>_.matcher</h2>\n<pre><code class=\"language-js\">if (_.isObject(value) &amp;&amp; !_.isArray(value)) return _.matcher(value);\n</code></pre>\n<p>这段就是用来处理当 map 的第二个参数是对象的情况：</p>\n<pre><code class=\"language-js\">// 传入一个对象\nvar result = _.map([{name:'Kevin'}, {name: 'Daisy', age: 18}], {name: 'Daisy'}); // [false, true]\n</code></pre>\n<p>如果 value 是一个对象，并且不是数组，就使用 _.matcher 函数。看看各个函数的源码：</p>\n<pre><code class=\"language-js\">var nativeIsArray = Array.isArray;\n\n_.isArray = nativeIsArray || function(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n_.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' &amp;&amp; !!obj;\n};\n\n\n// extend 函数可以参考 《JavaScript 专题之手写一个 jQuery 的 extend》\n_.matcher = function(attrs) {\n    attrs = _.extend({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n};\n\n// 该函数判断 attr 对象中的键值是否在 object 中有并且相等\n\n// var stooge = {name: 'moe', age: 32};\n// _.isMatch(stooge, {age: 32}); =&gt; true\n\n// 其中 _.keys 相当于 Object.keys\n_.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i &lt; length; i++) {\n        var key = keys[i];\n        if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n};\n</code></pre>\n<h2>_.property</h2>\n<pre><code class=\"language-js\">return _.property(value);\n</code></pre>\n<p>这个就是处理当 value 是基本类型的值的时候，返回元素对应的属性值的情况：</p>\n<pre><code class=\"language-js\">var result = _.map([{name: 'Kevin'}, {name: 'Daisy'}], 'name'); // ['Kevin', 'daisy']\n</code></pre>\n<p>我们看下源码：</p>\n<pre><code class=\"language-js\">_.property = function(path) {\n    // 如果不是数组\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function(obj) {\n        return deepGet(obj, path);\n    };\n};\n\nvar shallowProperty = function(key) {\n    return function(obj) {\n        return obj == null ? void 0 : obj[key];\n    };\n};\n\n// 根据路径取出深层次的值\nvar deepGet = function(obj, path) {\n    var length = path.length;\n    for (var i = 0; i &lt; length; i++) {\n        if (obj == null) return void 0;\n        obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n};\n</code></pre>\n<p>我们好像发现了新大陆，原来 value 还可以传一个数组，用来取深层次的值，举个例子：</p>\n<pre><code class=\"language-js\">var person1 = {\n    child: {\n        nickName: 'Kevin'\n    }\n}\n\nvar person2 = {\n    child: {\n        nickName: 'Daisy'\n    }\n}\n\nvar result = _.map([person1, person2], ['child', 'nickName']); \nconsole.log(result) // ['Kevin', 'daisy']\n</code></pre>\n<h2>最后</h2>\n<p>如果你想学习 underscore 的源码，在分析集合相关的函数时一定会接触 cb 和 optimizeCb 函数，先掌握这两个函数，会帮助你更好更快的解读源码。</p>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}