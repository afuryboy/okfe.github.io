{"code":0,"data":"<h2>Decorator</h2>\n<p>装饰器主要用于:</p>\n<ol>\n<li>装饰类</li>\n<li>装饰方法或属性</li>\n</ol>\n<h3>装饰类</h3>\n<pre><code class=\"language-js\">@annotation\nclass MyClass { }\n\nfunction annotation(target) {\n   target.annotated = true;\n}\n</code></pre>\n<h3>装饰方法或属性</h3>\n<pre><code class=\"language-js\">class MyClass {\n  @readonly\n  method() { }\n}\n\nfunction readonly(target, name, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n</code></pre>\n<h2>Babel</h2>\n<h3>安装编译</h3>\n<p>我们可以在 Babel 官网的 <a href=\"https://babeljs.io/repl/build/8875/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=GYVwdgxgLglg9mABAZzgWwKYBEMTgJwEMoCAKAawBtDlkAaRcjATwYBMNkIBKRAbwBQiRPgxQQ-JBy4BuAQF8BAqPmb8hiCNVqIAYnDjrhwgAKpMOPERL4NwgOZiU6DAEEIETqnylefRcKK8prEEAAWiKQY-Ph-GnhgqJQYAHTR-GTp3HLyQA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=7.0.0-rc.1%2Bpr.8505&amp;envVersion=\">Try it out</a>，查看 Babel 编译后的代码。</p>\n<p>不过我们也可以选择本地编译：</p>\n<pre><code class=\"language-bash\">npm init\n\nnpm install --save-dev @babel/core @babel/cli\n\nnpm install --save-dev @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties\n</code></pre>\n<p>新建 .babelrc 文件</p>\n<pre><code class=\"language-json\">{\n  &quot;plugins&quot;: [\n    [&quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true }],\n    [&quot;@babel/plugin-proposal-class-properties&quot;, {&quot;loose&quot;: true}]\n  ]\n}\n</code></pre>\n<p>再编译指定的文件</p>\n<pre><code class=\"language-bash\">babel decorator.js --out-file decorator-compiled.js\n</code></pre>\n<h3>装饰类的编译</h3>\n<p>编译前：</p>\n<pre><code class=\"language-js\">@annotation\nclass MyClass { }\n\nfunction annotation(target) {\n   target.annotated = true;\n}\n</code></pre>\n<p>编译后：</p>\n<pre><code class=\"language-js\">var _class;\n\nlet MyClass = annotation(_class = class MyClass {}) || _class;\n\nfunction annotation(target) {\n  target.annotated = true;\n}\n</code></pre>\n<p>我们可以看到对于类的装饰，其原理就是：</p>\n<pre><code class=\"language-js\">@decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A;\n</code></pre>\n<h3>装饰方法的编译</h3>\n<p>编译前：</p>\n<pre><code class=\"language-js\">class MyClass {\n  @unenumerable\n  @readonly\n  method() { }\n}\n\nfunction readonly(target, name, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nfunction unenumerable(target, name, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n</code></pre>\n<p>编译后：</p>\n<pre><code class=\"language-js\">var _class;\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context ) {\n\t/**\n\t * 第一部分\n\t * 拷贝属性\n\t */\n\tvar desc = {};\n\tObject[&quot;ke&quot; + &quot;ys&quot;](descriptor).forEach(function(key) {\n\t\tdesc[key] = descriptor[key];\n\t});\n\tdesc.enumerable = !!desc.enumerable;\n\tdesc.configurable = !!desc.configurable;\n\n\tif (&quot;value&quot; in desc || desc.initializer) {\n\t\tdesc.writable = true;\n\t}\n\n\t/**\n\t * 第二部分\n\t * 应用多个 decorators\n\t */\n\tdesc = decorators\n\t\t.slice()\n\t\t.reverse()\n\t\t.reduce(function(desc, decorator) {\n\t\t\treturn decorator(target, property, desc) || desc;\n\t\t}, desc);\n\n\t/**\n\t * 第三部分\n\t * 设置要 decorators 的属性\n\t */\n\tif (context &amp;&amp; desc.initializer !== void 0) {\n\t\tdesc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\t\tdesc.initializer = undefined;\n\t}\n\n\tif (desc.initializer === void 0) {\n\t\tObject[&quot;define&quot; + &quot;Property&quot;](target, property, desc);\n\t\tdesc = null;\n\t}\n\n\treturn desc;\n}\n\nlet MyClass = ((_class = class MyClass {\n\tmethod() {}\n}),\n_applyDecoratedDescriptor(\n\t_class.prototype,\n\t&quot;method&quot;,\n\t[readonly],\n\tObject.getOwnPropertyDescriptor(_class.prototype, &quot;method&quot;),\n\t_class.prototype\n),\n_class);\n\nfunction readonly(target, name, descriptor) {\n\tdescriptor.writable = false;\n\treturn descriptor;\n}\n</code></pre>\n<h3>装饰方法的编译源码解析</h3>\n<p>我们可以看到 Babel 构建了一个 _applyDecoratedDescriptor 函数，用于给方法装饰。</p>\n<h4>Object.getOwnPropertyDescriptor()</h4>\n<p>在传入参数的时候，我们使用了一个 Object.getOwnPropertyDescriptor() 方法，我们来看下这个方法：</p>\n<blockquote>\n<p>Object.getOwnPropertyDescriptor() 方法返回指定对象上的一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>\n</blockquote>\n<p>顺便注意这是一个 ES5 的方法。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">const foo = { value: 1 };\nconst bar = Object.getOwnPropertyDescriptor(foo, &quot;value&quot;);\n// bar {\n//   value: 1,\n//   writable: true\n//   enumerable: true,\n//   configurable: true,\n// }\n\nconst foo = { get value() { return 1; } };\nconst bar = Object.getOwnPropertyDescriptor(foo, &quot;value&quot;);\n// bar {\n//   get: /*the getter function*/,\n//   set: undefined\n//   enumerable: true,\n//   configurable: true,\n// }\n</code></pre>\n<h4>第一部分源码解析</h4>\n<p>在 _applyDecoratedDescriptor 函数内部，我们首先将 Object.getOwnPropertyDescriptor() 返回的属性描述符对象做了一份拷贝：</p>\n<pre><code class=\"language-js\">// 拷贝一份 descriptor\nvar desc = {};\nObject[&quot;ke&quot; + &quot;ys&quot;](descriptor).forEach(function(key) {\n\tdesc[key] = descriptor[key];\n});\ndesc.enumerable = !!desc.enumerable;\ndesc.configurable = !!desc.configurable;\n\n// 如果没有 value 属性或者没有 initializer 属性，表明是 getter 和 setter\nif (&quot;value&quot; in desc || desc.initializer) {\n\tdesc.writable = true;\n}\n</code></pre>\n<p>那么 initializer 属性是什么呢？Object.getOwnPropertyDescriptor() 返回的对象并不具有这个属性呀，确实，这是 Babel 的 Class 为了与 decorator 配合而产生的一个属性，比如说对于下面这种代码：</p>\n<pre><code class=\"language-js\">class MyClass {\n  @readonly\n  born = Date.now();\n}\n\nfunction readonly(target, name, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nvar foo = new MyClass();\nconsole.log(foo.born);\n</code></pre>\n<p>Babel 就会编译为：</p>\n<pre><code class=\"language-js\">// ...\n(_descriptor = _applyDecoratedDescriptor(_class.prototype, &quot;born&quot;, [readonly], {\n\tconfigurable: true,\n\tenumerable: true,\n\twritable: true,\n\tinitializer: function() {\n\t\treturn Date.now();\n\t}\n}))\n// ...\n</code></pre>\n<p>此时传入 _applyDecoratedDescriptor 函数的 descriptor 就具有 initializer 属性。</p>\n<h4>第二部分源码解析</h4>\n<p>接下是应用多个 decorators：</p>\n<pre><code class=\"language-js\">/**\n * 第二部分\n * @type {[type]}\n */\ndesc = decorators\n\t.slice()\n\t.reverse()\n\t.reduce(function(desc, decorator) {\n\t\treturn decorator(target, property, desc) || desc;\n\t}, desc);\n</code></pre>\n<p>对于一个方法应用了多个 decorator，比如：</p>\n<pre><code class=\"language-js\">class MyClass {\n  @unenumerable\n  @readonly\n  method() { }\n}\n</code></pre>\n<p>Babel 会编译为：</p>\n<pre><code class=\"language-jsx\">_applyDecoratedDescriptor(\n\t_class.prototype,\n\t&quot;method&quot;,\n\t[unenumerable, readonly],\n\tObject.getOwnPropertyDescriptor(_class.prototype, &quot;method&quot;),\n\t_class.prototype\n)\n</code></pre>\n<p>在第二部分的源码中，执行了 reverse() 和 reduce() 操作，由此我们也可以发现，如果同一个方法有多个装饰器，会由内向外执行。</p>\n<h4>第三部分源码解析</h4>\n<pre><code class=\"language-js\">/**\n * 第三部分\n * 设置要 decorators 的属性\n */\nif (context &amp;&amp; desc.initializer !== void 0) {\n\tdesc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\tdesc.initializer = undefined;\n}\n\nif (desc.initializer === void 0) {\n\tObject[&quot;define&quot; + &quot;Property&quot;](target, property, desc);\n\tdesc = null;\n}\n\nreturn desc;\n</code></pre>\n<p>如果 desc 有 initializer 属性，意味着当装饰的是类的属性时，会将 value 的值设置为:</p>\n<pre><code class=\"language-jsx\">desc.initializer.call(context)\n</code></pre>\n<p>而 context 的值为 <code>_class.prototype</code>，之所以要 <code>call(context)</code>，这也很好理解，因为有可能</p>\n<pre><code class=\"language-js\">class MyClass {\n  @readonly\n  value = this.getNum() + 1;\n\n  getNum() {\n    return 1;\n  }\n}\n</code></pre>\n<p>最后无论是装饰方法还是属性，都会执行：</p>\n<pre><code class=\"language-js\">Object[&quot;define&quot; + &quot;Property&quot;](target, property, desc);\n</code></pre>\n<p>由此可见，装饰方法本质上还是使用 <code>Object.defineProperty()</code> 来实现的。</p>\n<h2>应用</h2>\n<h3>1.log</h3>\n<p>为一个方法添加 log 函数，检查输入的参数：</p>\n<pre><code class=\"language-js\">class Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nfunction log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n\n  descriptor.value = function(...args) {\n    console.log(`Calling ${name} with`, args);\n    return oldValue.apply(this, args);\n  };\n\n  return descriptor;\n}\n\nconst math = new Math();\n\n// Calling add with [2, 4]\nmath.add(2, 4);\n</code></pre>\n<p>再完善点：</p>\n<pre><code class=\"language-js\">let log = (type) =&gt; {\n  return (target, name, descriptor) =&gt; {\n    const method = descriptor.value;\n    descriptor.value =  (...args) =&gt; {\n      console.info(`(${type}) 正在执行: ${name}(${args}) = ?`);\n      let ret;\n      try {\n        ret = method.apply(target, args);\n        console.info(`(${type}) 成功 : ${name}(${args}) =&gt; ${ret}`);\n      } catch (error) {\n        console.error(`(${type}) 失败: ${name}(${args}) =&gt; ${error}`);\n      }\n      return ret;\n    }\n  }\n};\n</code></pre>\n<h3>2.autobind</h3>\n<pre><code class=\"language-js\">class Person {\n  @autobind\n  getPerson() {\n  \treturn this;\n  }\n}\n\nlet person = new Person();\nlet { getPerson } = person;\n\ngetPerson() === person;\n// true\n</code></pre>\n<p>我们很容易想到的一个场景是 React 绑定事件的时候：</p>\n<pre><code class=\"language-jsx\">class Toggle extends React.Component {\n\n  @autobind\n  handleClick() {\n\t  console.log(this)\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        button\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<p>我们来写这样一个 autobind 函数：</p>\n<pre><code class=\"language-js\">const { defineProperty, getPrototypeOf} = Object;\n\nfunction bind(fn, context) {\n  if (fn.bind) {\n    return fn.bind(context);\n  } else {\n    return function __autobind__() {\n      return fn.apply(context, arguments);\n    };\n  }\n}\n\nfunction createDefaultSetter(key) {\n  return function set(newValue) {\n    Object.defineProperty(this, key, {\n      configurable: true,\n      writable: true,\n      enumerable: true,\n      value: newValue\n    });\n\n    return newValue;\n  };\n}\n\nfunction autobind(target, key, { value: fn, configurable, enumerable }) {\n  if (typeof fn !== 'function') {\n    throw new SyntaxError(`@autobind can only be used on functions, not: ${fn}`);\n  }\n\n  const { constructor } = target;\n\n  return {\n    configurable,\n    enumerable,\n\n    get() {\n\n      /**\n       * 使用这种方式相当于替换了这个函数，所以当比如\n       * Class.prototype.hasOwnProperty(key) 的时候，为了正确返回\n       * 所以这里做了 this 的判断\n       */\n      if (this === target) {\n        return fn;\n      }\n\n      const boundFn = bind(fn, this);\n\n      defineProperty(this, key, {\n        configurable: true,\n        writable: true,\n        enumerable: false,\n        value: boundFn\n      });\n\n      return boundFn;\n    },\n    set: createDefaultSetter(key)\n  };\n}\n</code></pre>\n<h3>3.debounce</h3>\n<p>有的时候，我们需要对执行的方法进行防抖处理:</p>\n<pre><code class=\"language-jsx\">class Toggle extends React.Component {\n\n  @debounce(500, true)\n  handleClick() {\n    console.log('toggle')\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        button\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<p>我们来实现一下：</p>\n<pre><code class=\"language-js\">function _debounce(func, wait, immediate) {\n\n    var timeout;\n\n    return function () {\n        var context = this;\n        var args = arguments;\n\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            var callNow = !timeout;\n            timeout = setTimeout(function(){\n                timeout = null;\n            }, wait)\n            if (callNow) func.apply(context, args)\n        }\n        else {\n            timeout = setTimeout(function(){\n                func.apply(context, args)\n            }, wait);\n        }\n    }\n}\n\nfunction debounce(wait, immediate) {\n  return function handleDescriptor(target, key, descriptor) {\n    const callback = descriptor.value;\n\n    if (typeof callback !== 'function') {\n      throw new SyntaxError('Only functions can be debounced');\n    }\n\n    var fn = _debounce(callback, wait, immediate)\n\n    return {\n      ...descriptor,\n      value() {\n        fn()\n      }\n    };\n  }\n}\n</code></pre>\n<h3>4.time</h3>\n<p>用于统计方法执行的时间:</p>\n<pre><code class=\"language-js\">function time(prefix) {\n  let count = 0;\n  return function handleDescriptor(target, key, descriptor) {\n\n    const fn = descriptor.value;\n\n    if (prefix == null) {\n      prefix = `${target.constructor.name}.${key}`;\n    }\n\n    if (typeof fn !== 'function') {\n      throw new SyntaxError(`@time can only be used on functions, not: ${fn}`);\n    }\n\n    return {\n      ...descriptor,\n      value() {\n        const label = `${prefix}-${count}`;\n        count++;\n        console.time(label);\n\n        try {\n          return fn.apply(this, arguments);\n        } finally {\n          console.timeEnd(label);\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<h3>5.mixin</h3>\n<p>用于将对象的方法混入 Class 中：</p>\n<pre><code class=\"language-js\">const SingerMixin = {\n  sing(sound) {\n    alert(sound);\n  }\n};\n\nconst FlyMixin = {\n  // All types of property descriptors are supported\n  get speed() {},\n  fly() {},\n  land() {}\n};\n\n@mixin(SingerMixin, FlyMixin)\nclass Bird {\n  singMatingCall() {\n    this.sing('tweet tweet');\n  }\n}\n\nvar bird = new Bird();\nbird.singMatingCall();\n// alerts &quot;tweet tweet&quot;\n</code></pre>\n<p>mixin 的一个简单实现如下：</p>\n<pre><code class=\"language-js\">function mixin(...mixins) {\n  return target =&gt; {\n    if (!mixins.length) {\n      throw new SyntaxError(`@mixin() class ${target.name} requires at least one mixin as an argument`);\n    }\n\n    for (let i = 0, l = mixins.length; i &lt; l; i++) {\n      const descs = Object.getOwnPropertyDescriptors(mixins[i]);\n      const keys = Object.getOwnPropertyNames(descs);\n\n      for (let j = 0, k = keys.length; j &lt; k; j++) {\n        const key = keys[j];\n\n        if (!target.prototype.hasOwnProperty(key)) {\n          Object.defineProperty(target.prototype, key, descs[key]);\n        }\n      }\n    }\n  };\n}\n</code></pre>\n<h3>6.redux</h3>\n<p>实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。</p>\n<pre><code class=\"language-js\">class MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n</code></pre>\n<p>有了装饰器，就可以改写上面的代码。</p>\n<pre><code class=\"language-js\">@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {};\n</code></pre>\n<p>相对来说，后一种写法看上去更容易理解。</p>\n<h3>7.注意</h3>\n<p>以上我们都是用于修饰类方法，我们获取值的方式为：</p>\n<pre><code class=\"language-js\">const method = descriptor.value;\n</code></pre>\n<p>但是如果我们修饰的是类的实例属性，因为 Babel 的缘故，通过 value 属性并不能获取值，我们可以写成：</p>\n<pre><code class=\"language-js\">const value = descriptor.initializer &amp;&amp; descriptor.initializer();\n</code></pre>\n<h2>参考</h2>\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/decorator\">ECMAScript 6 入门</a></li>\n<li><a href=\"https://github.com/jayphelps/core-decorators#mixin-alias-mixins\">core-decorators</a></li>\n<li><a href=\"http://taobaofed.org/blog/2015/11/16/es7-decorator/\">ES7 Decorator 装饰者模式</a></li>\n<li><a href=\"https://juejin.im/post/59f1c484f265da431c6f8940#heading-2\">JS 装饰器（Decorator）场景实战</a></li>\n</ol>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}