{"code":0,"data":"<h2>基本介绍</h2>\n<p>ES6 提供了新的数据结构 Set。</p>\n<p>它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<h2>初始化</h2>\n<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>\n<pre><code class=\"language-js\">let set = new Set();\n</code></pre>\n<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>\n<pre><code class=\"language-js\">let set = new Set([1, 2, 3, 4, 4]);\nconsole.log(set); // Set(4) {1, 2, 3, 4}\n\nset = new Set(document.querySelectorAll('div'));\nconsole.log(set.size); // 66\n\nset = new Set(new Set([1, 2, 3, 4]));\nconsole.log(set.size); // 4\n</code></pre>\n<h2>属性和方法</h2>\n<p>操作方法有：</p>\n<ol>\n<li>add(value)：添加某个值，返回 Set 结构本身。</li>\n<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员。</li>\n<li>clear()：清除所有成员，无返回值。</li>\n</ol>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">let set = new Set();\nconsole.log(set.add(1).add(2)); // Set [ 1, 2 ]\n\nconsole.log(set.delete(2)); // true\nconsole.log(set.has(2)); // false\n\nconsole.log(set.clear()); // undefined\nconsole.log(set.has(1)); // false\n</code></pre>\n<p>之所以每个操作都 console 一下，就是为了让大家注意每个操作的返回值。</p>\n<p>遍历方法有：</p>\n<ol>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回键值对的遍历器</li>\n<li>forEach()：使用回调函数遍历每个成员，无返回值</li>\n</ol>\n<p><strong>注意 keys()、values()、entries() 返回的是遍历器</strong></p>\n<pre><code class=\"language-js\">let set = new Set(['a', 'b', 'c']);\nconsole.log(set.keys()); // SetIterator {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}\nconsole.log([...set.keys()]); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n</code></pre>\n<pre><code class=\"language-js\">let set = new Set(['a', 'b', 'c']);\nconsole.log(set.values()); // SetIterator {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}\nconsole.log([...set.values()]); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n</code></pre>\n<pre><code class=\"language-js\">let set = new Set(['a', 'b', 'c']);\nconsole.log(set.entries()); // SetIterator {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}\nconsole.log([...set.entries()]); // [[&quot;a&quot;, &quot;a&quot;], [&quot;b&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;c&quot;]]\n</code></pre>\n<pre><code class=\"language-js\">let set = new Set([1, 2, 3]);\nset.forEach((value, key) =&gt; console.log(key + ': ' + value));\n// 1: 1\n// 2: 2\n// 3: 3\n</code></pre>\n<p>属性：</p>\n<ol>\n<li>Set.prototype.constructor：构造函数，默认就是 Set 函数。</li>\n<li>Set.prototype.size：返回 Set 实例的成员总数。</li>\n</ol>\n<h2>模拟实现第一版</h2>\n<p>如果要模拟实现一个简单的 Set 数据结构，实现 add、delete、has、clear、forEach 方法，还是很容易写出来的，这里直接给出代码：</p>\n<pre><code class=\"language-js\">/**\n * 模拟实现第一版\n */\n(function(global) {\n\n    function Set(data) {\n        this._values = [];\n        this.size = 0;\n\n        data &amp;&amp; data.forEach(function(item) {\n            this.add(item);\n        }, this);\n    }\n\n    Set.prototype['add'] = function(value) {\n        if (this._values.indexOf(value) == -1) {\n            this._values.push(value);\n            ++this.size;\n        }\n        return this;\n    }\n\n    Set.prototype['has'] = function(value) {\n        return (this._values.indexOf(value) !== -1);\n    }\n\n    Set.prototype['delete'] = function(value) {\n        var idx = this._values.indexOf(value);\n        if (idx == -1) return false;\n        this._values.splice(idx, 1);\n        --this.size;\n        return true;\n    }\n\n    Set.prototype['clear'] = function(value) {\n        this._values = [];\n        this.size = 0;\n    }\n\n    Set.prototype['forEach'] = function(callbackFn, thisArg) {\n        thisArg = thisArg || global;\n        for (var i = 0; i &lt; this._values.length; i++) {\n            callbackFn.call(thisArg, this._values[i], this._values[i], this);\n        }\n    }\n\n    Set.length = 0;\n\n    global.Set = Set;\n\n})(this)\n</code></pre>\n<p>我们可以写段测试代码：</p>\n<pre><code class=\"language-js\">let set = new Set([1, 2, 3, 4, 4]);\nconsole.log(set.size); // 4\n\nset.delete(1);\nconsole.log(set.has(1)); // false\n\nset.clear();\nconsole.log(set.size); // 0\n\nset = new Set([1, 2, 3, 4, 4]);\nset.forEach((value, key, set) =&gt; {\n\tconsole.log(value, key, set.size)\n});\n// 1 1 4\n// 2 2 4\n// 3 3 4\n// 4 4 4\n</code></pre>\n<h2>模拟实现第二版</h2>\n<p>在第一版中，我们使用 indexOf 来判断添加的元素是否重复，本质上，还是使用 === 来进行比较，对于 NaN 而言，因为：</p>\n<pre><code class=\"language-js\">console.log([NaN].indexOf(NaN)); // -1\n</code></pre>\n<p>模拟实现的 Set 其实可以添加多个 NaN 而不会去重，然而对于真正的 Set 数据结构：</p>\n<pre><code class=\"language-js\">let set = new Set();\nset.add(NaN);\nset.add(NaN);\nconsole.log(set.size); // 1\n</code></pre>\n<p>所以我们需要对 NaN 这个值进行单独的处理。</p>\n<p>处理的方式是当判断添加的值是 NaN 时，将其替换为一个独一无二的值，比如说一个很难重复的字符串类似于 <code>@@NaNValue</code>，当然了，说到独一无二的值，我们也可以直接使用 Symbol，代码如下：</p>\n<pre><code class=\"language-js\">/**\n * 模拟实现第二版\n */\n(function(global) {\n\n    var NaNSymbol = Symbol('NaN');\n\n    var encodeVal = function(value) {\n        return value !== value ? NaNSymbol : value;\n    }\n\n    var decodeVal = function(value) {\n        return (value === NaNSymbol) ? NaN : value;\n    }\n\n    function Set(data) {\n        this._values = [];\n        this.size = 0;\n\n        data &amp;&amp; data.forEach(function(item) {\n            this.add(item);\n        }, this);\n\n    }\n\n    Set.prototype['add'] = function(value) {\n        value = encodeVal(value);\n        if (this._values.indexOf(value) == -1) {\n            this._values.push(value);\n            ++this.size;\n        }\n        return this;\n    }\n\n    Set.prototype['has'] = function(value) {\n        return (this._values.indexOf(encodeVal(value)) !== -1);\n    }\n\n    Set.prototype['delete'] = function(value) {\n        var idx = this._values.indexOf(encodeVal(value));\n        if (idx == -1) return false;\n        this._values.splice(idx, 1);\n        --this.size;\n        return true;\n    }\n\n    Set.prototype['clear'] = function(value) {\n        ...\n    }\n\n    Set.prototype['forEach'] = function(callbackFn, thisArg) {\n        ...\n    }\n\n    Set.length = 0;\n\n    global.Set = Set;\n\n})(this)\n</code></pre>\n<p>写段测试用例：</p>\n<pre><code class=\"language-js\">let set = new Set([1, 2, 3]);\n\nset.add(NaN);\nconsole.log(set.size); // 3\n\nset.add(NaN);\nconsole.log(set.size); // 3\n</code></pre>\n<h2>模拟实现第三版</h2>\n<p>在模拟实现 Set 时，最麻烦的莫过于迭代器的实现和处理，比如初始化以及执行 keys()、values()、entries() 方法时都会返回迭代器：</p>\n<pre><code class=\"language-js\">let set = new Set([1, 2, 3]);\n\nconsole.log([...set]); // [1, 2, 3]\nconsole.log(set.keys()); // SetIterator {1, 2, 3}\nconsole.log([...set.keys()]); // [1, 2, 3]\nconsole.log([...set.values()]); // [1, 2, 3]\nconsole.log([...set.entries()]); // [[1, 1], [2, 2], [3, 3]]\n</code></pre>\n<p>而且 Set 也支持初始化的时候传入迭代器：</p>\n<pre><code class=\"language-js\">let set = new Set(new Set([1, 2, 3]));\nconsole.log(set.size); // 3\n</code></pre>\n<p>当初始化传入一个迭代器的时候，我们可以根据我们在上一篇 <a href=\"https://github.com/mqyqingfeng/Blog/issues/90\">《ES6 系列之迭代器与 for of》</a>中模拟实现的 forOf 函数，遍历传入的迭代器的 Symbol.iterator 接口，然后依次执行 add 方法。</p>\n<p>而当执行 keys() 方法时，我们可以返回一个对象，然后为其部署 Symbol.iterator 接口，实现的代码，也是最终的代码如下：</p>\n<pre><code class=\"language-js\">/**\n * 模拟实现第三版\n */\n(function(global) {\n\n    var NaNSymbol = Symbol('NaN');\n\n    var encodeVal = function(value) {\n        return value !== value ? NaNSymbol : value;\n    }\n\n    var decodeVal = function(value) {\n        return (value === NaNSymbol) ? NaN : value;\n    }\n\n    var makeIterator = function(array, iterator) {\n        var nextIndex = 0;\n\n        // new Set(new Set()) 会调用这里\n        var obj = {\n            next: function() {\n                return nextIndex &lt; array.length ? { value: iterator(array[nextIndex++]), done: false } : { value: void 0, done: true };\n            }\n        };\n\n        // [...set.keys()] 会调用这里\n        obj[Symbol.iterator] = function() {\n            return obj\n        }\n\n        return obj\n    }\n\n    function forOf(obj, cb) {\n        let iterable, result;\n\n        if (typeof obj[Symbol.iterator] !== &quot;function&quot;) throw new TypeError(obj + &quot; is not iterable&quot;);\n        if (typeof cb !== &quot;function&quot;) throw new TypeError('cb must be callable');\n\n        iterable = obj[Symbol.iterator]();\n\n        result = iterable.next();\n        while (!result.done) {\n            cb(result.value);\n            result = iterable.next();\n        }\n    }\n\n    function Set(data) {\n        this._values = [];\n        this.size = 0;\n\n        forOf(data, (item) =&gt; {\n            this.add(item);\n        })\n\n    }\n\n    Set.prototype['add'] = function(value) {\n        value = encodeVal(value);\n        if (this._values.indexOf(value) == -1) {\n            this._values.push(value);\n            ++this.size;\n        }\n        return this;\n    }\n\n    Set.prototype['has'] = function(value) {\n        return (this._values.indexOf(encodeVal(value)) !== -1);\n    }\n\n    Set.prototype['delete'] = function(value) {\n        var idx = this._values.indexOf(encodeVal(value));\n        if (idx == -1) return false;\n        this._values.splice(idx, 1);\n        --this.size;\n        return true;\n    }\n\n    Set.prototype['clear'] = function(value) {\n        this._values = [];\n        this.size = 0;\n    }\n\n    Set.prototype['forEach'] = function(callbackFn, thisArg) {\n        thisArg = thisArg || global;\n        for (var i = 0; i &lt; this._values.length; i++) {\n            callbackFn.call(thisArg, this._values[i], this._values[i], this);\n        }\n    }\n\n    Set.prototype['values'] = Set.prototype['keys'] = function() {\n        return makeIterator(this._values, function(value) { return decodeVal(value); });\n    }\n\n    Set.prototype['entries'] = function() {\n        return makeIterator(this._values, function(value) { return [decodeVal(value), decodeVal(value)]; });\n    }\n\n    Set.prototype[Symbol.iterator] = function(){\n        return this.values();\n    }\n\n    Set.prototype['forEach'] = function(callbackFn, thisArg) {\n        thisArg = thisArg || global;\n        var iterator = this.entries();\n\n        forOf(iterator, (item) =&gt; {\n            callbackFn.call(thisArg, item[1], item[0], this);\n        })\n    }\n\n    Set.length = 0;\n\n    global.Set = Set;\n\n})(this)\n</code></pre>\n<p>写段测试代码：</p>\n<pre><code class=\"language-js\">let set = new Set(new Set([1, 2, 3]));\nconsole.log(set.size); // 3\n\nconsole.log([...set.keys()]); // [1, 2, 3]\nconsole.log([...set.values()]); // [1, 2, 3]\nconsole.log([...set.entries()]); // [1, 2, 3]\n</code></pre>\n<h2>QUnit</h2>\n<p>由上我们也可以发现，每当我们进行一版的修改时，只是写了新的测试代码，但是代码改写后，对于之前的测试代码是否还能生效呢？是否不小心改了什么导致以前的测试代码没有通过呢？</p>\n<p>为了解决这个问题，针对模拟实现 Set 这样一个简单的场景，我们可以引入 QUnit 用于编写测试用例，我们新建一个 HTML 文件：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;\n    &lt;title&gt;Set 的模拟实现&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;qunit-2.4.0.css&quot;&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;qunit-2.4.0.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;polyfill-set.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<p>编写测试用例，因为语法比较简单，我们就直接看编写的一些例子：</p>\n<pre><code class=\"language-js\">QUnit.test(&quot;unique value&quot;, function(assert) {\n    const set = new Set([1, 2, 3, 4, 4]);\n    assert.deepEqual([...set], [1, 2, 3, 4], &quot;Passed!&quot;);\n});\n\nQUnit.test(&quot;unique value&quot;, function(assert) {\n    const set = new Set(new Set([1, 2, 3, 4, 4]));\n    assert.deepEqual([...set], [1, 2, 3, 4], &quot;Passed!&quot;);\n});\n\nQUnit.test(&quot;NaN&quot;, function(assert) {\n    const items = new Set([NaN, NaN]);\n    assert.ok(items.size == 1, &quot;Passed!&quot;);\n});\n\nQUnit.test(&quot;Object&quot;, function(assert) {\n    const items = new Set([{}, {}]);\n    assert.ok(items.size == 2, &quot;Passed!&quot;);\n});\n\nQUnit.test(&quot;set.keys&quot;, function(assert) {\n    let set = new Set(['red', 'green', 'blue']);\n    assert.deepEqual([...set.keys()], [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;], &quot;Passed!&quot;);\n});\n\n\nQUnit.test(&quot;set.forEach&quot;, function(assert) {\n    let temp = [];\n    let set = new Set([1, 2, 3]);\n    set.forEach((value, key) =&gt; temp.push(value * 2) )\n\n    assert.deepEqual(temp, [2, 4, 6], &quot;Passed!&quot;);\n});\n</code></pre>\n<p>用浏览器预览 HTML 页面，效果如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/qunit/qunit.png\" alt=\"Qunit截图\"></p>\n<p>完整的 polyfill 及 Qunit 源码在 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/qunit\">https://github.com/mqyqingfeng/Blog/tree/master/demos/qunit</a>。</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}