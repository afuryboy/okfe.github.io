{"code":0,"data":"<h2>前言</h2>\n<p>在阅读 《ECMAScript 6 入门》的时候，零散的看到有私有变量的实现，所以在此总结一篇。</p>\n<h2>1. 约定</h2>\n<h3>实现</h3>\n<pre><code class=\"language-js\">class Example {\n\tconstructor() {\n\t\tthis._private = 'private';\n\t}\n\tgetName() {\n\t\treturn this._private\n\t}\n}\n\nvar ex = new Example();\n\nconsole.log(ex.getName()); // private\nconsole.log(ex._private); // private\n</code></pre>\n<h3>优点</h3>\n<ol>\n<li>写法简单</li>\n<li>调试方便</li>\n<li>兼容性好</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n<li>外部可以访问和修改</li>\n<li>语言没有配合的机制，如 for in 语句会将所有属性枚举出来</li>\n<li>命名冲突</li>\n</ol>\n<h2>2. 闭包</h2>\n<h3>实现一</h3>\n<pre><code class=\"language-js\">/**\n * 实现一\n */\nclass Example {\n  constructor() {\n    var _private = '';\n    _private = 'private';\n    this.getName = function() {return _private}\n  }\n}\n\nvar ex = new Example();\n\nconsole.log(ex.getName()); // private\nconsole.log(ex._private); // undefined\n</code></pre>\n<h3>优点</h3>\n<ol>\n<li>无命名冲突</li>\n<li>外部无法访问和修改</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n<li>constructor 的逻辑变得复杂。构造函数应该只做对象初始化的事情，现在为了实现私有变量，必须包含部分方法的实现，代码组织上略不清晰。</li>\n<li>方法存在于实例，而非原型上，子类也无法使用 super 调用</li>\n<li>构建增加一点点开销</li>\n</ol>\n<h3>实现二</h3>\n<pre><code class=\"language-js\">/**\n * 实现二\n */\nconst Example = (function() {\n  var _private = '';\n\n  class Example {\n    constructor() {\n      _private = 'private';\n    }\n    getName() {\n      return _private;\n    }\n  }\n\n  return Example;\n\n})();\n\nvar ex = new Example();\n\nconsole.log(ex.getName()); // private\nconsole.log(ex._private); // undefined\n</code></pre>\n<h3>优点</h3>\n<ol>\n<li>无命名冲突</li>\n<li>外部无法访问和修改</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n<li>写法有一点复杂</li>\n<li>构建增加一点点开销</li>\n</ol>\n<h2>3. Symbol</h2>\n<h3>实现</h3>\n<pre><code class=\"language-js\">const Example = (function() {\n    var _private = Symbol('private');\n\n    class Example {\n        constructor() {\n          this[_private] = 'private';\n        }\n        getName() {\n          return this[_private];\n        }\n    }\n\n    return Example;\n})();\n\nvar ex = new Example();\n\nconsole.log(ex.getName()); // private\nconsole.log(ex.name); // undefined\n</code></pre>\n<h3>优点</h3>\n<ol>\n<li>无命名冲突</li>\n<li>外部无法访问和修改</li>\n<li>无性能损失</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n<li>写法稍微复杂</li>\n<li>兼容性也还好</li>\n</ol>\n<h2>4. WeakMap</h2>\n<h3>实现</h3>\n<pre><code class=\"language-js\">/**\n * 实现一\n */\nconst _private = new WeakMap();\n\nclass Example {\n  constructor() {\n    _private.set(this, 'private');\n  }\n  getName() {\n  \treturn _private.get(this);\n  }\n}\n\nvar ex = new Example();\n\nconsole.log(ex.getName()); // private\nconsole.log(ex.name); // undefined\n</code></pre>\n<p>如果这样写，你可能觉得封装性不够，你也可以这样写：</p>\n<pre><code class=\"language-js\">/**\n * 实现二\n */\nconst Example = (function() {\n  var _private = new WeakMap(); // 私有成员存储容器\n\n  class Example {\n    constructor() {\n      _private.set(this, 'private');\n    }\n    getName() {\n    \treturn _private.get(this);\n    }\n  }\n\n  return Example;\n})();\n\nvar ex = new Example();\n\nconsole.log(ex.getName()); // private\nconsole.log(ex.name); // undefined\n</code></pre>\n<h3>优点</h3>\n<ol>\n<li>无命名冲突</li>\n<li>外部无法访问和修改</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n<li>写法比较麻烦</li>\n<li>兼容性有点问题</li>\n<li>有一定性能代价</li>\n</ol>\n<h2>5. 最新提案</h2>\n<pre><code class=\"language-js\">class Point {\n  #x;\n  #y;\n\n  constructor(x, y) {\n    this.#x = x;\n    this.#y = y;\n  }\n\n  equals(point) {\n    return this.#x === point.#x &amp;&amp; this.#y === point.#y;\n  }\n}\n</code></pre>\n<p>那么为什么不直接使用 private 字段呢？比如说这样：</p>\n<pre><code class=\"language-js\">class Foo {\n  private value;\n\n  equals(foo) {\n    return this.value === foo.value;\n  }\n}\n</code></pre>\n<p>简单点来说，就是嫌麻烦，当然也有性能上的考虑……</p>\n<p>举个例子，如果我们不使用 #，而是使用 private 关键字：</p>\n<pre><code class=\"language-js\">class Foo {\n  private value = '1';\n\n  equals(foo) {\n    return this.value === foo.value;\n  }\n}\n\nvar foo1 = new Foo();\nvar foo2 = new Foo();\n\nconsole.log(foo1.equals(foo2));\n</code></pre>\n<p>在这里我们新建了两个实例，然后将 foo2 作为参数传入了 foo1 的实例方法中。</p>\n<p>那么我们可以获取 foo2.value 的值吗？如果我们直接 <code>foo2.value</code> 肯定是获取不到值的，毕竟是私有变量，可是 equals 是 Foo 的一个类方法，那么可以获取到的吗？</p>\n<p>答案是可以的。</p>\n<p>其实这点在其他语言，比如说 Java 和 C++ 中也是一样的，<strong>类的成员函数中可以访问同类型实例的私有变量</strong>，这是因为私有是为了实现“对外”的信息隐藏，在类自己内部，没有必要禁止私有变量的访问，你也可以理解为私有变量的限制是以类为单位，而不是以对象为单位，此外这样做也可以为使用者带来便利。</p>\n<p>既然获取值是可以的，那么打印的结果应该为 true，但是如果我们传入的值不是 Foo 的实例，而是一个其他对象呢？</p>\n<pre><code class=\"language-js\">var foo1 = new Foo();\n\nconsole.log(foo1.equals({\n  value: 2\n}));\n</code></pre>\n<p>当然这里代码也是可以正常运行的，但是对于编译器来说，就有一点麻烦了，因为编译器不知道 value 到底是 foo 的正常属性还是私有属性，所以编译器需要做判断，先判断 foo 是不是 Foo 的实例，然后再接着获取值。</p>\n<p>这也意味着每次属性访问都需要做这样一个判断，而引擎已经围绕属性访问做了高度优化，懒得改，而且还降低速度。</p>\n<p>不过除了这个工作之外，还会有一些其他的内容需要考虑，比如说：</p>\n<ol>\n<li>你必须将私有的 key 编码进每个词法环境</li>\n<li>for in 可以遍历这些属性吗？</li>\n<li>私有属性和正常属性同名的时候，谁会屏蔽谁？</li>\n<li>怎么防止私有属性的名称不被探测出来。</li>\n</ol>\n<p>关于使用 # 而不使用 private 更多的讨论可以参考这个 <a href=\"https://github.com/tc39/proposal-private-fields/issues/14\">Issue</a>。</p>\n<p>当然这些问题都可以被解决啦，就是麻烦了点。</p>\n<p>而如果你选择 #，实现的方式将跟 JavaScript 对象属性完全没有关系，将会使用 <code>private slots</code> 的方式以及使用一个新的 slot 查找语法，总之就是会比 private 的实现方式简单很多。</p>\n<h2>参考</h2>\n<ol>\n<li><a href=\"https://v.qq.com/x/page/c0529qeku63.html\">《编程语言如何演化——以JS的private为例》贺师俊</a></li>\n<li><a href=\"http://exploringjs.com/es6/ch_classes.html#sec_private-data-for-classes\">Exploring ES6</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27360252\">译 JS 新语法：私有属性</a></li>\n</ol>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}