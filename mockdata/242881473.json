{"code":0,"data":"<h2>前言</h2>\n<p>jQuery 的 extend 是 jQuery 中应用非常多的一个函数，今天我们一边看 jQuery 的 extend 的特性，一边实现一个 extend!</p>\n<h2>extend 基本用法</h2>\n<p>先来看看 extend 的功能，引用 jQuery 官网：</p>\n<blockquote>\n<p>Merge the contents of two or more objects together into the first object.</p>\n</blockquote>\n<p>翻译过来就是，合并两个或者更多的对象的内容到第一个对象中。</p>\n<p>让我们看看 extend 的用法：</p>\n<pre><code class=\"language-js\">jQuery.extend( target [, object1 ] [, objectN ] )\n</code></pre>\n<p>第一个参数 target，表示要拓展的目标，我们就称它为目标对象吧。</p>\n<p>后面的参数，都传入对象，内容都会复制到目标对象中，我们就称它们为待复制对象吧。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">var obj1 = {\n    a: 1,\n    b: { b1: 1, b2: 2 }\n};\n\nvar obj2 = {\n    b: { b1: 3, b3: 4 },\n    c: 3\n};\n\nvar obj3 = {\n    d: 4\n}\n\nconsole.log($.extend(obj1, obj2, obj3));\n\n// {\n//    a: 1,\n//    b: { b1: 3, b3: 4 },\n//    c: 3,\n//    d: 4\n// }\n</code></pre>\n<p>当两个对象出现相同字段的时候，后者会覆盖前者，而不会进行深层次的覆盖。</p>\n<h2>extend 第一版</h2>\n<p>结合着上篇写得 <a href=\"https://github.com/mqyqingfeng/Blog/issues/32\">《JavaScript专题之深浅拷贝》</a>，我们尝试着自己写一个 extend 函数：</p>\n<pre><code class=\"language-js\">// 第一版\nfunction extend() {\n    var name, options, copy;\n    var length = arguments.length;\n    var i = 1;\n    var target = arguments[0];\n\n    for (; i &lt; length; i++) {\n        options = arguments[i];\n        if (options != null) {\n            for (name in options) {\n                copy = options[name];\n                if (copy !== undefined){\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    return target;\n};\n</code></pre>\n<h2>extend 深拷贝</h2>\n<p>那如何进行深层次的复制呢？jQuery v1.1.4 加入了一个新的用法：</p>\n<pre><code class=\"language-js\">jQuery.extend( [deep], target, object1 [, objectN ] )\n</code></pre>\n<p>也就是说，函数的第一个参数可以传一个布尔值，如果为 true，我们就会进行深拷贝，false 依然当做浅拷贝，这个时候，target 就往后移动到第二个参数。</p>\n<p>还是举这个例子：</p>\n<pre><code class=\"language-js\">var obj1 = {\n    a: 1,\n    b: { b1: 1, b2: 2 }\n};\n\nvar obj2 = {\n    b: { b1: 3, b3: 4 },\n    c: 3\n};\n\nvar obj3 = {\n    d: 4\n}\n\nconsole.log($.extend(true, obj1, obj2, obj3));\n\n// {\n//    a: 1,\n//    b: { b1: 3, b2: 2, b3: 4 },\n//    c: 3,\n//    d: 4\n// }\n</code></pre>\n<p>因为采用了深拷贝，会遍历到更深的层次进行添加和覆盖。</p>\n<h2>extend 第二版</h2>\n<p>我们来实现深拷贝的功能，值得注意的是：</p>\n<ol>\n<li>需要根据第一个参数的类型，确定 target 和要合并的对象的下标起始值。</li>\n<li>如果是深拷贝，根据 copy 的类型递归 extend。</li>\n</ol>\n<pre><code class=\"language-js\">// 第二版\nfunction extend() {\n    // 默认不进行深拷贝\n    var deep = false;\n    var name, options, src, copy;\n    var length = arguments.length;\n    // 记录要复制的对象的下标\n    var i = 1;\n    // 第一个参数不传布尔值的情况下，target默认是第一个参数\n    var target = arguments[0] || {};\n    // 如果第一个参数是布尔值，第二个参数是才是target\n    if (typeof target == 'boolean') {\n        deep = target;\n        target = arguments[i] || {};\n        i++;\n    }\n    // 如果target不是对象，我们是无法进行复制的，所以设为{}\n    if (typeof target !== 'object') {\n        target = {}\n    }\n\n    // 循环遍历要复制的对象们\n    for (; i &lt; length; i++) {\n        // 获取当前对象\n        options = arguments[i];\n        // 要求不能为空 避免extend(a,,b)这种情况\n        if (options != null) {\n            for (name in options) {\n                // 目标属性值\n                src = target[name];\n                // 要复制的对象的属性值\n                copy = options[name];\n\n                if (deep &amp;&amp; copy &amp;&amp; typeof copy == 'object') {\n                    // 递归调用\n                    target[name] = extend(deep, src, copy);\n                }\n                else if (copy !== undefined){\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    return target;\n};\n</code></pre>\n<p>在实现上，核心的部分还是跟上篇实现的深浅拷贝函数一致，如果要复制的对象的属性值是一个对象，就递归调用 extend。不过 extend 的实现中，多了很多细节上的判断，比如第一个参数是否是布尔值，target 是否是一个对象，不传参数时的默认值等。</p>\n<p>接下来，我们看几个 jQuery 的 extend 使用效果：</p>\n<h2>target 是函数</h2>\n<p>在我们的实现中，<code>typeof target</code> 必须等于 <code>object</code>，我们才会在这个 <code>target</code> 基础上进行拓展，然而我们用 <code>typeof</code> 判断一个函数时，会返回<code>function</code>，也就是说，我们无法在一个函数上进行拓展！</p>\n<p>什么，我们还能在一个函数上进行拓展！！</p>\n<p>当然啦，毕竟函数也是一种对象嘛，让我们看个例子：</p>\n<pre><code class=\"language-js\">function a() {}\n\na.target = 'b';\n\nconsole.log(a.target); // b\n</code></pre>\n<p>实际上，在 underscore 的实现中，underscore 的各种方法便是挂在了函数上！</p>\n<p>所以在这里我们还要判断是不是函数，这时候我们便可以使用<a href=\"https://github.com/mqyqingfeng/Blog/issues/28\">《JavaScript专题之类型判断(上)》</a>中写得 isFunction 函数</p>\n<p>我们这样修改：</p>\n<pre><code class=\"language-js\">if (typeof target !== &quot;object&quot; &amp;&amp; !isFunction(target)) {\n    target = {};\n}\n</code></pre>\n<h2>类型不一致</h2>\n<p>其实我们实现的方法有个小 bug ，不信我们写个 demo:</p>\n<pre><code class=\"language-js\">var obj1 = {\n    a: 1,\n    b: {\n        c: 2\n    }\n}\n\nvar obj2 = {\n    b: {\n        c: [5],\n\n    }\n}\n\nvar d = extend(true, obj1, obj2)\nconsole.log(d);\n</code></pre>\n<p>我们预期会返回这样一个对象：</p>\n<pre><code class=\"language-js\">{\n    a: 1,\n    b: {\n        c: [5]\n    }\n}\n</code></pre>\n<p>然而返回了这样一个对象:</p>\n<pre><code class=\"language-js\">{\n    a: 1,\n    b: {\n        c: {\n            0: 5\n        }\n    }\n}\n</code></pre>\n<p>让我们细细分析为什么会导致这种情况：</p>\n<p>首先我们在函数的开始写一个 console 函数比如：console.log(1)，然后以上面这个 demo 为例，执行一下，我们会发现 1 打印了三次，这就是说 extend 函数执行了三遍，让我们捋一捋这三遍传入的参数：</p>\n<p>第一遍执行到递归调用时：</p>\n<pre><code class=\"language-js\">var src = { c: 2 };\nvar copy = { c: [5]};\n\ntarget[name] = extend(true, src, copy);\n\n</code></pre>\n<p>第二遍执行到递归调用时：</p>\n<pre><code class=\"language-js\">var src = 2;\nvar copy = [5];\n\ntarget[name] = extend(true, src, copy);\n\n</code></pre>\n<p>第三遍进行最终的赋值，因为 src 是一个基本类型，我们默认使用一个空对象作为目标值，所以最终的结果就变成了对象的属性！</p>\n<p>为了解决这个问题，我们需要对目标属性值和待复制对象的属性值进行判断：</p>\n<p>判断目标属性值跟要复制的对象的属性值类型是否一致:</p>\n<ul>\n<li>\n<p>如果待复制对象属性值类型为数组，目标属性值类型不为数组的话，目标属性值就设为 []</p>\n</li>\n<li>\n<p>如果待复制对象属性值类型为对象，目标属性值类型不为对象的话，目标属性值就设为 {}</p>\n</li>\n</ul>\n<p>结合着<a href=\"https://github.com/mqyqingfeng/Blog/issues/30\">《JavaScript专题之类型判断(下)》</a>中的 isPlainObject 函数，我们可以对类型进行更细致的划分：</p>\n<pre><code class=\"language-js\">\nvar clone, copyIsArray;\n\n...\n\nif (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) ||\n        (copyIsArray = Array.isArray(copy)))) {\n\n    if (copyIsArray) {\n        copyIsArray = false;\n        clone = src &amp;&amp; Array.isArray(src) ? src : [];\n\n    } else {\n        clone = src &amp;&amp; isPlainObject(src) ? src : {};\n    }\n\n    target[name] = extend(deep, clone, copy);\n\n} else if (copy !== undefined) {\n    target[name] = copy;\n}\n</code></pre>\n<h2>循环引用</h2>\n<p>实际上，我们还可能遇到一个循环引用的问题，举个例子：</p>\n<pre><code class=\"language-js\">var a = {name : b};\nvar b = {name : a}\nvar c = extend(a, b);\nconsole.log(c);\n</code></pre>\n<p>我们会得到一个可以无限展开的对象，类似于这样：</p>\n<p><img src=\"https://github.com/mqyqingfeng/Blog/raw/master/Images/extend/extend1.png\" alt=\"循环引用对象\"></p>\n<p>为了避免这个问题，我们需要判断要复制的对象属性是否等于 target，如果等于，我们就跳过：</p>\n<pre><code class=\"language-js\">...\nsrc = target[name];\ncopy = options[name];\n\nif (target === copy) {\n    continue;\n}\n...\n</code></pre>\n<p>如果加上这句，结果就会是：</p>\n<pre><code class=\"language-js\">{name: undefined}\n</code></pre>\n<h2>最终代码</h2>\n<pre><code class=\"language-js\">\n// isPlainObject 函数来自于  [JavaScript专题之类型判断(下) ](https://github.com/mqyqingfeng/Blog/issues/30)\nvar class2type = {};\nvar toString = class2type.toString;\nvar hasOwn = class2type.hasOwnProperty;\n\nfunction isPlainObject(obj) {\n    var proto, Ctor;\n    if (!obj || toString.call(obj) !== &quot;[object Object]&quot;) {\n        return false;\n    }\n    proto = Object.getPrototypeOf(obj);\n    if (!proto) {\n        return true;\n    }\n    Ctor = hasOwn.call(proto, &quot;constructor&quot;) &amp;&amp; proto.constructor;\n    return typeof Ctor === &quot;function&quot; &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object);\n}\n\n\nfunction extend() {\n    // 默认不进行深拷贝\n    var deep = false;\n    var name, options, src, copy, clone, copyIsArray;\n    var length = arguments.length;\n    // 记录要复制的对象的下标\n    var i = 1;\n    // 第一个参数不传布尔值的情况下，target 默认是第一个参数\n    var target = arguments[0] || {};\n    // 如果第一个参数是布尔值，第二个参数是 target\n    if (typeof target == 'boolean') {\n        deep = target;\n        target = arguments[i] || {};\n        i++;\n    }\n    // 如果target不是对象，我们是无法进行复制的，所以设为 {}\n    if (typeof target !== &quot;object&quot; &amp;&amp; !isFunction(target)) {\n        target = {};\n    }\n\n    // 循环遍历要复制的对象们\n    for (; i &lt; length; i++) {\n        // 获取当前对象\n        options = arguments[i];\n        // 要求不能为空 避免 extend(a,,b) 这种情况\n        if (options != null) {\n            for (name in options) {\n                // 目标属性值\n                src = target[name];\n                // 要复制的对象的属性值\n                copy = options[name];\n\n                // 解决循环引用\n                if (target === copy) {\n                    continue;\n                }\n\n                // 要递归的对象必须是 plainObject 或者数组\n                if (deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) ||\n                        (copyIsArray = Array.isArray(copy)))) {\n                    // 要复制的对象属性值类型需要与目标属性值相同\n                    if (copyIsArray) {\n                        copyIsArray = false;\n                        clone = src &amp;&amp; Array.isArray(src) ? src : [];\n\n                    } else {\n                        clone = src &amp;&amp; isPlainObject(src) ? src : {};\n                    }\n\n                    target[name] = extend(deep, clone, copy);\n\n                } else if (copy !== undefined) {\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    return target;\n};\n</code></pre>\n<h2>思考题</h2>\n<p>如果觉得看明白了上面的代码，想想下面两个 demo 的结果：</p>\n<pre><code class=\"language-js\">var a = extend(true, [4, 5, 6, 7, 8, 9], [1, 2, 3]);\nconsole.log(a) // ???\n</code></pre>\n<pre><code class=\"language-js\">var obj1 = {\n    value: {\n        3: 1\n    }\n}\n\nvar obj2 = {\n    value: [5, 6, 7],\n\n}\n\nvar b = extend(true, obj1, obj2) // ???\nvar c = extend(true, obj2, obj1) // ???\n</code></pre>\n<h2>专题系列</h2>\n<p>JavaScript专题系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}