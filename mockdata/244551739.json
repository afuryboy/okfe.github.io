{"code":0,"data":"<h2>扁平化</h2>\n<p>数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。</p>\n<p>举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下：</p>\n<pre><code class=\"language-js\">var arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr)) // [1, 2, 3, 4]\n</code></pre>\n<p>知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了</p>\n<h2>递归</h2>\n<p>我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法：</p>\n<pre><code class=\"language-js\">// 方法 1\nvar arr = [1, [2, [3, 4]]];\n\nfunction flatten(arr) {\n    var result = [];\n    for (var i = 0, len = arr.length; i &lt; len; i++) {\n        if (Array.isArray(arr[i])) {\n            result = result.concat(flatten(arr[i]))\n        }\n        else {\n            result.push(arr[i])\n        }\n    }\n    return result;\n}\n\n\nconsole.log(flatten(arr))\n</code></pre>\n<h2>toString</h2>\n<p>如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：</p>\n<pre><code class=\"language-js\">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;\n</code></pre>\n<p>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？</p>\n<pre><code class=\"language-js\">// 方法2\nvar arr = [1, [2, [3, 4]]];\n\nfunction flatten(arr) {\n    return arr.toString().split(',').map(function(item){\n        return +item\n    })\n}\n\nconsole.log(flatten(arr))\n</code></pre>\n<p>然而这种方法使用的场景却非常有限，如果数组是 [1, '1', 2, '2'] 的话，这种方法就会产生错误的结果。</p>\n<h2>reduce</h2>\n<p>既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码：</p>\n<pre><code class=\"language-js\">// 方法3\nvar arr = [1, [2, [3, 4]]];\n\nfunction flatten(arr) {\n    return arr.reduce(function(prev, next){\n        return prev.concat(Array.isArray(next) ? flatten(next) : next)\n    }, [])\n}\n\nconsole.log(flatten(arr))\n</code></pre>\n<h2>...</h2>\n<p>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：</p>\n<pre><code class=\"language-js\">var arr = [1, [2, [3, 4]]];\nconsole.log([].concat(...arr)); // [1, 2, [3, 4]]\n</code></pre>\n<p>我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：</p>\n<pre><code class=\"language-js\">// 方法4\nvar arr = [1, [2, [3, 4]]];\n\nfunction flatten(arr) {\n\n    while (arr.some(item =&gt; Array.isArray(item))) {\n        arr = [].concat(...arr);\n    }\n\n    return arr;\n}\n\nconsole.log(flatten(arr))\n</code></pre>\n<h2>undercore</h2>\n<p>那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~</p>\n<p>在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。</p>\n<pre><code class=\"language-js\">/**\n * 数组扁平化\n * @param  {Array} input   要处理的数组\n * @param  {boolean} shallow 是否只扁平一层\n * @param  {boolean} strict  是否严格处理元素，下面有解释\n * @param  {Array} output  这是为了方便递归而传递的参数\n * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528\n */\nfunction flatten(input, shallow, strict, output) {\n\n    // 递归使用的时候会用到output\n    output = output || [];\n    var idx = output.length;\n\n    for (var i = 0, len = input.length; i &lt; len; i++) {\n\n        var value = input[i];\n        // 如果是数组，就进行处理\n        if (Array.isArray(value)) {\n            // 如果是只扁平一层，遍历该数组，依此填入 output\n            if (shallow) {\n                var j = 0, length = value.length;\n                while (j &lt; length) output[idx++] = value[j++];\n            }\n            // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output\n            else {\n                flatten(value, shallow, strict, output);\n                idx = output.length;\n            }\n        }\n        // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output\n        else if (!strict){\n            output[idx++] = value;\n        }\n    }\n\n    return output;\n\n}\n</code></pre>\n<p>解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子：</p>\n<pre><code class=\"language-js\">var arr = [1, 2, [3, 4]];\nconsole.log(flatten(arr, true, true)); // [3, 4]\n</code></pre>\n<p>那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果：</p>\n<ul>\n<li>shallow true + strict false ：正常扁平一层</li>\n<li>shallow false + strict false ：正常扁平所有层</li>\n<li>shallow true + strict true ：去掉非数组元素</li>\n<li>shallow false + strict true ： 返回一个[]</li>\n</ul>\n<p>我们看看 underscore 中哪些方法调用了 flatten 这个基本函数：</p>\n<h2>_.flatten</h2>\n<p>首先就是 _.flatten：</p>\n<pre><code class=\"language-js\">_.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n};\n</code></pre>\n<p>在正常的扁平中，我们并不需要去掉非数组元素。</p>\n<h2>_.union</h2>\n<p>接下来是 _.union：</p>\n<p>该函数传入多个数组，然后返回传入的数组的并集，</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);\n=&gt; [1, 2, 3, 101, 10]\n</code></pre>\n<p>如果传入的参数并不是数组，就会将该参数跳过：</p>\n<pre><code class=\"language-js\">_.union([1, 2, 3], [101, 2, 1, 10], 4, 5);\n=&gt; [1, 2, 3, 101, 10]\n</code></pre>\n<p>为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。</p>\n<pre><code class=\"language-js\">// 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27)\nfunction unique(array) {\n   return Array.from(new Set(array));\n}\n\n_.union = function() {\n    return unique(flatten(arguments, true, true));\n}\n</code></pre>\n<h2>_.difference</h2>\n<p>是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference：</p>\n<p>语法为：</p>\n<blockquote>\n<p>_.difference(array, *others)</p>\n</blockquote>\n<p>效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">_.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);\n=&gt; [1, 3]\n</code></pre>\n<p>实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值：</p>\n<pre><code class=\"language-js\">function difference(array, ...rest) {\n\n    rest = flatten(rest, true, true);\n\n    return array.filter(function(item){\n        return rest.indexOf(item) === -1;\n    })\n}\n</code></pre>\n<p>注意，以上实现的细节并不是完全按照 underscore，具体细节的实现感兴趣可以<a href=\"https://github.com/jashkenas/underscore/blob/master/underscore.js#L528\">查看源码</a>。</p>\n<h2>专题系列</h2>\n<p>JavaScript专题系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}