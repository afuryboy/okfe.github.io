{"code":0,"data":"<h2>顺序执行？</h2>\n<p>如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟：</p>\n<pre><code class=\"language-js\">var foo = function () {\n\n    console.log('foo1');\n\n}\n\nfoo();  // foo1\n\nvar foo = function () {\n\n    console.log('foo2');\n\n}\n\nfoo(); // foo2\n</code></pre>\n<p>然而去看这段代码：</p>\n<pre><code class=\"language-js\">\nfunction foo() {\n\n    console.log('foo1');\n\n}\n\nfoo();  // foo2\n\nfunction foo() {\n\n    console.log('foo2');\n\n}\n\nfoo(); // foo2\n\n</code></pre>\n<p>打印的结果却是两个 <code>foo2</code>。</p>\n<p>刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。</p>\n<p>但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？</p>\n<p>到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？</p>\n<h2>可执行代码</h2>\n<p>这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？</p>\n<p>其实很简单，就三种，全局代码、函数代码、eval代码。</p>\n<p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做&quot;执行上下文(execution context)&quot;。</p>\n<h2>执行上下文栈</h2>\n<p>接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？</p>\n<p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p>\n<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>\n<pre><code class=\"language-js\">ECStack = [];\n</code></pre>\n<p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p>\n<pre><code class=\"language-js\">ECStack = [\n    globalContext\n];\n</code></pre>\n<p>现在 JavaScript 遇到下面的这段代码了：</p>\n<pre><code class=\"language-js\">function fun3() {\n    console.log('fun3')\n}\n\nfunction fun2() {\n    fun3();\n}\n\nfunction fun1() {\n    fun2();\n}\n\nfun1();\n</code></pre>\n<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p>\n<pre><code class=\"language-js\">// 伪代码\n\n// fun1()\nECStack.push(&lt;fun1&gt; functionContext);\n\n// fun1中竟然调用了fun2，还要创建fun2的执行上下文\nECStack.push(&lt;fun2&gt; functionContext);\n\n// 擦，fun2还调用了fun3！\nECStack.push(&lt;fun3&gt; functionContext);\n\n// fun3执行完毕\nECStack.pop();\n\n// fun2执行完毕\nECStack.pop();\n\n// fun1执行完毕\nECStack.pop();\n\n// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext\n</code></pre>\n<h2>解答思考题</h2>\n<p>好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章<a href=\"https://github.com/mqyqingfeng/Blog/issues/3\">《JavaScript深入之词法作用域和动态作用域》</a>最后的问题：</p>\n<pre><code class=\"language-js\">var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n</code></pre>\n<pre><code class=\"language-js\">var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n</code></pre>\n<p>两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p>\n<p>答案就是执行上下文栈的变化不一样。</p>\n<p>让我们模拟第一段代码：</p>\n<pre><code class=\"language-js\">ECStack.push(&lt;checkscope&gt; functionContext);\nECStack.push(&lt;f&gt; functionContext);\nECStack.pop();\nECStack.pop();\n</code></pre>\n<p>让我们模拟第二段代码：</p>\n<pre><code class=\"language-js\">ECStack.push(&lt;checkscope&gt; functionContext);\nECStack.pop();\nECStack.push(&lt;f&gt; functionContext);\nECStack.pop();\n</code></pre>\n<p>是不是有些不同呢？</p>\n<p>当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。</p>\n<h2>下一篇文章</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/5\">《JavaScript深入之变量对象》</a></p>\n<h2>深入系列</h2>\n<p>JavaScript深入系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}