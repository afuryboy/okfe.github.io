{"code":0,"data":"<h2>写在前面</h2>\n<p>本文讲解JavaScript各种继承方式和优缺点。</p>\n<p>但是注意：</p>\n<p>这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！</p>\n<h2>1.原型链继承</h2>\n<pre><code class=\"language-js\">function Parent () {\n    this.name = 'kevin';\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name);\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nconsole.log(child1.getName()) // kevin\n</code></pre>\n<p>问题：</p>\n<p>1.引用类型的属性被所有实例共享，举个例子：</p>\n<pre><code class=\"language-js\">function Parent () {\n    this.names = ['kevin', 'daisy'];\n}\n\nfunction Child () {\n\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child();\n\nchild1.names.push('yayu');\n\nconsole.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]\n</code></pre>\n<p>2.在创建 Child 的实例时，不能向Parent传参</p>\n<h2>2.借用构造函数(经典继承)</h2>\n<pre><code class=\"language-js\">function Parent () {\n    this.names = ['kevin', 'daisy'];\n}\n\nfunction Child () {\n    Parent.call(this);\n}\n\nvar child1 = new Child();\n\nchild1.names.push('yayu');\n\nconsole.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]\n\nvar child2 = new Child();\n\nconsole.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;]\n</code></pre>\n<p>优点：</p>\n<p>1.避免了引用类型的属性被所有实例共享</p>\n<p>2.可以在 Child 中向 Parent 传参</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">function Parent (name) {\n    this.name = name;\n}\n\nfunction Child (name) {\n    Parent.call(this, name);\n}\n\nvar child1 = new Child('kevin');\n\nconsole.log(child1.name); // kevin\n\nvar child2 = new Child('daisy');\n\nconsole.log(child2.name); // daisy\n</code></pre>\n<p>缺点：</p>\n<p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p>\n<h2>3.组合继承</h2>\n<p>原型链继承和经典继承双剑合璧。</p>\n<pre><code class=\"language-js\">function Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n\n    Parent.call(this, name);\n    \n    this.age = age;\n\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('kevin', '18');\n\nchild1.colors.push('black');\n\nconsole.log(child1.name); // kevin\nconsole.log(child1.age); // 18\nconsole.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]\n\nvar child2 = new Child('daisy', '20');\n\nconsole.log(child2.name); // daisy\nconsole.log(child2.age); // 20\nconsole.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]\n</code></pre>\n<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>\n<h2>4.原型式继承</h2>\n<pre><code class=\"language-js\">function createObj(o) {\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n</code></pre>\n<p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>\n<p>缺点：</p>\n<p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>\n<pre><code class=\"language-js\">var person = {\n    name: 'kevin',\n    friends: ['daisy', 'kelly']\n}\n\nvar person1 = createObj(person);\nvar person2 = createObj(person);\n\nperson1.name = 'person1';\nconsole.log(person2.name); // kevin\n\nperson1.firends.push('taylor');\nconsole.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]\n</code></pre>\n<p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = 'person1'</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p>\n<h2>5. 寄生式继承</h2>\n<p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>\n<pre><code class=\"language-js\">function createObj (o) {\n    var clone = Object.create(o);\n    clone.sayName = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n</code></pre>\n<p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>\n<h2>6. 寄生组合式继承</h2>\n<p>为了方便大家阅读，在这里重复一下组合继承的代码：</p>\n<pre><code class=\"language-js\">function Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1)\n</code></pre>\n<p>组合继承最大的缺点是会调用两次父构造函数。</p>\n<p>一次是设置子类型实例的原型的时候：</p>\n<pre><code class=\"language-js\">Child.prototype = new Parent();\n</code></pre>\n<p>一次在创建子类型实例的时候：</p>\n<pre><code class=\"language-js\">var child1 = new Child('kevin', '18');\n</code></pre>\n<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>\n<pre><code class=\"language-js\">Parent.call(this, name);\n</code></pre>\n<p>在这里，我们又会调用了一次 Parent 构造函数。</p>\n<p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>['red', 'blue', 'green']</code>。</p>\n<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>\n<p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>\n<p>看看如何实现：</p>\n<pre><code class=\"language-js\">function Parent (name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\n// 关键的三步\nvar F = function () {};\n\nF.prototype = Parent.prototype;\n\nChild.prototype = new F();\n\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n</code></pre>\n<p>最后我们封装一下这个继承方法：</p>\n<pre><code class=\"language-js\">function object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction prototype(child, parent) {\n    var prototype = object(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\n\n// 当我们使用的时候：\nprototype(Child, Parent);\n</code></pre>\n<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>\n<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>\n<h2>相关链接</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">《JavaScript深入之从原型到原型链》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/11\">《JavaScript深入之call和apply的模拟实现》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/13\">《JavaScript深入之new的模拟实现》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/15\">《JavaScript深入之创建对象》</a></p>\n<h2>深入系列</h2>\n<p>JavaScript深入系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}