{"code":0,"data":"<h2>起源</h2>\n<p>一段标准的 for 循环代码：</p>\n<pre><code class=\"language-js\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n\nfor (var i = 0, len = colors.length; i &lt; len; i++) {\n    console.log(colors[i]);\n}\n</code></pre>\n<p>看着很简单，但是再回顾这段代码，实际上我们仅仅是需要数组中元素的值，但是却需要提前获取数组长度，声明索引变量等，尤其当多个循环嵌套的时候，更需要使用多个索引变量，代码的复杂度就会大大增加，比如我们使用双重循环进行去重：</p>\n<pre><code class=\"language-js\">function unique(array) {\n    var res = [];\n    for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) {\n        for (var j = 0, resLen = res.length; j &lt; resLen; j++) {\n            if (array[i] === res[j]) {\n                break;\n            }\n        }\n        if (j === resLen) {\n            res.push(array[i]);\n        }\n    }\n    return res;\n}\n</code></pre>\n<p>为了消除这种复杂度以及减少循环中的错误(比如错误使用其他循环中的变量)，ES6 提供了迭代器和 for of 循环<strong>共同解决</strong>这个问题。</p>\n<h2>迭代器</h2>\n<p>所谓迭代器，其实就是一个具有 next() 方法的对象，每次调用 next() 都会返回一个结果对象，该结果对象有两个属性，value 表示当前的值，done 表示遍历是否结束。</p>\n<p>我们直接用 ES5 的语法创建一个迭代器：</p>\n<pre><code class=\"language-js\">function createIterator(items) {\n    var i = 0;\n    return {\n        next: function() {\n            var done = i &gt;= item.length;\n            var value = !done ? items[i++] : undefined;\n\n            return {\n                done: done,\n                value: value\n            };\n        }\n    };\n}\n\n// iterator 就是一个迭代器对象\nvar iterator = createIterator([1, 2, 3]);\n\nconsole.log(iterator.next()); // { done: false, value: 1 }\nconsole.log(iterator.next()); // { done: false, value: 2 }\nconsole.log(iterator.next()); // { done: false, value: 3 }\nconsole.log(iterator.next()); // { done: true, value: undefined }\n</code></pre>\n<h2>for of</h2>\n<p>除了迭代器之外，我们还需要一个可以遍历迭代器对象的方式，ES6 提供了 for of 语句，我们直接用 for of 遍历一下我们上节生成的遍历器对象试试：</p>\n<pre><code class=\"language-js\">var iterator = createIterator([1, 2, 3]);\n\nfor (let value of iterator) {\n    console.log(value);\n}\n</code></pre>\n<p>结果报错 <code>TypeError: iterator is not iterable</code>，表明我们生成的 iterator 对象并不是 iterable(可遍历的)。</p>\n<p>那什么才是可遍历的呢？</p>\n<p>其实一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>\n<p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是&quot;可遍历的&quot;（iterable）。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">const obj = {\n    value: 1\n};\n\nfor (value of obj) {\n    console.log(value);\n}\n\n// TypeError: iterator is not iterable\n</code></pre>\n<p>我们直接 for of 遍历一个对象，会报错，然而如果我们给该对象添加 Symbol.iterator 属性：</p>\n<pre><code class=\"language-js\">const obj = {\n    value: 1\n};\n\nobj[Symbol.iterator] = function() {\n    return createIterator([1, 2, 3]);\n};\n\nfor (value of obj) {\n    console.log(value);\n}\n\n// 1\n// 2\n// 3\n</code></pre>\n<p>由此，我们也可以发现 for of 遍历的其实是对象的 Symbol.iterator 属性。</p>\n<h2>默认可遍历对象</h2>\n<p>然而如果我们直接遍历一个数组对象：</p>\n<pre><code class=\"language-js\">const colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n\nfor (let color of colors) {\n    console.log(color);\n}\n\n// red\n// green\n// blue\n</code></pre>\n<p>尽管我们没有手动添加 Symbol.iterator 属性，还是可以遍历成功，这是因为 ES6 默认部署了 Symbol.iterator 属性，当然我们也可以手动修改这个属性：</p>\n<pre><code class=\"language-js\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n\ncolors[Symbol.iterator] = function() {\n    return createIterator([1, 2, 3]);\n};\n\nfor (let color of colors) {\n    console.log(color);\n}\n\n// 1\n// 2\n// 3\n</code></pre>\n<p>除了数组之外，还有一些数据结构默认部署了 Symbol.iterator 属性。</p>\n<p>所以 for...of 循环可以使用的范围包括：</p>\n<ol>\n<li>数组</li>\n<li>Set</li>\n<li>Map</li>\n<li>类数组对象，如 arguments 对象、DOM NodeList 对象</li>\n<li>Generator 对象</li>\n<li>字符串</li>\n</ol>\n<h2>模拟实现 for of</h2>\n<p>其实模拟实现 for of 也比较简单，基本就是通过 Symbol.iterator 属性获取迭代器对象，然后使用 while 遍历一下：</p>\n<pre><code class=\"language-js\">function forOf(obj, cb) {\n    let iterable, result;\n\n    if (typeof obj[Symbol.iterator] !== &quot;function&quot;)\n        throw new TypeError(result + &quot; is not iterable&quot;);\n    if (typeof cb !== &quot;function&quot;) throw new TypeError(&quot;cb must be callable&quot;);\n\n    iterable = obj[Symbol.iterator]();\n\n    result = iterable.next();\n    while (!result.done) {\n        cb(result.value);\n        result = iterable.next();\n    }\n}\n</code></pre>\n<h2>内建迭代器</h2>\n<p>为了更好的访问对象中的内容，比如有的时候我们仅需要数组中的值，但有的时候不仅需要使用值还需要使用索引，ES6 为数组、Map、Set 集合内建了以下三种迭代器：</p>\n<ol>\n<li>entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值。</li>\n<li>keys() 返回一个遍历器对象，用来遍历所有的键名。</li>\n<li>values() 返回一个遍历器对象，用来遍历所有的键值。</li>\n</ol>\n<p>以数组为例：</p>\n<pre><code class=\"language-js\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n\nfor (let index of colors.keys()) {\n    console.log(index);\n}\n\n// 0\n// 1\n// 2\n\nfor (let color of colors.values()) {\n    console.log(color);\n}\n\n// red\n// green\n// blue\n\nfor (let item of colors.entries()) {\n    console.log(item);\n}\n\n// [ 0, &quot;red&quot; ]\n// [ 1, &quot;green&quot; ]\n// [ 2, &quot;blue&quot; ]\n</code></pre>\n<p>Map 类型与数组类似，但是对于 Set 类型需要注意以下：</p>\n<pre><code class=\"language-js\">var colors = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);\n\nfor (let index of colors.keys()) {\n    console.log(index);\n}\n\n// red\n// green\n// blue\n\nfor (let color of colors.values()) {\n    console.log(color);\n}\n\n// red\n// green\n// blue\n\nfor (let item of colors.entries()) {\n    console.log(item);\n}\n\n// [ &quot;red&quot;, &quot;red&quot; ]\n// [ &quot;green&quot;, &quot;green&quot; ]\n// [ &quot;blue&quot;, &quot;blue&quot; ]\n</code></pre>\n<p>Set 类型的 keys() 和 values() 返回的是相同的迭代器，这也意味着在 Set 这种数据结构中键名与键值相同。</p>\n<p>而且每个集合类型都有一个默认的迭代器，在 for-of 循环中，如果没有显式指定则使用默认的迭代器。数组和 Set 集合的默认迭代器是 values() 方法，Map 集合的默认迭代器是 entries() 方法。</p>\n<p>这也就是为什么直接 for of 遍历 Set 和 Map 数据结构，会有不同的数据结构返回：</p>\n<pre><code class=\"language-js\">const values = new Set([1, 2, 3]);\n\nfor (let value of values) {\n    console.log(value);\n}\n\n// 1\n// 2\n// 3\n</code></pre>\n<pre><code class=\"language-js\">const values = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);\nfor (let value of values) {\n    console.log(value);\n}\n\n// [&quot;key1&quot;, &quot;value1&quot;]\n// [&quot;key2&quot;, &quot;value2&quot;]\n</code></pre>\n<p>遍历 Map 数据结构的时候可以顺便结合解构赋值：</p>\n<pre><code class=\"language-js\">const valuess = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);\n\nfor (let [key, value] of valuess) {\n    console.log(key + &quot;:&quot; + value);\n}\n\n// key1:value1\n// key2:value2\n</code></pre>\n<h2>Babel 是如何编译 for of 的</h2>\n<p>我们可以在 Babel 的 <a href=\"http://babeljs.io/repl\">Try it out</a> 中查看编译的结果：</p>\n<pre><code class=\"language-js\">const colors = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);\n\nfor (let color of colors) {\n    console.log(color);\n}\n</code></pre>\n<p>对于这样一段代码，编译的结果如下：</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;;\n\nvar colors = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);\n\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n    for (\n        var _iterator = colors[Symbol.iterator](), _step;\n        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n        _iteratorNormalCompletion = true\n    ) {\n        var color = _step.value;\n\n        console.log(color);\n    }\n} catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n} finally {\n    try {\n        if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {\n            _iterator.return();\n        }\n    } finally {\n        if (_didIteratorError) {\n            throw _iteratorError;\n        }\n    }\n}\n</code></pre>\n<p>至少由编译的结果可以看出，使用 <code>for of</code> 循环的背后，还是会使用 Symbol.iterator 接口。</p>\n<p>而这段编译的代码稍微复杂的地方有两段，一段是 for 循环这里：</p>\n<pre><code class=\"language-js\">for (\n    var _iterator = colors[Symbol.iterator](), _step;\n    !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n    _iteratorNormalCompletion = true\n) {\n    var color = _step.value;\n    console.log(color);\n}\n</code></pre>\n<p>跟标准的 for 循环写法有些差别，我们看下 for 语句的语法：</p>\n<pre><code class=\"language-js\">for (initialize; test; increment) statement;\n</code></pre>\n<p>initialize、test 和 increment 三个表达式之间用分号分割，它们分别负责<code>初始化操作</code>、<code>循环条件判断</code>和<code>计数器变量的更新</code>。</p>\n<p>for 语句其实就相当于：</p>\n<pre><code class=\"language-js\">initialize;\nwhile (test) {\n    statement;\n    increment;\n}\n</code></pre>\n<p>代码的逻辑为：先进行初始化，然后每次循环执行之前会执行 test 表达式，并判断表达式的结果来决定是否执行循环体，如果 test 计算结果为真值，则执行循环体中的 statement。最后，执行 increment 表达式。</p>\n<p>而且值得注意的是，其实 for 循环中的三个表达式中任意一个都可以被忽略，不过分号还是要写的。</p>\n<p>比如 <code>for(;;)</code>，不过这就是一个死循环……</p>\n<p>比如：</p>\n<pre><code class=\"language-js\">var i = 0,\n    len = colors.length;\nfor (; i &lt; len; i++) {\n    console.log(colors[i]);\n}\n</code></pre>\n<p>又比如：</p>\n<pre><code class=\"language-js\">var i = 0,\n    len = colors.length;\nfor (; i &lt; len; ) {\n    i++;\n}\n</code></pre>\n<p>然后我们再来看 Babel 编译的这个 for 循环表达式：</p>\n<pre><code class=\"language-js\">for (\n    var _iterator = colors[Symbol.iterator](), _step;\n    !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\n    _iteratorNormalCompletion = true\n) {\n    var color = _step.value;\n    console.log(color);\n}\n</code></pre>\n<p>用 while 的写法相当于：</p>\n<pre><code class=\"language-js\">var _iterator = colors[Symbol.iterator](),\n    _step;\nwhile (!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) {\n    var color = _step.value;\n    console.log(color);\n    _iteratorNormalCompletion = true;\n}\n</code></pre>\n<p>是不是就好懂了很多呢，然后你就会发现，其实 <code>_iteratorNormalCompletion = true</code> 这句是完全没有必要的……</p>\n<p>另外一段稍微复杂的代码是:</p>\n<pre><code class=\"language-js\">try {\n  ...\n} catch (err) {\n  ...\n} finally {\n  try {\n    if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {\n      _iterator.return();\n    }\n  } finally {\n    ...\n  }\n}\n</code></pre>\n<p>因为 <code>_iteratorNormalCompletion = (_step = _iterator.next()).done</code>，所以 _iteratorNormalCompletion 表示的就是是否完成了一次完整的迭代过程，如果没有正常的迭代完成，并且迭代器有 return 方法时，就会执行该方法。</p>\n<p>而之所以这么做，就要提到迭代器的 return 方法。</p>\n<p>引用阮一峰老师的 <a href=\"http://es6.ruanyifeng.com/#docs/iterator#%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84-return%EF%BC%8Cthrow\">ECMAScript 6 入门</a>:</p>\n<blockquote>\n<p>遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。</p>\n</blockquote>\n<blockquote>\n<p>return 方法的使用场合是，如果 for...of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。</p>\n</blockquote>\n<p>我们可以举个例子：</p>\n<pre><code class=\"language-js\">function createIterator(items) {\n    var i = 0;\n    return {\n        next: function() {\n            var done = i &gt;= items.length;\n            var value = !done ? items[i++] : undefined;\n\n            return {\n                done: done,\n                value: value\n            };\n        },\n        return: function() {\n            console.log(&quot;执行了 return 方法&quot;);\n            return {\n                value: 23333,\n                done: true\n            };\n        }\n    };\n}\n\nvar colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\n\nvar iterator = createIterator([1, 2, 3]);\n\ncolors[Symbol.iterator] = function() {\n    return iterator;\n};\n\nfor (let color of colors) {\n    if (color == 1) break;\n    console.log(color);\n}\n// 执行了 return 方法\n</code></pre>\n<p>不过正如你在编译后的代码中看到，仅仅是在有 return 函数的时候执行了 return 函数而已，return 函数中返回的值其实并不生效……</p>\n<p>但是你不返回值或者返回一个基本类型的值的话，结果又会报错……</p>\n<pre><code>TypeError: Iterator result undefined is not an object\n</code></pre>\n<p>这是因为 return 方法必须返回一个对象，而这又是 Generator 规范决定的……</p>\n<p>总之如果是在浏览器中使用的话，return 函数的返回值其实并不生效 T^T</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}