{"code":0,"data":"<h2>前言</h2>\n<p>underscore 提供了模板引擎的功能，举个例子：</p>\n<pre><code class=\"language-js\">var tpl = &quot;hello: &lt;%= name %&gt;&quot;;\n\nvar compiled = _.template(tpl);\ncompiled({name: 'Kevin'}); // &quot;hello: Kevin&quot;\n</code></pre>\n<p>感觉好像没有什么强大的地方，再来举个例子：</p>\n<p>在 HTML 文件中：</p>\n<pre><code class=\"language-html\">&lt;ul id=&quot;name_list&quot;&gt;&lt;/ul&gt;\n\n&lt;script type=&quot;text/html&quot; id=&quot;user_tmpl&quot;&gt;\n    &lt;%for ( var i = 0; i &lt; users.length; i++ ) { %&gt;\n        &lt;li&gt;\n            &lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;\n                &lt;%=users[i].name%&gt;\n            &lt;/a&gt;\n        &lt;/li&gt;\n    &lt;% } %&gt;\n&lt;/script&gt;\n</code></pre>\n<p>JavaScript 文件中：</p>\n<pre><code class=\"language-js\">var container = document.getElementById(&quot;name_list&quot;);\n\nvar data = {\n    users: [\n        { &quot;name&quot;: &quot;Kevin&quot;, &quot;url&quot;: &quot;http://localhost&quot; },\n        { &quot;name&quot;: &quot;Daisy&quot;, &quot;url&quot;: &quot;http://localhost&quot; },\n        { &quot;name&quot;: &quot;Kelly&quot;, &quot;url&quot;: &quot;http://localhost&quot; }\n    ]\n}\nvar precompile = _.template(document.getElementById(&quot;user_tmpl&quot;).innerHTML);\nvar html = precompile(data);\n\ncontainer.innerHTML = html;\n</code></pre>\n<p>效果为：</p>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/template/template.png\" alt=\"模板引擎效果\"></p>\n<p>那么该如何实现这样一个 _.template 函数呢？</p>\n<h2>实现思路</h2>\n<p>underscore 的 template 函数参考了 jQuery 的作者 John Resig 在 2008 年发表的一篇文章 <a href=\"https://johnresig.com/blog/javascript-micro-templating/#postcomment\">JavaScript Micro-Templating</a>，我们先从这篇文章的思路出发，思考一下如何写一个简单的模板引擎。</p>\n<p>依然是以这段模板字符串为例：</p>\n<pre><code class=\"language-js\">&lt;%for ( var i = 0; i &lt; users.length; i++ ) { %&gt;\n    &lt;li&gt;\n        &lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;\n            &lt;%=users[i].name%&gt;\n        &lt;/a&gt;\n    &lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n<p>John Resig 的思路是将这段代码转换为这样一段程序：</p>\n<pre><code class=\"language-js\">// 模拟数据\nvar users = [{&quot;name&quot;: &quot;Kevin&quot;, &quot;url&quot;: &quot;http://localhost&quot;}];\n\nvar p = [];\nfor (var i = 0; i &lt; users.length; i++) {\n    p.push('&lt;li&gt;&lt;a href=&quot;');\n    p.push(users[i].url);\n    p.push('&quot;&gt;');\n    p.push(users[i].name);\n    p.push('&lt;/a&gt;&lt;/li&gt;');\n}\n\n// 最后 join 一下就可以得到最终拼接好的模板字符串\nconsole.log(p.join('')) // &lt;li&gt;&lt;a href=&quot;http://localhost&quot;&gt;Kevin&lt;/a&gt;&lt;/li&gt;\n</code></pre>\n<p>我们注意，模板其实是一段字符串，我们怎么根据一段字符串生成一段代码呢？很容易就想到用 eval，那我们就先用 eval 吧。</p>\n<p>然后我们会发现，为了转换成这样一段代码，我们需要将<code>&lt;%xxx%&gt;</code>转换为 <code>xxx</code>，其实就是去掉包裹的符号，还要将 <code>&lt;%=xxx%&gt;</code>转化成 <code>p.push(xxx)</code>，这些都可以用正则实现，但是我们还需要写 <code>p.push('&lt;li&gt;&lt;a href=&quot;');</code> 、<code>p.push('&quot;&gt;');</code>呐，这些该如何实现呢？</p>\n<p>那我们换个思路，依然是用正则，但是我们</p>\n<ol>\n<li>将 <code>%&gt;</code> 替换成 <code>p.push('</code></li>\n<li>将 <code>&lt;%</code> 替换成 <code>');</code></li>\n<li>将 <code>&lt;%=xxx%&gt;</code> 替换成 <code>');p.push(xxx);p.push('</code></li>\n</ol>\n<p>我们来举个例子：</p>\n<pre><code>&lt;%for ( var i = 0; i &lt; users.length; i++ ) { %&gt;\n    &lt;li&gt;\n        &lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;\n            &lt;%=users[i].name%&gt;\n        &lt;/a&gt;\n    &lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n<p>按照这个替换规则会被替换为：</p>\n<pre><code>');for ( var i = 0; i &lt; users.length; i++ ) { p.push('\n    &lt;li&gt;\n        &lt;a href=&quot;');p.push(users[i].url);p.push('&quot;&gt;\n            ');p.push(users[i].name);p.push('\n        &lt;/a&gt;\n    &lt;/li&gt;\n'); } p.push('\n</code></pre>\n<p>这样肯定会报错，毕竟代码都没有写全，我们在首和尾加上部分代码，变成：</p>\n<pre><code>// 添加的首部代码\nvar p = []; p.push('\n\n');for ( var i = 0; i &lt; users.length; i++ ) { p.push('\n    &lt;li&gt;\n        &lt;a href=&quot;');p.push(users[i].url);p.push('&quot;&gt;\n            ');p.push(users[i].name);p.push('\n        &lt;/a&gt;\n    &lt;/li&gt;\n'); } p.push('\n\n// 添加的尾部代码\n');\n</code></pre>\n<p>我们整理下这段代码：</p>\n<pre><code class=\"language-js\">var p = []; p.push('');\nfor ( var i = 0; i &lt; users.length; i++ ) { \n    p.push('&lt;li&gt;&lt;a href=&quot;');\n    p.push(users[i].url);\n    p.push('&quot;&gt;');\n    p.push(users[i].name);\n    p.push('&lt;/a&gt;&lt;/li&gt;'); \n}\n    p.push('');\n</code></pre>\n<p>恰好可以实现这个功能，不过还要注意一点，要将换行符替换成空格，防止解析成代码的时候报错，不过在这里为了方便理解原理，就只在代码里实现。</p>\n<h2>第一版</h2>\n<p>我们来尝试实现第一版：</p>\n<pre><code class=\"language-js\">// 第一版\nfunction tmpl(str, data) {\n    var str = document.getElementById(str).innerHTML;\n\n    var string = &quot;var p = []; p.push('&quot; +\n    str\n    .replace(/[\\r\\t\\n]/g, &quot;&quot;)\n    .replace(/&lt;%=(.*?)%&gt;/g, &quot;');p.push($1);p.push('&quot;)\n    .replace(/&lt;%/g, &quot;');&quot;)\n    .replace(/%&gt;/g,&quot;p.push('&quot;)\n    + &quot;');&quot;\n\n    eval(string)\n\n    return p.join('');\n};\n</code></pre>\n<p>为了验证是否有用：</p>\n<p>HTML 文件：</p>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/html&quot; id=&quot;user_tmpl&quot;&gt;\n    &lt;%for ( var i = 0; i &lt; users.length; i++ ) { %&gt;\n        &lt;li&gt;\n            &lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;\n                &lt;%=users[i].name%&gt;\n            &lt;/a&gt;\n        &lt;/li&gt;\n    &lt;% } %&gt;\n&lt;/script&gt;\n</code></pre>\n<p>JavaScript 文件：</p>\n<pre><code class=\"language-js\">var users = [\n    { &quot;name&quot;: &quot;Byron&quot;, &quot;url&quot;: &quot;http://localhost&quot; },\n    { &quot;name&quot;: &quot;Casper&quot;, &quot;url&quot;: &quot;http://localhost&quot; },\n    { &quot;name&quot;: &quot;Frank&quot;, &quot;url&quot;: &quot;http://localhost&quot; }\n]\ntmpl(&quot;user_tmpl&quot;, users)\n</code></pre>\n<p>完整的 Demo 可以查看 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template1\">template 示例一</a></p>\n<h2>Function</h2>\n<p>在这里我们使用了 eval ，实际上 John Resig 在文章中使用的是 Function 构造函数。</p>\n<p>Function 构造函数创建一个新的 Function 对象。 在 JavaScript 中, 每个函数实际上都是一个 Function 对象。</p>\n<p>使用方法为：</p>\n<pre><code class=\"language-js\">new Function ([arg1[, arg2[, ...argN]],] functionBody)\n</code></pre>\n<p>arg1, arg2, ... argN 表示函数用到的参数，functionBody 表示一个含有包括函数定义的 JavaScript 语句的字符串。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">var adder = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);\n\nadder(2, 6); // 8\n</code></pre>\n<p>那么 John Resig 到底是如何实现的呢？</p>\n<h2>第二版</h2>\n<p>使用 Function 构造函数：</p>\n<pre><code class=\"language-js\">// 第二版\nfunction tmpl(str, data) {\n    var str = document.getElementById(str).innerHTML;\n\n    var fn = new Function(&quot;obj&quot;,\n\n    &quot;var p = []; p.push('&quot; +\n\n    str\n    .replace(/[\\r\\t\\n]/g, &quot;&quot;)\n    .replace(/&lt;%=(.*?)%&gt;/g, &quot;');p.push($1);p.push('&quot;)\n    .replace(/&lt;%/g, &quot;');&quot;)\n    .replace(/%&gt;/g,&quot;p.push('&quot;)\n    + &quot;');return p.join('');&quot;);\n\n    return fn(data);\n};\n</code></pre>\n<p>使用方法依然跟第一版相同，具体 Demo 可以查看 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template2\">template 示例二</a></p>\n<p>不过值得注意的是：其实 tmpl 函数没有必要传入 data 参数，也没有必要在最后 return 的时候，传入 data 参数，即使你把这两个参数都去掉，代码还是可以正常执行的。</p>\n<p>这是因为:</p>\n<blockquote>\n<p>使用Function构造器生成的函数，并不会在创建它们的上下文中创建闭包；它们一般在全局作用域中被创建。当运行这些函数的时候，它们只能访问自己的本地变量和全局变量，不能访问Function构造器被调用生成的上下文的作用域。这和使用带有函数表达式代码的 eval 不同。</p>\n</blockquote>\n<p>这里之所以依然传入了 data 参数，是为了下一版做准备。</p>\n<h2>with</h2>\n<p>现在有一个小问题，就是实际上我们传入的数据结构可能比较复杂，比如：</p>\n<pre><code class=\"language-js\">var data = {\n    status: 200,\n    name: 'kevin',\n    friends: [...]\n}\n</code></pre>\n<p>如果我们将这个数据结构传入 tmpl 函数中，在模板字符串中，如果要用到某个数据，总是需要使用 <code>data.name</code>、<code>data.friends</code> 的形式来获取，麻烦就麻烦在我想直接使用 name、friends 等变量，而不是繁琐的使用 <code>data.</code> 来获取。</p>\n<p>这又该如何实现的呢？答案是 with。</p>\n<p>with 语句可以扩展一个语句的作用域链(scope chain)。当需要多次访问一个对象的时候，可以使用 with 做简化。比如：</p>\n<pre><code class=\"language-js\">var hostName = location.hostname;\nvar url = location.href;\n\n// 使用 with\nwith(location){\n    var hostname = hostname;\n    var url = href;\n}\n</code></pre>\n<pre><code class=\"language-js\">function Person(){\n    this.name = 'Kevin';\n    this.age = '18';\n}\n\nvar person = new Person();\n\nwith(person) {\n    console.log('my name is ' + name + ', age is ' + age + '.')\n}\n// my name is Kevin, age is 18.\n</code></pre>\n<p>最后：不建议使用 with 语句，因为它可能是混淆错误和兼容性问题的根源，除此之外，也会造成性能低下</p>\n<h2>第三版</h2>\n<p>使用 with ，我们再写一版代码：</p>\n<pre><code class=\"language-js\">// 第三版\nfunction tmpl(str, data) {\n    var str = document.getElementById(str).innerHTML;\n\n    var fn = new Function(&quot;obj&quot;,\n\n    // 其实就是这里多添加了一句 with(obj){...}\n    &quot;var p = []; with(obj){p.push('&quot; +\n\n    str\n    .replace(/[\\r\\t\\n]/g, &quot;&quot;)\n    .replace(/&lt;%=(.*?)%&gt;/g, &quot;');p.push($1);p.push('&quot;)\n    .replace(/&lt;%/g, &quot;');&quot;)\n    .replace(/%&gt;/g,&quot;p.push('&quot;)\n    + &quot;');}return p.join('');&quot;);\n\n    return fn(data);\n};\n</code></pre>\n<p>具体 Demo 可以查看 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template3\">template 示例三</a></p>\n<h2>第四版</h2>\n<p>如果我们的模板不变，数据却发生了变化，如果使用我们的之前写的 tmpl 函数，每次都会 new Function，这其实是没有必要的，如果我们能在使用 tmpl 的时候，返回一个函数，然后使用该函数，传入不同的数据，只根据数据不同渲染不同的 html 字符串，就可以避免这种无谓的损失。</p>\n<pre><code class=\"language-js\">// 第四版\nfunction tmpl(str, data) {\n    var str = document.getElementById(str).innerHTML;\n\n    var fn = new Function(&quot;obj&quot;,\n\n    &quot;var p = []; with(obj){p.push('&quot; +\n\n    str\n    .replace(/[\\r\\t\\n]/g, &quot;&quot;)\n    .replace(/&lt;%=(.*?)%&gt;/g, &quot;');p.push($1);p.push('&quot;)\n    .replace(/&lt;%/g, &quot;');&quot;)\n    .replace(/%&gt;/g,&quot;p.push('&quot;)\n    + &quot;');}return p.join('');&quot;);\n\n    var template = function(data) {\n        return fn.call(this, data)\n    }\n    return template;\n};\n\n// 使用时\nvar compiled = tmpl(&quot;user_tmpl&quot;);\nresults.innerHTML = compiled(data);\n</code></pre>\n<p>具体 Demo 可以查看 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template4\">template 示例四</a></p>\n<h2>下期预告</h2>\n<p>至此，我们已经跟着 jQuery 的作者 John Resig 实现了一个简单的模板引擎，虽然 underscore 基于这个思路实现，但是功能强大，相对的，代码也更加复杂一下，下一篇，我们一起去分析 underscore 的 template 函数实现。</p>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}