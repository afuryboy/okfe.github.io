{"code":0,"data":"<h2>回顾</h2>\n<p>我们先来回顾下箭头函数的基本语法。</p>\n<p>ES6 增加了箭头函数：</p>\n<pre><code class=\"language-js\">let func = value =&gt; value;\n</code></pre>\n<p>相当于：</p>\n<pre><code class=\"language-js\">let func = function (value) {\n    return value;\n};\n</code></pre>\n<p>如果需要给函数传入多个参数：</p>\n<pre><code class=\"language-js\">let func = (value, num) =&gt; value * num;\n</code></pre>\n<p>如果函数的代码块需要多条语句：</p>\n<pre><code class=\"language-js\">let func = (value, num) =&gt; {\n    return value * num\n};\n</code></pre>\n<p>如果需要直接返回一个对象：</p>\n<pre><code class=\"language-js\">let func = (value, num) =&gt; ({total: value * num});\n</code></pre>\n<p>与变量解构结合：</p>\n<pre><code class=\"language-js\">let func = ({value, num}) =&gt; ({total: value * num})\n\n// 使用\nvar result = func({\n    value: 10,\n    num: 10\n})\n\nconsole.log(result); // {total: 100}\n</code></pre>\n<p>很多时候，你可能想不到要这样用，所以再来举个例子，比如在 React 与 Immutable 的技术选型中，我们处理一个事件会这样做：</p>\n<pre><code class=\"language-js\">handleEvent = () =&gt; {\n  this.setState({\n    data: this.state.data.set(&quot;key&quot;, &quot;value&quot;)\n  })\n};\n</code></pre>\n<p>其实就可以简化为：</p>\n<pre><code class=\"language-js\">handleEvent = () =&gt; {\n  this.setState(({data}) =&gt; ({\n    data: data.set(&quot;key&quot;, &quot;value&quot;)\n  }))\n};\n</code></pre>\n<h2>比较</h2>\n<p>本篇我们重点比较一下箭头函数与普通函数。</p>\n<p>主要区别包括：</p>\n<h3>1.没有 this</h3>\n<p><strong>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。</strong></p>\n<p>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p>\n<p>模拟一个实际开发中的例子：</p>\n<p>我们的需求是点击一个按钮，改变该按钮的背景色。</p>\n<p>为了方便开发，我们抽离一个 Button 组件，当需要使用的时候，直接：</p>\n<pre><code class=\"language-js\">// 传入元素 id 值即可绑定该元素点击时改变背景色的事件\nnew Button(&quot;button&quot;)\n</code></pre>\n<p>HTML 代码如下：</p>\n<pre><code class=\"language-html\">&lt;button id=&quot;button&quot;&gt;点击变色&lt;/button&gt;\n</code></pre>\n<p>JavaScript 代码如下：</p>\n<pre><code class=\"language-js\">function Button(id) {\n    this.element = document.querySelector(&quot;#&quot; + id);\n    this.bindEvent();\n}\n\nButton.prototype.bindEvent = function() {\n    this.element.addEventListener(&quot;click&quot;, this.setBgColor, false);\n};\n\nButton.prototype.setBgColor = function() {\n    this.element.style.backgroundColor = '#1abc9c'\n};\n\nvar button = new Button(&quot;button&quot;);\n</code></pre>\n<p>看着好像没有问题，结果却是报错 <code>Uncaught TypeError: Cannot read property 'style' of undefined</code></p>\n<p>这是因为当使用 addEventListener() 为一个元素注册事件的时候，事件函数里的 this 值是该元素的引用。</p>\n<p>所以如果我们在 setBgColor 中 <code>console.log(this)</code>，this 指向的是按钮元素，那 this.element 就是 undefined，报错自然就理所当然了。</p>\n<p>也许你会问，既然 this 都指向了按钮元素，那我们直接修改 setBgColor 函数为：</p>\n<pre><code class=\"language-js\">Button.prototype.setBgColor = function() {\n    this.style.backgroundColor = '#1abc9c'\n};\n</code></pre>\n<p>不就可以解决这个问题了？</p>\n<p>确实可以这样做，但是在实际的开发中，我们可能会在 setBgColor 中还调用其他的函数，比如写成这种：</p>\n<pre><code class=\"language-js\">Button.prototype.setBgColor = function() {\n    this.setElementColor();\n    this.setOtherElementColor();\n};\n</code></pre>\n<p>所以我们还是希望 setBgColor 中的 this 是指向实例对象的，这样就可以调用其他的函数。</p>\n<p>利用 ES5，我们一般会这样做：</p>\n<pre><code class=\"language-js\">Button.prototype.bindEvent = function() {\n    this.element.addEventListener(&quot;click&quot;, this.setBgColor.bind(this), false);\n};\n</code></pre>\n<p>为避免 addEventListener 的影响，使用 bind 强制绑定 setBgColor() 的 this 为实例对象</p>\n<p>使用 ES6，我们可以更好的解决这个问题：</p>\n<pre><code class=\"language-js\">Button.prototype.bindEvent = function() {\n    this.element.addEventListener(&quot;click&quot;, event =&gt; this.setBgColor(event), false);\n};\n</code></pre>\n<p>由于箭头函数没有 this，所以会向外层查找 this 的值，即 bindEvent 中的 this，此时 this 指向实例对象，所以可以正确的调用 this.setBgColor 方法， 而 this.setBgColor 中的 this 也会正确指向实例对象。</p>\n<p>在这里再额外提一点，就是注意 bindEvent 和  setBgColor 在这里使用的是普通函数的形式，而非箭头函数，如果我们改成箭头函数，会导致函数里的 this 指向 window 对象 (非严格模式下)。</p>\n<p>最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子：</p>\n<pre><code class=\"language-js\">var value = 1;\nvar result = (() =&gt; this.value).bind({value: 2})();\nconsole.log(result); // 1\n</code></pre>\n<h3>2. 没有 arguments</h3>\n<p>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：</p>\n<pre><code class=\"language-js\">function constant() {\n    return () =&gt; arguments[0]\n}\n\nvar result = constant(1);\nconsole.log(result()); // 1\n</code></pre>\n<p>那如果我们就是要访问箭头函数的参数呢？</p>\n<p>你可以通过命名参数或者 rest 参数的形式访问参数:</p>\n<pre><code class=\"language-js\">let nums = (...nums) =&gt; nums;\n</code></pre>\n<h3>3. 不能通过 new 关键字调用</h3>\n<p>JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。</p>\n<p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p>\n<p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p>\n<p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p>\n<pre><code class=\"language-js\">var Foo = () =&gt; {};\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n</code></pre>\n<h3>4. 没有 new.target</h3>\n<p>因为不能使用 new 调用，所以也没有 new.target 值。</p>\n<p>关于 new.target，可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7\">http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7</a></p>\n<h3>5. 没有原型</h3>\n<p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p>\n<pre><code class=\"language-js\">var Foo = () =&gt; {};\nconsole.log(Foo.prototype); // undefined\n</code></pre>\n<h3>6. 没有 super</h3>\n<p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>\n<h2>总结</h2>\n<p>最后，关于箭头函数，引用 MDN 的介绍就是：</p>\n<blockquote>\n<p>An arrow function expression has a shorter syntax than a function expression and does not have its own this, arguments, super, or new.target. These function expressions are best suited for non-method functions, and they cannot be used as constructors.</p>\n</blockquote>\n<p>翻译过来就是：</p>\n<p>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数。</p>\n<p>那么什么是 non-method functions 呢？</p>\n<p>我们先来看看 method 的定义：</p>\n<blockquote>\n<p>A method is a function which is a property of an object.</p>\n</blockquote>\n<p>对象属性中的函数就被称之为 method，那么 non-mehtod 就是指不被用作对象属性中的函数了，可是为什么说箭头函数更适合 non-method 呢？</p>\n<p>让我们来看一个例子就明白了：</p>\n<pre><code class=\"language-js\">var obj = {\n  i: 10,\n  b: () =&gt; console.log(this.i, this),\n  c: function() {\n    console.log( this.i, this)\n  }\n}\nobj.b();\n// undefined Window\nobj.c();\n// 10, Object {...}\n</code></pre>\n<h2>自执行函数</h2>\n<p>自执行函数的形式为：</p>\n<pre><code class=\"language-js\">(function(){\n    console.log(1)\n})()\n</code></pre>\n<p>或者</p>\n<pre><code class=\"language-js\">(function(){\n    console.log(1)\n}())\n</code></pre>\n<p>利用箭头简化自执行函数的写法：</p>\n<pre><code class=\"language-js\">(() =&gt; {\n    console.log(1)\n})()\n</code></pre>\n<p>但是注意：使用以下这种写法却会报错：</p>\n<pre><code class=\"language-js\">(() =&gt; {\n    console.log(1)\n}())\n</code></pre>\n<p>为什么会报错呢？嘿嘿，如果你知道，可以告诉我~</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}