{"code":0,"data":"<h2>前言</h2>\n<p>在 <a href=\"https://github.com/mqyqingfeng/Blog/issues/53\">《JavaScript 专题系列》</a> 中，我们写了很多的功能函数，比如防抖、节流、去重、类型判断、扁平数组、深浅拷贝、查找数组元素、通用遍历、柯里化、函数组合、函数记忆、乱序等，可以我们该如何组织这些函数，形成自己的一个工具函数库呢？这个时候，我们就要借鉴 underscore 是怎么做的了。</p>\n<h2>自己实现</h2>\n<p>如果是我们自己去组织这些函数，我们该怎么做呢？我想我会这样做：</p>\n<pre><code class=\"language-js\">(function(){\n    var root = this;\n\n    var _ = {};\n\n    root._ = _;\n\n    // 在这里添加自己的方法\n    _.reverse = function(string){\n        return string.split('').reverse().join('');\n    }\n\n})()\n\n_.reverse('hello');\n=&gt; 'olleh'\n</code></pre>\n<p>我们将所有的方法添加到一个名为 <code>_</code> 的对象上，然后将该对象挂载到全局对象上。</p>\n<p>之所以不直接 <code>window._ = _</code> 是因为我们写的是一个工具函数库，不仅要求可以运行在浏览器端，还可以运行在诸如 Node 等环境中。</p>\n<h2>root</h2>\n<p>然而 underscore 可不会写得如此简单，我们从 <code>var root = this</code> 开始说起。</p>\n<p>之所以写这一句，是因为我们要通过 this 获得全局对象，然后将 <code>_</code> 对象，挂载上去。</p>\n<p>然而在严格模式下，this 返回 undefined，而不是指向 Window，幸运的是 underscore 并没有采用严格模式，可是即便如此，也不能避免，因为在 ES6 中模块脚本自动采用严格模式，不管有没有声明 <code>use strict</code>。</p>\n<p>如果 this 返回 undefined，代码就会报错，所以我们的思路是对环境进行检测，然后挂载到正确的对象上。我们修改一下代码：</p>\n<pre><code class=\"language-js\">var root = (typeof window == 'object' &amp;&amp; window.window == window &amp;&amp; window) ||\n           (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global);\n</code></pre>\n<p>在这段代码中，我们判断了浏览器和 Node 环境，可是只有这两个环境吗？那我们来看看 Web Worker。</p>\n<h2>Web Worker</h2>\n<p>Web Worker 属于 HTML5 中的内容，引用《JavaScript权威指南》中的话就是：</p>\n<blockquote>\n<p>在 Web Worker 标准中，定义了解决客户端 JavaScript 无法多线程的问题。其中定义的 “worker” 是指执行代码的并行过程。不过，Web Worker 处在一个自包含的执行环境中，无法访问 Window 对象和 Document 对象，和主线程之间的通信业只能通过异步消息传递机制来实现。</p>\n</blockquote>\n<p>为了演示 Web Worker 的效果，我写了一个 demo，<a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/web-worker\">查看代码</a>。</p>\n<p>在 Web Worker 中，是无法访问 Window 对象的，所以 <code>typeof window</code> 和 <code>typeof global</code> 的结果都是 <code>undefined</code>，所以最终 root 的值为 false，将一个基本类型的值像对象一样添加属性和方法，自然是会报错的。</p>\n<p>那么我们该怎么办呢？</p>\n<p>虽然在 Web Worker 中不能访问到 Window 对象，但是我们却能通过 self 访问到 Worker 环境中的全局对象。我们只是要找全局变量挂载而已，所以完全可以挂到 self 中嘛。</p>\n<p>而且在浏览器中，除了 window 属性，我们也可以通过 self 属性直接访问到 Winow 对象。</p>\n<pre><code class=\"language-js\">console.log(window.window === window); // true\nconsole.log(window.self === window); // true\n</code></pre>\n<p>考虑到使用 self 还可以额外支持 Web Worker，我们直接将代码改成 self：</p>\n<pre><code class=\"language-js\">var root = (typeof self == 'object' &amp;&amp; self.self == self &amp;&amp; self) ||\n           (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global);\n</code></pre>\n<h2>node vm</h2>\n<p>到了这里，依然没完，让你想不到的是，在 node 的 vm 模块中，也就是沙盒模块，runInContext 方法中，是不存在 window，也不存在 global 变量的，<a href=\"https://github.com/mqyqingfeng/Blog/blob/master/demos/node-vm/index.js\">查看代码</a>。</p>\n<p>但是我们却可以通过 this 访问到全局对象，所以就有人发起了一个 PR，代码改成了：</p>\n<pre><code class=\"language-js\">var root = (typeof self == 'object' &amp;&amp; self.self == self &amp;&amp; self) ||\n           (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global) ||\n           this;\n</code></pre>\n<h2>微信小程序</h2>\n<p>到了这里，还是没完，轮到微信小程序登场了。</p>\n<p>因为在微信小程序中，window 和 global 都是 undefined，加上又强制使用严格模式，this 为 undefined，挂载就会发生错误，所以就有人又发了一个 PR，代码变成了：</p>\n<pre><code class=\"language-js\">var root = (typeof self == 'object' &amp;&amp; self.self == self &amp;&amp; self) ||\n           (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global) ||\n           this ||\n           {};\n</code></pre>\n<p>这就是现在 v1.8.3 的样子。</p>\n<p>虽然作者可以直接讲解最终的代码，但是作者更希望带着大家看看这看似普通的代码是如何一步步演变成这样的，也希望告诉大家，代码的健壮性，并非一蹴而就，而是汇集了很多人的经验，考虑到了很多我们意想不到的地方，这也是开源项目的好处吧。</p>\n<h2>函数对象</h2>\n<p>现在我们讲第二句 <code>var _ = {};</code>。</p>\n<p>如果仅仅设置 _ 为一个空对象，我们调用方法的时候，只能使用 <code>_.reverse('hello')</code> 的方式，实际上，underscore 也支持类似面向对象的方式调用，即：</p>\n<pre><code class=\"language-js\">_('hello').reverse(); // 'olleh'\n</code></pre>\n<p>再举个例子比较下两种调用方式：</p>\n<pre><code class=\"language-js\">// 函数式风格\n_.each([1, 2, 3], function(item){\n    console.log(item)\n});\n\n// 面向对象风格\n_([1, 2, 3]).each(function(item){\n    console.log(item)\n});\n</code></pre>\n<p>可是该如何实现呢？</p>\n<p>既然以 <code>_([1, 2, 3])</code> 的形式可以执行，就表明 <code>_</code> 不是一个字面量对象，而是一个函数！</p>\n<p>幸运的是，在 JavaScript 中，函数也是一种对象，我们举个例子：</p>\n<pre><code class=\"language-js\">var _ = function() {};\n_.value = 1;\n_.log = function() { return this.value + 1 };\n\nconsole.log(_.value); // 1\nconsole.log(_.log()); // 2\n</code></pre>\n<p>我们完全可以将自定义的函数定义在 <code>_</code> 函数上！</p>\n<p>目前的写法为：</p>\n<pre><code class=\"language-js\">var root = (typeof self == 'object' &amp;&amp; self.self == self &amp;&amp; self) ||\n           (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global) ||\n           this ||\n           {};\n\nvar _ = function() {}\n\nroot._ = _;\n</code></pre>\n<p>如何做到 <code>_([1, 2, 3]).each(...)</code>呢？即 _ 函数返回一个对象，这个对象，如何调用挂在 _ 函数上的方法呢？</p>\n<p>我们看看 underscore 是如何实现的：</p>\n<pre><code class=\"language-js\">var _ = function(obj) {\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n};\n\n_([1, 2, 3]);\n</code></pre>\n<p>我们分析下 <code>_([1, 2, 3])</code> 的执行过程：</p>\n<ol>\n<li>执行 <code>this instanceof _</code>，this 指向 window ，<code>window instanceof _</code> 为 false，<code>!</code>操作符取反，所以执行 <code>new _(obj)</code>。</li>\n<li><code>new _(obj)</code> 中，this 指向实例对象，<code>this instanceof _</code> 为 true，取反后，代码接着执行</li>\n<li>执行 <code>this._wrapped = obj</code>， 函数执行结束</li>\n<li>总结，<code>_([1, 2, 3])</code> 返回一个对象，为 <code>{_wrapped: [1, 2, 3]}</code>，该对象的原型指向 _.prototype</li>\n</ol>\n<p>示意图如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/underscore/new-obj.png\" alt=\"_()示意图\"></p>\n<p>然后问题来了，我们是将方法挂载到 _ 函数对象上，并没有挂到函数的原型上呐，所以返回了的实例，其实是无法调用 _ 函数对象上的方法的！</p>\n<p>我们写个例子：</p>\n<pre><code class=\"language-js\">(function(){\n    var root = (typeof self == 'object' &amp;&amp; self.self == self &amp;&amp; self) ||\n               (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global) ||\n               this ||\n               {};\n\n    var _ = function(obj) {\n        if (!(this instanceof _)) return new _(obj);\n        this._wrapped = obj;\n    }\n\n    root._ = _;\n\n    _.log = function(){\n        console.log(1)\n    }\n\n})()\n\n_().log(); // _(...).log is not a function\n</code></pre>\n<p>确实有这个问题，所以我们还需要一个方法将 _ 上的方法复制到 <code>_.prototype</code> 上，这个方法就是 <code>_.mixin</code>。</p>\n<h2>_.functions</h2>\n<p>为了将 _ 上的方法复制到原型上，首先我们要获得 _ 上的方法，所以我们先写个 <code>_.functions</code> 方法。</p>\n<pre><code class=\"language-js\">_.functions = function(obj) {\n    var names = [];\n    for (var key in obj) {\n        if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n};\n</code></pre>\n<p>isFunction 函数可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/issues/28\">《JavaScript专题之类型判断(下)》</a></p>\n<h2>mixin</h2>\n<p>现在我们可以写 mixin 方法了。</p>\n<pre><code class=\"language-js\">var ArrayProto = Array.prototype;\nvar push = ArrayProto.push;\n\n_.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n            var args = [this._wrapped];\n            push.apply(args, arguments);\n            return func.apply(_, args);\n        };\n    });\n    return _;\n};\n\n_.mixin(_);\n</code></pre>\n<p>each 方法可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/issues/40\">《JavaScript专题jQuery通用遍历方法each的实现》</a></p>\n<p>值得注意的是：因为 <code>_[name] = obj[name]</code> 的缘故，我们可以给 underscore 拓展自定义的方法:</p>\n<pre><code class=\"language-js\">_.mixin({\n  addOne: function(num) {\n    return num + 1;\n  }\n});\n\n_(2).addOne(); // 3\n</code></pre>\n<p>至此，我们算是实现了同时支持面向对象风格和函数风格。</p>\n<h2>导出</h2>\n<p>终于到了讲最后一步 <code>root._ = _</code>，我们直接看源码：</p>\n<pre><code class=\"language-js\">if (typeof exports != 'undefined' &amp;&amp; !exports.nodeType) {\n    if (typeof module != 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) {\n        exports = module.exports = _;\n    }\n    exports._ = _;\n} else {\n    root._ = _;\n}\n</code></pre>\n<p>为了支持模块化，我们需要将 _ 在合适的环境中作为模块导出，但是 nodejs 模块的 API 曾经发生过改变，比如在早期版本中：</p>\n<pre><code class=\"language-js\">// add.js\nexports.addOne = function(num) {\n  return num + 1\n}\n\n// index.js\nvar add = require('./add');\nadd.addOne(2);\n</code></pre>\n<p>在新版本中：</p>\n<pre><code class=\"language-js\">// add.js\nmodule.exports = function(1){\n    return num + 1\n}\n\n// index.js\nvar addOne = require('./add.js')\naddOne(2)\n</code></pre>\n<p>所以我们根据 exports 和 module 是否存在来选择不同的导出方式，那为什么在新版本中，我们还要使用 <code>exports = module.exports = _</code> 呢？</p>\n<p>这是因为在 nodejs 中，exports 是 module.exports 的一个引用，当你使用了 module.exports = function(){}，实际上覆盖了 module.exports，但是 exports 并未发生改变，为了避免后面再修改 exports 而导致不能正确输出，就写成这样，将两者保持统一。</p>\n<p>写个 demo 吧：</p>\n<pre><code class=\"language-js\">// exports 是 module.exports 的一个引用\nmodule.exports.num = '1'\n\nconsole.log(exports.num) // 1\n\nexports.num = '2'\n\nconsole.log(module.exports.num) // 2\n</code></pre>\n<pre><code class=\"language-js\">// addOne.js\nmodule.exports = function(num){\n    return num + 1\n}\n\nexports.num = '3'\n\n// result.js 中引入 addOne.js\nvar addOne = require('./addOne.js');\n\nconsole.log(addOne(1)) // 2\nconsole.log(addOne.num) // undefined\n</code></pre>\n<pre><code class=\"language-js\">// addOne.js\nexports = module.exports = function(num){\n    return num + 1\n}\n\nexports.num = '3'\n\n// result.js 中引入 addOne.js\nvar addOne = require('./addOne.js');\n\nconsole.log(addOne(1)) // 2\nconsole.log(addOne.num) // 3\n</code></pre>\n<p>最后为什么要进行一个 exports.nodeType 判断呢？这是因为如果你在 HTML 页面中加入一个 id 为 exports 的元素，比如</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;exports&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>就会生成一个 window.exports 全局变量，你可以直接在浏览器命令行中打印该变量。</p>\n<p>此时在浏览器中，<code>typeof exports != 'undefined'</code> 的判断就会生效，然后 <code>exports._ = _</code>，然而在浏览器中，我们需要将 _ 挂载到全局变量上呐，所以在这里，我们还需要进行一个是否是 DOM 节点的判断。</p>\n<h2>源码</h2>\n<p>最终的代码如下，有了这个基本结构，你可以自由添加你需要使用到的函数了：</p>\n<pre><code class=\"language-js\">(function() {\n\n    var root = (typeof self == 'object' &amp;&amp; self.self == self &amp;&amp; self) ||\n        (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global) ||\n        this || {};\n\n    var ArrayProto = Array.prototype;\n\n    var push = ArrayProto.push;\n\n    var _ = function(obj) {\n        if (obj instanceof _) return obj;\n        if (!(this instanceof _)) return new _(obj);\n        this._wrapped = obj;\n    };\n\n    if (typeof exports != 'undefined' &amp;&amp; !exports.nodeType) {\n        if (typeof module != 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) {\n            exports = module.exports = _;\n        }\n        exports._ = _;\n    } else {\n        root._ = _;\n    }\n\n    _.VERSION = '0.1';\n\n    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n    var isArrayLike = function(collection) {\n        var length = collection.length;\n        return typeof length == 'number' &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;\n    };\n\n    _.each = function(obj, callback) {\n        var length, i = 0;\n\n        if (isArrayLike(obj)) {\n            length = obj.length;\n            for (; i &lt; length; i++) {\n                if (callback.call(obj[i], obj[i], i) === false) {\n                    break;\n                }\n            }\n        } else {\n            for (i in obj) {\n                if (callback.call(obj[i], obj[i], i) === false) {\n                    break;\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    _.isFunction = function(obj) {\n        return typeof obj == 'function' || false;\n    };\n\n    _.functions = function(obj) {\n        var names = [];\n        for (var key in obj) {\n            if (_.isFunction(obj[key])) names.push(key);\n        }\n        return names.sort();\n    };\n\n    /**\n     * 在 _.mixin(_) 前添加自己定义的方法\n     */\n    _.reverse = function(string){\n        return string.split('').reverse().join('');\n    }\n\n    _.mixin = function(obj) {\n        _.each(_.functions(obj), function(name) {\n            var func = _[name] = obj[name];\n            _.prototype[name] = function() {\n                var args = [this._wrapped];\n\n                push.apply(args, arguments);\n\n                return func.apply(_, args);\n            };\n        });\n        return _;\n    };\n\n    _.mixin(_);\n\n})()\n</code></pre>\n<h2>相关链接</h2>\n<ol>\n<li>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/28\">《JavaScript专题之类型判断(下)》</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/40\">《JavaScript专题jQuery通用遍历方法each的实现》</a></p>\n</li>\n</ol>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}