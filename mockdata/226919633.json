{"code":0,"data":"<h2>类数组对象</h2>\n<p>所谓的类数组对象:</p>\n<blockquote>\n<p>拥有一个 length 属性和若干索引属性的对象</p>\n</blockquote>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">var array = ['name', 'age', 'sex'];\n\nvar arrayLike = {\n    0: 'name',\n    1: 'age',\n    2: 'sex',\n    length: 3\n}\n</code></pre>\n<p>即便如此，为什么叫做类数组对象呢？</p>\n<p>那让我们从读写、获取长度、遍历三个方面看看这两个对象。</p>\n<h2>读写</h2>\n<pre><code class=\"language-js\">console.log(array[0]); // name\nconsole.log(arrayLike[0]); // name\n\narray[0] = 'new name';\narrayLike[0] = 'new name';\n</code></pre>\n<h2>长度</h2>\n<pre><code class=\"language-js\">console.log(array.length); // 3\nconsole.log(arrayLike.length); // 3\n</code></pre>\n<h2>遍历</h2>\n<pre><code class=\"language-js\">for(var i = 0, len = array.length; i &lt; len; i++) {\n   ……\n}\nfor(var i = 0, len = arrayLike.length; i &lt; len; i++) {\n    ……\n}\n</code></pre>\n<p>是不是很像？</p>\n<p>那类数组对象可以使用数组的方法吗？比如：</p>\n<pre><code class=\"language-js\">arrayLike.push('4');\n</code></pre>\n<p>然而上述代码会报错: arrayLike.push is not a function</p>\n<p>所以终归还是类数组呐……</p>\n<h2>调用数组方法</h2>\n<p>如果类数组就是任性的想用数组的方法怎么办呢？</p>\n<p>既然无法直接调用，我们可以用 Function.call 间接调用：</p>\n<pre><code class=\"language-js\">var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }\n\nArray.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sex\n\nArray.prototype.slice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] \n// slice可以做到类数组转数组\n\nArray.prototype.map.call(arrayLike, function(item){\n    return item.toUpperCase();\n}); \n// [&quot;NAME&quot;, &quot;AGE&quot;, &quot;SEX&quot;]\n</code></pre>\n<h2>类数组转数组</h2>\n<p>在上面的例子中已经提到了一种类数组转数组的方法，再补充三个：</p>\n<pre><code class=\"language-js\">var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }\n// 1. slice\nArray.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] \n// 2. splice\nArray.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] \n// 3. ES6 Array.from\nArray.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] \n// 4. apply\nArray.prototype.concat.apply([], arrayLike)\n</code></pre>\n<p>那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？</p>\n<p>要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。</p>\n<h2>Arguments对象</h2>\n<p>接下来重点讲讲 Arguments 对象。</p>\n<p>Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">function foo(name, age, sex) {\n    console.log(arguments);\n}\n\nfoo('name', 'age', 'sex')\n</code></pre>\n<p>打印结果如下：</p>\n<p><img src=\"https://github.com/mqyqingfeng/Blog/raw/master/Images/arguments.png\" alt=\"arguments\"></p>\n<p>我们可以看到除了类数组的索引属性和length属性之外，还有一个callee属性，接下来我们一个一个介绍。</p>\n<h2>length属性</h2>\n<p>Arguments对象的length属性，表示实参的长度，举个例子：</p>\n<pre><code class=\"language-js\">function foo(b, c, d){\n    console.log(&quot;实参的长度为：&quot; + arguments.length)\n}\n\nconsole.log(&quot;形参的长度为：&quot; + foo.length)\n\nfoo(1)\n\n// 形参的长度为：3\n// 实参的长度为：1\n</code></pre>\n<h2>callee属性</h2>\n<p>Arguments 对象的 callee 属性，通过它可以调用函数自身。</p>\n<p>讲个闭包经典面试题使用 callee 的解决方法：</p>\n<pre><code class=\"language-js\">var data = [];\n\nfor (var i = 0; i &lt; 3; i++) {\n    (data[i] = function () {\n       console.log(arguments.callee.i) \n    }).i = i;\n}\n\ndata[0]();\ndata[1]();\ndata[2]();\n\n// 0\n// 1\n// 2\n</code></pre>\n<p>接下来讲讲 arguments 对象的几个注意要点：</p>\n<h2>arguments 和对应参数的绑定</h2>\n<pre><code class=\"language-js\">function foo(name, age, sex, hobbit) {\n\n    console.log(name, arguments[0]); // name name\n\n    // 改变形参\n    name = 'new name';\n\n    console.log(name, arguments[0]); // new name new name\n\n    // 改变arguments\n    arguments[1] = 'new age';\n\n    console.log(age, arguments[1]); // new age new age\n\n    // 测试未传入的是否会绑定\n    console.log(sex); // undefined\n\n    sex = 'new sex';\n\n    console.log(sex, arguments[2]); // new sex undefined\n\n    arguments[3] = 'new hobbit';\n\n    console.log(hobbit, arguments[3]); // undefined new hobbit\n\n}\n\nfoo('name', 'age')\n</code></pre>\n<p>传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享</p>\n<p>除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。</p>\n<h2>传递参数</h2>\n<p>将参数从一个函数传递到另一个函数</p>\n<pre><code class=\"language-js\">// 使用 apply 将 foo 的参数传递给 bar\nfunction foo() {\n    bar.apply(this, arguments);\n}\nfunction bar(a, b, c) {\n   console.log(a, b, c);\n}\n\nfoo(1, 2, 3)\n</code></pre>\n<h2>强大的ES6</h2>\n<p>使用ES6的 ... 运算符，我们可以轻松转成数组。</p>\n<pre><code class=\"language-js\">function func(...arguments) {\n    console.log(arguments); // [1, 2, 3]\n}\n\nfunc(1, 2, 3);\n</code></pre>\n<h2>应用</h2>\n<p>arguments的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。</p>\n<p>如果要总结这些场景的话，暂时能想到的包括：</p>\n<ol>\n<li>参数不定长</li>\n<li>函数柯里化</li>\n<li>递归调用</li>\n<li>函数重载\n...</li>\n</ol>\n<p>欢迎留言回复。</p>\n<h2>下一篇文章</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/15\">JavaScript深入之创建对象的多种方式以及优缺点</a></p>\n<h2>深入系列</h2>\n<p>JavaScript深入系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}