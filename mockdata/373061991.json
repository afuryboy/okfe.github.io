{"code":0,"data":"<h2>async</h2>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>在异步处理上，async 函数就是 Generator 函数的语法糖。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">// 使用 generator\nvar fetch = require('node-fetch');\nvar co = require('co');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var json1 = yield r1.json();\n    console.log(json1.bio);\n}\n\nco(gen);\n</code></pre>\n<p>当你使用 async 时：</p>\n<pre><code class=\"language-js\">// 使用 async\nvar fetch = require('node-fetch');\n\nvar fetchData = async function () {\n    var r1 = await fetch('https://api.github.com/users/github');\n    var json1 = await r1.json();\n    console.log(json1.bio);\n};\n\nfetchData();\n</code></pre>\n<p>其实 async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n<pre><code class=\"language-js\">async function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n</code></pre>\n<p>spawn 函数指的是自动执行器，就比如说 co。</p>\n<p>再加上 async 函数返回一个 Promise 对象，你也可以理解为 async 函数是基于 Promise 和 Generator 的一层封装。</p>\n<h2>async 与 Promise</h2>\n<p>严谨的说，async 是一种语法，Promise 是一个内置对象，两者并不具备可比性，更何况 async 函数也返回一个 Promise 对象……</p>\n<p>这里主要是展示一些场景，使用 async 会比使用 Promise 更优雅的处理异步流程。</p>\n<h3>1. 代码更加简洁</h3>\n<pre><code class=\"language-js\">/**\n * 示例一\n */\nfunction fetch() {\n  return (\n    fetchData()\n    .then(() =&gt; {\n      return &quot;done&quot;\n    });\n  )\n}\n\nasync function fetch() {\n  await fetchData()\n  return &quot;done&quot;\n};\n</code></pre>\n<pre><code class=\"language-js\">/**\n * 示例二\n */\nfunction fetch() {\n  return fetchData()\n  .then(data =&gt; {\n    if (data.moreData) {\n        return fetchAnotherData(data)\n        .then(moreData =&gt; {\n          return moreData\n        })\n    } else {\n      return data\n    }\n  });\n}\n\nasync function fetch() {\n  const data = await fetchData()\n  if (data.moreData) {\n    const moreData = await fetchAnotherData(data);\n    return moreData\n  } else {\n    return data\n  }\n};\n</code></pre>\n<pre><code class=\"language-js\">/**\n * 示例三\n */\nfunction fetch() {\n  return (\n    fetchData()\n    .then(value1 =&gt; {\n      return fetchMoreData(value1)\n    })\n    .then(value2 =&gt; {\n      return fetchMoreData2(value2)\n    })\n  )\n}\n\nasync function fetch() {\n  const value1 = await fetchData()\n  const value2 = await fetchMoreData(value1)\n  return fetchMoreData2(value2)\n};\n</code></pre>\n<h3>2. 错误处理</h3>\n<pre><code class=\"language-js\">function fetch() {\n  try {\n    fetchData()\n      .then(result =&gt; {\n        const data = JSON.parse(result)\n      })\n      .catch((err) =&gt; {\n        console.log(err)\n      })\n  } catch (err) {\n    console.log(err)\n  }\n}\n</code></pre>\n<p>在这段代码中，try/catch 能捕获 fetchData() 中的一些 Promise 构造错误，但是不能捕获 JSON.parse 抛出的异常，如果要处理 JSON.parse 抛出的异常，需要添加 catch 函数重复一遍异常处理的逻辑。</p>\n<p>在实际项目中，错误处理逻辑可能会很复杂，这会导致冗余的代码。</p>\n<pre><code class=\"language-js\">async function fetch() {\n  try {\n    const data = JSON.parse(await fetchData())\n  } catch (err) {\n    console.log(err)\n  }\n};\n</code></pre>\n<p>async/await 的出现使得 try/catch 就可以捕获同步和异步的错误。</p>\n<h3>3. 调试</h3>\n<pre><code class=\"language-js\">const fetchData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 1))\nconst fetchMoreData = (value) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, value + 1))\nconst fetchMoreData2 = (value) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, value + 2))\n\nfunction fetch() {\n  return (\n    fetchData()\n    .then((value1) =&gt; {\n      console.log(value1)\n      return fetchMoreData(value1)\n    })\n    .then(value2 =&gt; {\n      return fetchMoreData2(value2)\n    })\n  )\n}\n\nconst res = fetch();\nconsole.log(res);\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/ES6/async/promise.gif\" alt=\"promise 断点演示\"></p>\n<p>因为 then 中的代码是异步执行，所以当你打断点的时候，代码不会顺序执行，尤其当你使用 step over 的时候，then 函数会直接进入下一个 then 函数。</p>\n<pre><code class=\"language-js\">const fetchData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 1))\nconst fetchMoreData = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 2))\nconst fetchMoreData2 = () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, 3))\n\nasync function fetch() {\n  const value1 = await fetchData()\n  const value2 = await fetchMoreData(value1)\n  return fetchMoreData2(value2)\n};\n\nconst res = fetch();\nconsole.log(res);\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/ES6/async/async.gif\" alt=\"async 断点演示\"></p>\n<p>而使用 async 的时候，则可以像调试同步代码一样调试。</p>\n<h2>async 地狱</h2>\n<p>async 地狱主要是指开发者贪图语法上的简洁而让原本可以并行执行的内容变成了顺序执行，从而影响了性能，但用地狱形容有点夸张了点……</p>\n<h3>例子一</h3>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n  const getList = await getList();\n  const getAnotherList = await getAnotherList();\n})();\n</code></pre>\n<p>getList() 和 getAnotherList() 其实并没有依赖关系，但是现在的这种写法，虽然简洁，却导致了 getAnotherList() 只能在 getList() 返回后才会执行，从而导致了多一倍的请求时间。</p>\n<p>为了解决这个问题，我们可以改成这样：</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n  const listPromise = getList();\n  const anotherListPromise = getAnotherList();\n  await listPromise;\n  await anotherListPromise;\n})();\n</code></pre>\n<p>也可以使用 Promise.all()：</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n  Promise.all([getList(), getAnotherList()]).then(...);\n})();\n</code></pre>\n<h3>例子二</h3>\n<p>当然上面这个例子比较简单，我们再来扩充一下：</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n  const listPromise = await getList();\n  const anotherListPromise = await getAnotherList();\n\n  // do something\n\n  await submit(listData);\n  await submit(anotherListData);\n\n})();\n</code></pre>\n<p>因为 await 的特性，整个例子有明显的先后顺序，然而 getList() 和 getAnotherList() 其实并无依赖，submit(listData) 和 submit(anotherListData) 也没有依赖关系，那么对于这种例子，我们该怎么改写呢？</p>\n<p>基本分为三个步骤：</p>\n<p><strong>1. 找出依赖关系</strong></p>\n<p>在这里，submit(listData) 需要在 getList() 之后，submit(anotherListData) 需要在 anotherListPromise() 之后。</p>\n<p><strong>2. 将互相依赖的语句包裹在 async 函数中</strong></p>\n<pre><code class=\"language-js\">async function handleList() {\n  const listPromise = await getList();\n  // ...\n  await submit(listData);\n}\n\nasync function handleAnotherList() {\n  const anotherListPromise = await getAnotherList()\n  // ...\n  await submit(anotherListData)\n}\n</code></pre>\n<p><strong>3.并发执行 async 函数</strong></p>\n<pre><code class=\"language-js\">async function handleList() {\n  const listPromise = await getList();\n  // ...\n  await submit(listData);\n}\n\nasync function handleAnotherList() {\n  const anotherListPromise = await getAnotherList()\n  // ...\n  await submit(anotherListData)\n}\n\n// 方法一\n(async () =&gt; {\n  const handleListPromise = handleList()\n  const handleAnotherListPromise = handleAnotherList()\n  await handleListPromise\n  await handleAnotherListPromise\n})()\n\n// 方法二\n(async () =&gt; {\n  Promise.all([handleList(), handleAnotherList()]).then()\n})()\n</code></pre>\n<h2>继发与并发</h2>\n<p><strong>问题：给定一个 URL 数组，如何实现接口的继发和并发？</strong></p>\n<p>async 继发实现：</p>\n<pre><code class=\"language-js\">// 继发一\nasync function loadData() {\n  var res1 = await fetch(url1);\n  var res2 = await fetch(url2);\n  var res3 = await fetch(url3);\n  return &quot;whew all done&quot;;\n}\n</code></pre>\n<pre><code class=\"language-js\">// 继发二\nasync function loadData(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n</code></pre>\n<p>async 并发实现：</p>\n<pre><code class=\"language-js\">// 并发一\nasync function loadData() {\n  var res = await Promise.all([fetch(url1), fetch(url2), fetch(url3)]);\n  return &quot;whew all done&quot;;\n}\n</code></pre>\n<pre><code class=\"language-js\">// 并发二\nasync function loadData(urls) {\n  // 并发读取 url\n  const textPromises = urls.map(async url =&gt; {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n</code></pre>\n<h2>async 错误捕获</h2>\n<p>尽管我们可以使用 try catch 捕获错误，但是当我们需要捕获多个错误并做不同的处理时，很快 try catch 就会导致代码杂乱，就比如：</p>\n<pre><code class=\"language-js\">async function asyncTask(cb) {\n    try {\n       const user = await UserModel.findById(1);\n       if(!user) return cb('No user found');\n    } catch(e) {\n        return cb('Unexpected error occurred');\n    }\n\n    try {\n       const savedTask = await TaskModel({userId: user.id, name: 'Demo Task'});\n    } catch(e) {\n        return cb('Error occurred while saving task');\n    }\n\n    if(user.notificationsEnabled) {\n        try {\n            await NotificationService.sendNotification(user.id, 'Task Created');\n        } catch(e) {\n            return cb('Error while sending notification');\n        }\n    }\n\n    if(savedTask.assignedUser.id !== user.id) {\n        try {\n            await NotificationService.sendNotification(savedTask.assignedUser.id, 'Task was created for you');\n        } catch(e) {\n            return cb('Error while sending notification');\n        }\n    }\n\n    cb(null, savedTask);\n}\n</code></pre>\n<p>为了简化这种错误的捕获，我们可以给 await 后的 promise 对象添加 catch 函数，为此我们需要写一个 helper:</p>\n<pre><code class=\"language-js\">// to.js\nexport default function to(promise) {\n   return promise.then(data =&gt; {\n      return [null, data];\n   })\n   .catch(err =&gt; [err]);\n}\n</code></pre>\n<p>整个错误捕获的代码可以简化为：</p>\n<pre><code class=\"language-js\">import to from './to.js';\n\nasync function asyncTask() {\n     let err, user, savedTask;\n\n     [err, user] = await to(UserModel.findById(1));\n     if(!user) throw new CustomerError('No user found');\n\n     [err, savedTask] = await to(TaskModel({userId: user.id, name: 'Demo Task'}));\n     if(err) throw new CustomError('Error occurred while saving task');\n\n    if(user.notificationsEnabled) {\n       const [err] = await to(NotificationService.sendNotification(user.id, 'Task Created'));\n       if (err) console.error('Just log the error and continue flow');\n    }\n}\n</code></pre>\n<h2>async 的一些讨论</h2>\n<h3>async 会取代 Generator 吗？</h3>\n<p>Generator 本来是用作生成器，使用 Generator 处理异步请求只是一个比较 hack 的用法，在异步方面，async 可以取代 Generator，但是 async 和 Generator 两个语法本身是用来解决不同的问题的。</p>\n<h3>async 会取代 Promise 吗？</h3>\n<ol>\n<li>\n<p>async 函数返回一个 Promise 对象</p>\n</li>\n<li>\n<p>面对复杂的异步流程，Promise 提供的 all 和 race 会更加好用</p>\n</li>\n<li>\n<p>Promise 本身是一个对象，所以可以在代码中任意传递</p>\n</li>\n<li>\n<p>async 的支持率还很低，即使有 Babel，编译后也要增加 1000 行左右。</p>\n</li>\n</ol>\n<h2>参考</h2>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26260061\">[译] 6 个 Async/Await 优于 Promise 的方面</a></li>\n<li><a href=\"https://juejin.im/post/5aefbb48f265da0b9b073c40\">[译] 如何逃离 async/await 地狱</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000014753495\">精读《async/await 是把双刃剑》</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/async\">ECMAScript 6 入门</a></li>\n<li><a href=\"https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/\">How to write async await without try-catch blocks in Javascript</a></li>\n</ol>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}