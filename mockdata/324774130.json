{"code":0,"data":"<h2>块级作用域的出现</h2>\n<p>通过 var 声明的变量存在变量提升的特性：</p>\n<pre><code class=\"language-js\">if (condition) {\n    var value = 1;\n}\nconsole.log(value);\n</code></pre>\n<p>初学者可能会觉得只有 condition 为 true 的时候，才会创建 value，如果 condition 为 false，结果应该是报错，然而因为变量提升的原因，代码相当于：</p>\n<pre><code class=\"language-js\">var value;\nif (condition) {\n    value = 1;\n}\nconsole.log(value);\n</code></pre>\n<p>如果 condition 为 false，结果会是 undefined。</p>\n<p>除此之外，在 for 循环中：</p>\n<pre><code class=\"language-js\">for (var i = 0; i &lt; 10; i++) {\n    ...\n}\nconsole.log(i); // 10\n</code></pre>\n<p>即便循环已经结束了，我们依然可以访问 i 的值。</p>\n<p>为了加强对变量生命周期的控制，ECMAScript 6 引入了块级作用域。</p>\n<p>块级作用域存在于：</p>\n<ul>\n<li>函数内部</li>\n<li>块中(字符 { 和 } 之间的区域)</li>\n</ul>\n<h2>let 和 const</h2>\n<p>块级声明用于声明在指定块的作用域之外无法访问的变量。</p>\n<p>let 和 const 都是块级声明的一种。</p>\n<p>我们来回顾下 let 和 const 的特点：</p>\n<p><strong>1.不会被提升</strong></p>\n<pre><code class=\"language-js\">if (false) {\n    let value = 1;\n}\nconsole.log(value); // Uncaught ReferenceError: value is not defined\n</code></pre>\n<p><strong>2.重复声明报错</strong></p>\n<pre><code class=\"language-js\">var value = 1;\nlet value = 2; // Uncaught SyntaxError: Identifier 'value' has already been declared\n</code></pre>\n<p><strong>3.不绑定全局作用域</strong></p>\n<p>当在全局作用域中使用 var 声明的时候，会创建一个新的全局变量作为全局对象的属性。</p>\n<pre><code class=\"language-js\">var value = 1;\nconsole.log(window.value); // 1\n</code></pre>\n<p>然而 let 和 const 不会：</p>\n<pre><code class=\"language-js\">let value = 1;\nconsole.log(window.value); // undefined\n</code></pre>\n<p>再来说下 let 和 const 的区别：</p>\n<p>const 用于声明常量，其值一旦被设定不能再被修改，否则会报错。</p>\n<p>值得一提的是：const 声明不允许修改绑定，但允许修改值。这意味着当用 const 声明对象时：</p>\n<pre><code class=\"language-js\">const data = {\n    value: 1\n}\n\n// 没有问题\ndata.value = 2;\ndata.num = 3;\n\n// 报错\ndata = {}; // Uncaught TypeError: Assignment to constant variable.\n</code></pre>\n<h2>临时死区</h2>\n<p>临时死区(Temporal Dead Zone)，简写为 TDZ。</p>\n<p>let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错：</p>\n<pre><code class=\"language-js\">console.log(typeof value); // Uncaught ReferenceError: value is not defined\nlet value = 1;\n</code></pre>\n<p>这是因为 JavaScript 引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到 var 声明)，要么将声明放在 TDZ 中(遇到 let 和 const 声明)。访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后方可访问。</p>\n<p>看似很好理解，不保证你不犯错：</p>\n<pre><code class=\"language-js\">var value = &quot;global&quot;;\n\n// 例子1\n(function() {\n    console.log(value);\n\n    let value = 'local';\n}());\n\n// 例子2\n{\n    console.log(value);\n\n    const value = 'local';\n};\n</code></pre>\n<p>两个例子中，结果并不会打印 &quot;global&quot;，而是报错 <code>Uncaught ReferenceError: value is not defined</code>，就是因为 TDZ 的缘故。</p>\n<h2>循环中的块级作用域</h2>\n<pre><code class=\"language-js\">var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {\n    funcs[i] = function () {\n        console.log(i);\n    };\n}\nfuncs[0](); // 3\n</code></pre>\n<p>一个老生常谈的面试题，解决方案如下：</p>\n<pre><code class=\"language-js\">var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {\n    funcs[i] = (function(i){\n        return function() {\n            console.log(i);\n        }\n    }(i))\n}\nfuncs[0](); // 0\n</code></pre>\n<p>ES6 的 let 为这个问题提供了新的解决方法：</p>\n<pre><code class=\"language-js\">var funcs = [];\nfor (let i = 0; i &lt; 3; i++) {\n    funcs[i] = function () {\n        console.log(i);\n    };\n}\nfuncs[0](); // 0\n</code></pre>\n<p>问题在于，上面讲了 let 不提升，不能重复声明，不能绑定全局作用域等等特性，可是为什么在这里就能正确打印出 i 值呢？</p>\n<p>如果是不重复声明，在循环第二次的时候，又用 let 声明了 i，应该报错呀，就算因为某种原因，重复声明不报错，一遍一遍迭代，i 的值最终还是应该是 3 呀，还有人说 for 循环的\n设置循环变量的那部分是一个单独的作用域，就比如：</p>\n<pre><code class=\"language-js\">for (let i = 0; i &lt; 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n</code></pre>\n<p>这个例子是对的，如果我们把 let 改成 var 呢？</p>\n<pre><code class=\"language-js\">for (var i = 0; i &lt; 3; i++) {\n  var i = 'abc';\n  console.log(i);\n}\n// abc\n</code></pre>\n<p>为什么结果就不一样了呢，如果有单独的作用域，结果应该是相同的呀……</p>\n<p>如果要追究这个问题，就要抛弃掉之前所讲的这些特性！这是因为 let 声明在循环内部的行为是标准中专门定义的，不一定就与 let 的不提升特性有关，其实，在早期的 let 实现中就不包含这一行为。</p>\n<p>我们查看<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement-runtime-semantics-labelledevaluation\"> ECMAScript 规范第 13.7.4.7 节</a>:</p>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/ES6/let/let-ecma.png\" alt=\"let 规范\"></p>\n<p>我们会发现，在 for 循环中使用 let 和 var，底层会使用不同的处理方式。</p>\n<p>那么当使用 let 的时候底层到底是怎么做的呢？</p>\n<p>简单的来说，就是在 <code>for (let i = 0; i &lt; 3; i++)</code> 中，即圆括号之内建立一个隐藏的作用域，这就可以解释为什么:</p>\n<pre><code class=\"language-js\">for (let i = 0; i &lt; 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n</code></pre>\n<p>然后<strong>每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化</strong>。这样对于下面这样一段代码</p>\n<pre><code class=\"language-js\">var funcs = [];\nfor (let i = 0; i &lt; 3; i++) {\n    funcs[i] = function () {\n        console.log(i);\n    };\n}\nfuncs[0](); // 0\n</code></pre>\n<p>就相当于：</p>\n<pre><code class=\"language-js\">// 伪代码\n(let i = 0) {\n    funcs[0] = function() {\n        console.log(i)\n    };\n}\n\n(let i = 1) {\n    funcs[1] = function() {\n        console.log(i)\n    };\n}\n\n(let i = 2) {\n    funcs[2] = function() {\n        console.log(i)\n    };\n};\n</code></pre>\n<p>当执行函数的时候，根据词法作用域就可以找到正确的值，其实你也可以理解为 let 声明模仿了闭包的做法来简化循环过程。</p>\n<h2>循环中的 let 和 const</h2>\n<p>不过到这里还没有结束，如果我们把 let 改成 const 呢？</p>\n<pre><code class=\"language-js\">var funcs = [];\nfor (const i = 0; i &lt; 10; i++) {\n    funcs[i] = function () {\n        console.log(i);\n    };\n}\nfuncs[0](); // Uncaught TypeError: Assignment to constant variable.\n</code></pre>\n<p>结果会是报错，因为虽然我们每次都创建了一个新的变量，然而我们却在迭代中尝试修改 const 的值，所以最终会报错。</p>\n<p>说完了普通的 for 循环，我们还有 for in 循环呢~</p>\n<p>那下面的结果是什么呢？</p>\n<pre><code class=\"language-js\">var funcs = [], object = {a: 1, b: 1, c: 1};\nfor (var key in object) {\n    funcs.push(function(){\n        console.log(key)\n    });\n}\n\nfuncs[0]()\n</code></pre>\n<p>结果是 'c';</p>\n<p>那如果把 var 改成 let 或者 const 呢？</p>\n<p>使用 let，结果自然会是 'a'，const 呢？ 报错还是 'a'?</p>\n<p>结果是正确打印 'a'，这是因为在 for in 循环中，每次迭代不会修改已有的绑定，而是会创建一个新的绑定。</p>\n<h2>Babel</h2>\n<p>在 Babel 中是如何编译 let 和 const 的呢？我们来看看编译后的代码：</p>\n<pre><code class=\"language-js\">let value = 1;\n</code></pre>\n<p>编译为:</p>\n<pre><code class=\"language-js\">var value = 1;\n</code></pre>\n<p>我们可以看到 Babel 直接将 let 编译成了 var，如果是这样的话，那么我们来写个例子：</p>\n<pre><code class=\"language-js\">if (false) {\n    let value = 1;\n}\nconsole.log(value); // Uncaught ReferenceError: value is not defined\n</code></pre>\n<p>如果还是直接编译成 var，打印的结果肯定是 undefined，然而 Babel 很聪明，它编译成了：</p>\n<pre><code class=\"language-js\">if (false) {\n    var _value = 1;\n}\nconsole.log(value);\n</code></pre>\n<p>我们再写个直观的例子：</p>\n<pre><code class=\"language-js\">let value = 1;\n{\n    let value = 2;\n}\nvalue = 3;\n</code></pre>\n<pre><code class=\"language-js\">var value = 1;\n{\n    var _value = 2;\n}\nvalue = 3;\n</code></pre>\n<p>本质是一样的，就是改变量名，使内外层的变量名称不一样。</p>\n<p>那像 const 的修改值时报错，以及重复声明报错怎么实现的呢？</p>\n<p>其实就是在编译的时候直接给你报错……</p>\n<p>那循环中的 let 声明呢？</p>\n<pre><code class=\"language-js\">var funcs = [];\nfor (let i = 0; i &lt; 10; i++) {\n    funcs[i] = function () {\n        console.log(i);\n    };\n}\nfuncs[0](); // 0\n</code></pre>\n<p>Babel 巧妙的编译成了：</p>\n<pre><code class=\"language-js\">var funcs = [];\n\nvar _loop = function _loop(i) {\n    funcs[i] = function () {\n        console.log(i);\n    };\n};\n\nfor (var i = 0; i &lt; 10; i++) {\n    _loop(i);\n}\nfuncs[0](); // 0\n</code></pre>\n<h2>最佳实践</h2>\n<p>在我们开发的时候，可能认为应该默认使用 let 而不是 var ，这种情况下，对于需要写保护的变量要使用 const。然而另一种做法日益普及：默认使用 const，只有当确实需要改变变量的值的时候才使用 let。这是因为大部分的变量的值在初始化后不应再改变，而预料之外的变量之的改变是很多 bug 的源头。</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：https://github.com/mqyqingfeng/Blog</p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}