{"code":0,"data":"<h2>前言</h2>\n<p>本文接着上篇<a href=\"https://github.com/mqyqingfeng/Blog/issues/56\">《underscore 系列之如何写自己的 underscore》</a>，阅读本篇前，希望你已经阅读了上一篇。</p>\n<h2>jQuery</h2>\n<p>我们都知道 jQuery 可以链式调用，比如：</p>\n<pre><code class=\"language-js\">$(&quot;div&quot;).eq(0).css(&quot;width&quot;, &quot;200px&quot;).show();\n</code></pre>\n<p>我们写个简单的 demo 模拟链式调用：</p>\n<pre><code class=\"language-js\">function JQuery(selector) {\n    this.elements = [];\n    var nodeLists = document.getElementsByTagName(selector);\n    for (var i = 0; i &lt; nodeLists.length; i++) {\n        this.elements.push(nodeLists[i]);\n    }\n    return this;\n}\n\nJQuery.prototype = {\n    eq: function(num){\n        this.elements = [this.elements[num]];\n        return this;\n    },\n    css: function(prop, val) {\n        this.elements.forEach(function(el){\n            el.style[prop] = val;\n        })\n        return this;\n    },\n    show: function() {\n        this.css('display', 'block');\n        return this;\n    }\n\n}\n\nwindow.$ = function(selector){\n    return new JQuery(selector)\n}\n\n$(&quot;div&quot;).eq(0).css(&quot;width&quot;, &quot;200px&quot;).show();\n</code></pre>\n<p>jQuery 之所以能实现链式调用，关键就在于通过 <code>return this</code>，返回调用对象。再精简下 demo 就是：</p>\n<pre><code class=\"language-js\">var jQuery = {\n    eq: function(){\n        console.log('调用 eq 方法');\n        return this;\n    },\n    show: function(){\n        console.log('调用 show 方法');\n        return this;\n    }\n}\n\njQuery.eq().show();\n</code></pre>\n<h2>_.chain</h2>\n<p>在 underscore 中，默认不使用链式调用，但是如果你想使用链式调用，你可以通过 _.chain 函数实现：</p>\n<pre><code class=\"language-js\">_.chain([1, 2, 3, 4])\n.filter(function(num) { return num % 2 == 0; })\n.map(function(num) { return num * num })\n.value(); // [4, 16]\n</code></pre>\n<p>我们看看 _.chain 这个方法都做了什么：</p>\n<pre><code class=\"language-js\">_.chain = function (obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n};\n</code></pre>\n<p>我们以 [1, 2, 3] 为例，_.chain([1, 2, 3]) 会返回一个对象：</p>\n<pre><code class=\"language-js\">{\n    _chain: true,\n    _wrapped: [1, 2, 3]\n}\n</code></pre>\n<p>该对象的原型上有着 underscore 的各种方法，我们可以直接调用这些方法。</p>\n<p>但是问题在于原型上的这些方法并没有像 jQuery 一样，返回 this ，所以如果你调用了一次方法，就无法接着调用其他方法了……</p>\n<p>但是试想下，我们将函数的返回值作为参数再传入 <code>_.chain</code> 函数中，不就可以接着调用其他方法了？</p>\n<p>写一个精简的 Demo:</p>\n<pre><code class=\"language-js\">var _ = function(obj) {\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n};\n\n_.chain = function (obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n};\n\n_.prototype.push = function(num) {\n    this._wrapped.push(num);\n    return this._wrapped\n}\n\n_.prototype.shift = function(num) {\n    this._wrapped.shift()\n    return this._wrapped\n}\n\nvar res = _.chain([1, 2, 3]).push(4);\n// 将上一个函数的返回值，传入 _.chain，然后再继续调用其他函数\nvar res2 = _.chain(res).shift();\n\nconsole.log(res2); // [2, 3, 4]\n</code></pre>\n<p>然而这也太复杂了吧，难道 chain 这个过程不能是自动化的吗？如果我是开发者，我肯定希望直接写成：</p>\n<pre><code class=\"language-js\">_.chain([1, 2, 3]).push(4).shift()\n</code></pre>\n<p>所以我们再优化一下实现方式：</p>\n<pre><code class=\"language-js\">var _ = function(obj) {\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n};\n\nvar chainResult = function (instance, obj) {\n    return instance._chain ? _.chain(obj) : obj;\n};\n\n_.chain = function (obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n};\n\n_.prototype.push = function(num) {\n    this._wrapped.push(num);\n    return chainResult(this, this._wrapped)\n}\n\n_.prototype.shift = function() {\n    this._wrapped.shift();\n    return chainResult(this, this._wrapped)\n}\n\nvar res = _.chain([1, 2, 3]).push(4).shift();\n\nconsole.log(res._wrapped);\n</code></pre>\n<p>我们在每个函数中，都用 chainResult 将函数的返回值包裹一遍，再生成一个类似以下这种形式的对象：</p>\n<pre><code class=\"language-js\">{\n    _wrapped: some value, \n    _chain: true\n}\n</code></pre>\n<p>该对象的原型上有各种函数，而这些函数的返回值作为参数传入了 chainResult，该函数又会返回这样一个对象，函数的返回值就保存在 _wrapped 中，这样就实现了链式调用。</p>\n<p><code>_.chain</code>链式调用原理就是这样，可是这样的话，我们需要对每个函数都进行修改呀……</p>\n<p>幸运的是，在 underscore 中，所有的函数是挂载到 <code>_</code> 函数对象中的，<code>_</code>.prototype 上的函数是通过 <code>_.mixin</code> 函数将 <code>_</code> 函数对象中的所有函数复制到 <code>_.prototype</code> 中的。</p>\n<p>所以为了实现链式调用，我们还需要对上一篇<a href=\"https://github.com/mqyqingfeng/Blog/issues/56\">《underscore 系列之如何写自己的 underscore》</a> 中的 <code>_.mixin</code> 方法进行一定修改：</p>\n<pre><code class=\"language-js\">// 修改前\nvar ArrayProto = Array.prototype;\nvar push = ArrayProto.push;\n\n_.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n            var args = [this._wrapped];\n            push.apply(args, arguments);\n            return func.apply(_, args);\n        };\n    });\n    return _;\n};\n\n_.mixin(_);\n</code></pre>\n<pre><code class=\"language-js\">// 修改后\nvar ArrayProto = Array.prototype;\nvar push = ArrayProto.push;\n\nvar chainResult = function (instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n};\n\n_.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n        var func = _[name] = obj[name];\n        _.prototype[name] = function() {\n            var args = [this._wrapped];\n            push.apply(args, arguments);\n            return chainResult(this, func.apply(_, args));\n        };\n    });\n    return _;\n};\n\n_.mixin(_);\n</code></pre>\n<h2>_.value</h2>\n<p>根据上面的分析过程，我们知道如果我们打印：</p>\n<pre><code class=\"language-js\">console.log(_.chain([1, 2, 3]).push(4).shift());\n</code></pre>\n<p>其实会打印一个对象 <code>{_chain: true, _wrapped: [2, 3, 4] }</code></p>\n<p>可是我希望获得值是 [2, 3, 4] 呀！</p>\n<p>所以，我们还需要提供一个 value 方法，当执行 value 方法的时候，就返回当前 _wrapped 的值。</p>\n<pre><code class=\"language-js\">_.prototype.value = function() {\n    return this._wrapped;\n};\n</code></pre>\n<p>此时调用方式为：</p>\n<pre><code class=\"language-js\">var arr = _.chain([1, 2, 3]).push(4).shift().value();\nconsole.log(arr) // [2, 3, 4]\n</code></pre>\n<h2>最终代码</h2>\n<p>结合<a href=\"https://github.com/mqyqingfeng/Blog/issues/56\">上一篇文章</a>，最终的 underscore 代码组织结构如下：</p>\n<pre><code class=\"language-js\">(function() {\n\n    var root = (typeof self == 'object' &amp;&amp; self.self == self &amp;&amp; self) ||\n        (typeof global == 'object' &amp;&amp; global.global == global &amp;&amp; global) ||\n        this || {};\n\n    var ArrayProto = Array.prototype;\n\n    var push = ArrayProto.push;\n\n    var _ = function(obj) {\n        if (obj instanceof _) return obj;\n        if (!(this instanceof _)) return new _(obj);\n        this._wrapped = obj;\n    };\n\n    if (typeof exports != 'undefined' &amp;&amp; !exports.nodeType) {\n        if (typeof module != 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) {\n            exports = module.exports = _;\n        }\n        exports._ = _;\n    } else {\n        root._ = _;\n    }\n\n    _.VERSION = '0.2';\n\n    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n    var isArrayLike = function(collection) {\n        var length = collection.length;\n        return typeof length == 'number' &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;\n    };\n\n    _.each = function(obj, callback) {\n        var length, i = 0;\n\n        if (isArrayLike(obj)) {\n            length = obj.length;\n            for (; i &lt; length; i++) {\n                if (callback.call(obj[i], obj[i], i) === false) {\n                    break;\n                }\n            }\n        } else {\n            for (i in obj) {\n                if (callback.call(obj[i], obj[i], i) === false) {\n                    break;\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    _.isFunction = function(obj) {\n        return typeof obj == 'function' || false;\n    };\n\n    _.functions = function(obj) {\n        var names = [];\n        for (var key in obj) {\n            if (_.isFunction(obj[key])) names.push(key);\n        }\n        return names.sort();\n    };\n\n    /**\n     * 在 _.mixin(_) 前添加自己定义的方法\n     */\n    _.reverse = function(string){\n        return string.split('').reverse().join('');\n    }\n\n    _.chain = function(obj) {\n        var instance = _(obj);\n        instance._chain = true;\n        return instance;\n    };\n\n    var chainResult = function(instance, obj) {\n        return instance._chain ? _(obj).chain() : obj;\n    };\n\n    _.mixin = function(obj) {\n        _.each(_.functions(obj), function(name) {\n            var func = _[name] = obj[name];\n            _.prototype[name] = function() {\n                var args = [this._wrapped];\n                push.apply(args, arguments);\n                return chainResult(this, func.apply(_, args));\n            };\n        });\n        return _;\n    };\n\n    _.mixin(_);\n\n    _.prototype.value = function () {\n        return this._wrapped;\n    };\n\n})()\n</code></pre>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}