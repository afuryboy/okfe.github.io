{"code":0,"data":"<h2>前言</h2>\n<p>在上一篇 <a href=\"https://github.com/mqyqingfeng/Blog/issues/105\">《 ES6 系列 Babel 是如何编译 Class 的(上)》</a>，我们知道了 Babel 是如何编译 Class 的，这篇我们学习 Babel 是如何用 ES5 实现 Class 的继承。</p>\n<h2>ES5 寄生组合式继承</h2>\n<pre><code class=\"language-js\">function Parent (name) {\n    this.name = name;\n}\n\nParent.prototype.getName = function () {\n    console.log(this.name)\n}\n\nfunction Child (name, age) {\n    Parent.call(this, name);\n    this.age = age;\n}\n\nChild.prototype = Object.create(Parent.prototype);\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n</code></pre>\n<p>原型链示意图为：</p>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/ES6/class/es5-prototype.png\" alt=\"寄生组合式继承原型链示意图\"></p>\n<p>关于寄生组合式继承我们在 <a href=\"https://github.com/mqyqingfeng/Blog/issues/16\">《JavaScript深入之继承的多种方式和优缺点》</a> 中介绍过。</p>\n<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>\n<blockquote>\n<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>\n</blockquote>\n<h2>ES6 extend</h2>\n<p>Class 通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<p>以上 ES5 的代码对应到 ES6 就是：</p>\n<pre><code class=\"language-js\">class Parent {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nclass Child extends Parent {\n    constructor(name, age) {\n        super(name); // 调用父类的 constructor(name)\n        this.age = age;\n    }\n}\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n</code></pre>\n<p>值得注意的是：</p>\n<p>super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this)。</p>\n<p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。</p>\n<p>也正是因为这个原因，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。</p>\n<h2>子类的 __proto__</h2>\n<p>在 ES6 中，父类的静态方法，可以被子类继承。举个例子：</p>\n<pre><code class=\"language-js\">class Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod(); // 'hello'\n</code></pre>\n<p>这是因为 Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__ 属性，因此同时存在两条继承链。</p>\n<p>（1）子类的 __proto__ 属性，表示构造函数的继承，总是指向父类。</p>\n<p>（2）子类 prototype 属性的 __proto__ 属性，表示方法的继承，总是指向父类的 prototype 属性。</p>\n<pre><code class=\"language-js\">class Parent {\n}\n\nclass Child extends Parent {\n}\n\nconsole.log(Child.__proto__ === Parent); // true\nconsole.log(Child.prototype.__proto__ === Parent.prototype); // true\n</code></pre>\n<p>ES6 的原型链示意图为：</p>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/ES6/class/class-prototype.png\" alt=\"ES6 class 原型链示意图\"></p>\n<p>我们会发现，相比寄生组合式继承，ES6 的 class 多了一个 <code>Object.setPrototypeOf(Child, Parent)</code> 的步骤。</p>\n<h2>继承目标</h2>\n<p>extends 关键字后面可以跟多种类型的值。</p>\n<pre><code class=\"language-js\">class B extends A {\n}\n</code></pre>\n<p>上面代码的 A，只要是一个有 prototype 属性的函数，就能被 B 继承。由于函数都有 prototype 属性（除了 Function.prototype 函数），因此 A 可以是任意函数。</p>\n<p>除了函数之外，A 的值还可以是 null，当 <code>extend null</code> 的时候：</p>\n<pre><code class=\"language-js\">class A extends null {\n}\n\nconsole.log(A.__proto__ === Function.prototype); // true\nconsole.log(A.prototype.__proto__ === undefined); // true\n</code></pre>\n<h2>Babel 编译</h2>\n<p>那 ES6 的这段代码:</p>\n<pre><code class=\"language-js\">class Parent {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nclass Child extends Parent {\n    constructor(name, age) {\n        super(name); // 调用父类的 constructor(name)\n        this.age = age;\n    }\n}\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n</code></pre>\n<p>Babel 又是如何编译的呢？我们可以在 Babel 官网的<a href=\"https://babeljs.io/repl\"> Try it out </a> 中尝试：</p>\n<pre><code class=\"language-js\">'use strict';\n\nfunction _possibleConstructorReturn(self, call) {\n    if (!self) {\n        throw new ReferenceError(&quot;this hasn't been initialised - super() hasn't been called&quot;);\n    }\n    return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {\n        throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(&quot;Cannot call a class as a function&quot;);\n    }\n}\n\nvar Parent = function Parent(name) {\n    _classCallCheck(this, Parent);\n\n    this.name = name;\n};\n\nvar Child = function(_Parent) {\n    _inherits(Child, _Parent);\n\n    function Child(name, age) {\n        _classCallCheck(this, Child);\n\n        // 调用父类的 constructor(name)\n        var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name));\n\n        _this.age = age;\n        return _this;\n    }\n\n    return Child;\n}(Parent);\n\nvar child1 = new Child('kevin', '18');\n\nconsole.log(child1);\n</code></pre>\n<p>我们可以看到 Babel 创建了 _inherits 函数帮助实现继承，又创建了 _possibleConstructorReturn 函数帮助确定调用父类构造函数的返回值，我们来细致的看一看代码。</p>\n<h2>_inherits</h2>\n<pre><code class=\"language-js\">function _inherits(subClass, superClass) {\n    // extend 的继承目标必须是函数或者是 null\n    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {\n        throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass);\n    }\n\n    // 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性\n    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n\n    // 设置子类的 __proto__ 属性指向父类\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n</code></pre>\n<p>关于 Object.create()，一般我们用的时候会传入一个参数，其实是支持传入两个参数的，第二个参数表示要添加到新创建对象的属性，注意这里是给新创建的对象即返回值添加属性，而不是在新创建对象的原型对象上添加。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">// 创建一个以另一个空对象为原型,且拥有一个属性 p 的对象\nconst o = Object.create({}, { p: { value: 42 } });\nconsole.log(o); // {p: 42}\nconsole.log(o.p); // 42\n</code></pre>\n<p>再完整一点：</p>\n<pre><code class=\"language-js\">const o = Object.create({}, {\n    p: {\n        value: 42,\n        enumerable: false,\n        // 该属性不可写\n        writable: false,\n        configurable: true\n    }\n});\no.p = 24;\nconsole.log(o.p); // 42\n</code></pre>\n<p>那么对于这段代码：</p>\n<pre><code class=\"language-js\">subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n</code></pre>\n<p>作用就是给 subClass.prototype 添加一个可配置可写不可枚举的 constructor 属性，该属性值为 subClass。</p>\n<h2>_possibleConstructorReturn</h2>\n<p>函数里是这样调用的：</p>\n<pre><code class=\"language-js\">var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name));\n</code></pre>\n<p>我们简化为：</p>\n<pre><code class=\"language-js\">var _this = _possibleConstructorReturn(this, Parent.call(this, name));\n</code></pre>\n<p><code>_possibleConstructorReturn</code> 的源码为：</p>\n<pre><code class=\"language-js\">function _possibleConstructorReturn(self, call) {\n    if (!self) {\n        throw new ReferenceError(&quot;this hasn't been initialised - super() hasn't been called&quot;);\n    }\n    return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;\n}\n</code></pre>\n<p>在这里我们判断 <code>Parent.call(this, name)</code> 的返回值的类型，咦？这个值还能有很多类型？</p>\n<p>对于这样一个 class：</p>\n<pre><code class=\"language-js\">class Parent {\n    constructor() {\n        this.xxx = xxx;\n    }\n}\n</code></pre>\n<p>Parent.call(this, name) 的值肯定是 undefined。可是如果我们在 constructor 函数中 return 了呢？比如：</p>\n<pre><code class=\"language-js\">class Parent {\n    constructor() {\n        return {\n            name: 'kevin'\n        }\n    }\n}\n</code></pre>\n<p>我们可以返回各种类型的值，甚至是 null：</p>\n<pre><code class=\"language-js\">class Parent {\n    constructor() {\n        return null\n    }\n}\n</code></pre>\n<p>我们接着看这个判断：</p>\n<pre><code class=\"language-js\">call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;\n</code></pre>\n<p>注意，这句话的意思并不是判断 call 是否存在，如果存在，就执行 <code>(typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self</code></p>\n<p>因为 <code>&amp;&amp;</code> 的运算符优先级高于 <code>? :</code>，所以这句话的意思应该是：</p>\n<pre><code class=\"language-js\">(call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;)) ? call : self;\n</code></pre>\n<p>对于 Parent.call(this) 的值，如果是 object 类型或者是 function 类型，就返回 Parent.call(this)，如果是 null 或者基本类型的值或者是 undefined，都会返回 self 也就是子类的 this。</p>\n<p>这也是为什么这个函数被命名为 <code>_possibleConstructorReturn</code>。</p>\n<h2>总结</h2>\n<pre><code class=\"language-js\">var Child = function(_Parent) {\n    _inherits(Child, _Parent);\n\n    function Child(name, age) {\n        _classCallCheck(this, Child);\n\n        // 调用父类的 constructor(name)\n        var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name));\n\n        _this.age = age;\n        return _this;\n    }\n\n    return Child;\n}(Parent);\n</code></pre>\n<p>最后我们总体看下如何实现继承：</p>\n<p>首先执行 <code>_inherits(Child, Parent)</code>，建立 Child 和 Parent 的原型链关系，即 <code>Object.setPrototypeOf(Child.prototype, Parent.prototype)</code> 和 <code>Object.setPrototypeOf(Child, Parent)</code>。</p>\n<p>然后调用 <code>Parent.call(this, name)</code>，根据 Parent 构造函数的返回值类型确定子类构造函数 this 的初始值 _this。</p>\n<p>最终，根据子类构造函数，修改 _this 的值，然后返回该值。</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}