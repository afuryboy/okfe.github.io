{"code":0,"data":"<h2>需求</h2>\n<p>我们需要写一个函数，输入 'kevin'，返回 'HELLO, KEVIN'。</p>\n<h2>尝试</h2>\n<pre><code class=\"language-js\">var toUpperCase = function(x) { return x.toUpperCase(); };\nvar hello = function(x) { return 'HELLO, ' + x; };\n\nvar greet = function(x){\n    return hello(toUpperCase(x));\n};\n\ngreet('kevin');\n</code></pre>\n<p>还好我们只有两个步骤，首先小写转大写，然后拼接字符串。如果有更多的操作，greet 函数里就需要更多的嵌套，类似于 <code>fn3(fn2(fn1(fn0(x))))</code>。</p>\n<h2>优化</h2>\n<p>试想我们写个 compose 函数：</p>\n<pre><code class=\"language-js\">var compose = function(f,g) {\n    return function(x) {\n        return f(g(x));\n    };\n};\n</code></pre>\n<p>greet 函数就可以被优化为：</p>\n<pre><code class=\"language-js\">var greet = compose(hello, toUpperCase);\ngreet('kevin');\n</code></pre>\n<p>利用 compose 将两个函数组合成一个函数，让代码从右向左运行，而不是由内而外运行，可读性大大提升。这便是函数组合。</p>\n<p>但是现在的 compose 函数也只是能支持两个参数，如果有更多的步骤呢？我们岂不是要这样做：</p>\n<pre><code class=\"language-js\">compose(d, compose(c, compose(b, a)))\n</code></pre>\n<p>为什么我们不写一个帅气的 compose 函数支持传入多个函数呢？这样就变成了：</p>\n<pre><code class=\"language-js\">compose(d, c, b, a)\n</code></pre>\n<h2>compose</h2>\n<p>我们直接抄袭 underscore 的 compose 函数的实现：</p>\n<pre><code class=\"language-js\">function compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n        var i = start;\n        var result = args[start].apply(this, arguments);\n        while (i--) result = args[i].call(this, result);\n        return result;\n    };\n};\n</code></pre>\n<p>现在的 compose 函数已经可以支持多个函数了，然而有了这个又有什么用呢？</p>\n<p>在此之前，我们先了解一个概念叫做 pointfree。</p>\n<h2>pointfree</h2>\n<p>pointfree 指的是函数无须提及将要操作的数据是什么样的。依然是以最初的需求为例：</p>\n<pre><code class=\"language-js\">// 需求：输入 'kevin'，返回 'HELLO, KEVIN'。\n\n// 非 pointfree，因为提到了数据：name\nvar greet = function(name) {\n    return ('hello ' + name).toUpperCase();\n}\n\n// pointfree\n// 先定义基本运算，这些可以封装起来复用\nvar toUpperCase = function(x) { return x.toUpperCase(); };\nvar hello = function(x) { return 'HELLO, ' + x; };\n\nvar greet = compose(hello, toUpperCase);\ngreet('kevin');\n</code></pre>\n<p>我们再举个稍微复杂一点的例子，为了方便书写，我们需要借助在<a href=\"https://github.com/mqyqingfeng/Blog/issues/42\">《JavaScript专题之函数柯里化》</a>中写到的 curry 函数：</p>\n<pre><code class=\"language-js\">// 需求：输入 'kevin daisy kelly'，返回 'K.D.K'\n\n// 非 pointfree，因为提到了数据：name\nvar initials = function (name) {\n    return name.split(' ').map(compose(toUpperCase, head)).join('. ');\n};\n\n// pointfree\n// 先定义基本运算\nvar split = curry(function(separator, str) { return str.split(separator) })\nvar head = function(str) { return str.slice(0, 1) }\nvar toUpperCase = function(str) { return str.toUpperCase() }\nvar join = curry(function(separator, arr) { return arr.join(separator) })\nvar map = curry(function(fn, arr) { return arr.map(fn) })\n\nvar initials = compose(join('.'), map(compose(toUpperCase, head)), split(' '));\n\ninitials(&quot;kevin daisy kelly&quot;);\n</code></pre>\n<p>从这个例子中我们可以看到，利用柯里化（curry）和函数组合 (compose) 非常有助于实现 pointfree。</p>\n<p>也许你会想，这种写法好麻烦呐，我们还需要定义那么多的基础函数……可是如果有工具库已经帮你写好了呢？比如 <a href=\"http://ramda.cn/docs/\">ramda.js</a>：</p>\n<pre><code class=\"language-js\">// 使用 ramda.js\nvar initials = R.compose(R.join('.'), R.map(R.compose(R.toUpper, R.head)), R.split(' '));\n</code></pre>\n<p>而且你也会发现：</p>\n<blockquote>\n<p>Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。即不使用所要处理的值，只合成运算过程。</p>\n</blockquote>\n<p>那么使用 pointfree 模式究竟有什么好处呢？</p>\n<blockquote>\n<p>pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用，更符合语义，更容易复用，测试也变得轻而易举。</p>\n</blockquote>\n<h2>实战</h2>\n<p>这个例子来自于 <a href=\"http://fr.umio.us/favoring-curry/\">Favoring Curry</a>：</p>\n<p>假设我们从服务器获取这样的数据：</p>\n<pre><code class=\"language-js\">var data = {\n    result: &quot;SUCCESS&quot;,\n    tasks: [\n        {id: 104, complete: false,            priority: &quot;high&quot;,\n                  dueDate: &quot;2013-11-29&quot;,      username: &quot;Scott&quot;,\n                  title: &quot;Do something&quot;,      created: &quot;9/22/2013&quot;},\n        {id: 105, complete: false,            priority: &quot;medium&quot;,\n                  dueDate: &quot;2013-11-22&quot;,      username: &quot;Lena&quot;,\n                  title: &quot;Do something else&quot;, created: &quot;9/22/2013&quot;},\n        {id: 107, complete: true,             priority: &quot;high&quot;,\n                  dueDate: &quot;2013-11-22&quot;,      username: &quot;Mike&quot;,\n                  title: &quot;Fix the foo&quot;,       created: &quot;9/22/2013&quot;},\n        {id: 108, complete: false,            priority: &quot;low&quot;,\n                  dueDate: &quot;2013-11-15&quot;,      username: &quot;Punam&quot;,\n                  title: &quot;Adjust the bar&quot;,    created: &quot;9/25/2013&quot;},\n        {id: 110, complete: false,            priority: &quot;medium&quot;,\n                  dueDate: &quot;2013-11-15&quot;,      username: &quot;Scott&quot;,\n                  title: &quot;Rename everything&quot;, created: &quot;10/2/2013&quot;},\n        {id: 112, complete: true,             priority: &quot;high&quot;,\n                  dueDate: &quot;2013-11-27&quot;,      username: &quot;Lena&quot;,\n                  title: &quot;Alter all quuxes&quot;,  created: &quot;10/5/2013&quot;}\n    ]\n};\n</code></pre>\n<p>我们需要写一个名为 getIncompleteTaskSummaries 的函数，接收一个 username 作为参数，从服务器获取数据，然后筛选出这个用户的未完成的任务的 ids、priorities、titles、和 dueDate 数据，并且按照日期升序排序。</p>\n<p>以 Scott 为例，最终筛选出的数据为：</p>\n<pre><code class=\"language-js\">[\n    {id: 110, title: &quot;Rename everything&quot;, \n        dueDate: &quot;2013-11-15&quot;, priority: &quot;medium&quot;},\n    {id: 104, title: &quot;Do something&quot;, \n        dueDate: &quot;2013-11-29&quot;, priority: &quot;high&quot;}\n]\n</code></pre>\n<p>普通的方式为：</p>\n<pre><code class=\"language-js\">// 第一版 过程式编程\nvar fetchData = function() {\n    // 模拟\n    return Promise.resolve(data)\n};\n\nvar getIncompleteTaskSummaries = function(membername) {\n     return fetchData()\n         .then(function(data) {\n             return data.tasks;\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return task.username == membername\n             })\n         })\n         .then(function(tasks) {\n             return tasks.filter(function(task) {\n                 return !task.complete\n             })\n         })\n         .then(function(tasks) {\n             return tasks.map(function(task) {\n                 return {\n                     id: task.id,\n                     dueDate: task.dueDate,\n                     title: task.title,\n                     priority: task.priority\n                 }\n             })\n         })\n         .then(function(tasks) {\n             return tasks.sort(function(first, second) {\n                 var a = first.dueDate,\n                     b = second.dueDate;\n                 return a &lt; b ? -1 : a &gt; b ? 1 : 0;\n             });\n         })\n         .then(function(task) {\n             console.log(task)\n         })\n};\n\ngetIncompleteTaskSummaries('Scott')\n</code></pre>\n<p>如果使用 pointfree 模式：</p>\n<pre><code class=\"language-js\">// 第二版 pointfree 改写\nvar fetchData = function() {\n    return Promise.resolve(data)\n};\n\n// 编写基本函数\nvar prop = curry(function(name, obj) {\n    return obj[name];\n});\n\nvar propEq = curry(function(name, val, obj) {\n    return obj[name] === val;\n});\n\nvar filter = curry(function(fn, arr) {\n    return arr.filter(fn)\n});\n\nvar map = curry(function(fn, arr) {\n    return arr.map(fn)\n});\n\nvar pick = curry(function(args, obj){\n    var result = {};\n    for (var i = 0; i &lt; args.length; i++) {\n        result[args[i]] = obj[args[i]]\n    }\n    return result;\n});\n\nvar sortBy = curry(function(fn, arr) {\n    return arr.sort(function(a, b){\n        var a = fn(a),\n            b = fn(b);\n        return a &lt; b ? -1 : a &gt; b ? 1 : 0;\n    })\n});\n\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(prop('tasks'))\n        .then(filter(propEq('username', membername)))\n        .then(filter(propEq('complete', false)))\n        .then(map(pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(sortBy(prop('dueDate')))\n        .then(console.log)\n};\n\ngetIncompleteTaskSummaries('Scott')\n</code></pre>\n<p>如果直接使用 ramda.js，你可以省去编写基本函数:</p>\n<pre><code class=\"language-js\">// 第三版 使用 ramda.js\nvar fetchData = function() {\n    return Promise.resolve(data)\n};\n\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.prop('tasks'))\n        .then(R.filter(R.propEq('username', membername)))\n        .then(R.filter(R.propEq('complete', false)))\n        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(R.sortBy(R.prop('dueDate')))\n        .then(console.log)\n};\n\ngetIncompleteTaskSummaries('Scott')\n</code></pre>\n<p>当然了，利用 compose，你也可以这样写：</p>\n<pre><code class=\"language-js\">// 第四版 使用 compose\nvar fetchData = function() {\n    return Promise.resolve(data)\n};\n\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.compose(\n            console.log,\n            R.sortBy(R.prop('dueDate')),\n            R.map(R.pick(['id', 'dueDate', 'title', 'priority'])\n            ),\n            R.filter(R.propEq('complete', false)),\n            R.filter(R.propEq('username', membername)),\n            R.prop('tasks'),\n        ))\n};\n\ngetIncompleteTaskSummaries('Scott')\n</code></pre>\n<p>compose 是从右到左依此执行，当然你也可以写一个从左到右的版本，但是从右向左执行更加能够反映数学上的含义。</p>\n<p>ramda.js 提供了一个 R.pipe 函数，可以做的从左到右，以上可以改写为：</p>\n<pre><code class=\"language-js\">// 第五版 使用 R.pipe\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.pipe(\n            R.prop('tasks'),\n            R.filter(R.propEq('username', membername)),\n            R.filter(R.propEq('complete', false)),\n            R.map(R.pick(['id', 'dueDate', 'title', 'priority'])\n            R.sortBy(R.prop('dueDate')),\n            console.log,\n        ))\n};\n</code></pre>\n<h2>专题系列</h2>\n<p>JavaScript专题系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}