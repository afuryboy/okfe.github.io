{"code":0,"data":"<h2>需求</h2>\n<p>我们现在需要写一个 foo 函数，这个函数返回首次调用时的 Date 对象，注意是首次。</p>\n<h2>解决一：普通方法</h2>\n<pre><code class=\"language-js\">var t;\nfunction foo() {\n    if (t) return t;\n    t = new Date()\n    return t;\n}\n</code></pre>\n<p>问题有两个，一是污染了全局变量，二是每次调用 foo 的时候都需要进行一次判断。</p>\n<h2>解决二：闭包</h2>\n<p>我们很容易想到用闭包避免污染全局变量。</p>\n<pre><code class=\"language-js\">var foo = (function() {\n    var t;\n    return function() {\n        if (t) return t;\n        t = new Date();\n        return t;\n    }\n})();\n</code></pre>\n<p>然而还是没有解决调用时都必须进行一次判断的问题。</p>\n<h2>解决三：函数对象</h2>\n<p>函数也是一种对象，利用这个特性，我们也可以解决这个问题。</p>\n<pre><code class=\"language-js\">function foo() {\n    if (foo.t) return foo.t;\n    foo.t = new Date();\n    return foo.t;\n}\n</code></pre>\n<p>依旧没有解决调用时都必须进行一次判断的问题。</p>\n<h2>解决四：惰性函数</h2>\n<p>不错，惰性函数就是解决每次都要进行判断的这个问题，解决原理很简单，重写函数。</p>\n<pre><code class=\"language-js\">var foo = function() {\n    var t = new Date();\n    foo = function() {\n        return t;\n    };\n    return foo();\n};\n</code></pre>\n<h2>更多应用</h2>\n<p>DOM 事件添加中，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断：</p>\n<pre><code class=\"language-js\">// 简化写法\nfunction addEvent (type, el, fn) {\n    if (window.addEventListener) {\n        el.addEventListener(type, fn, false);\n    }\n    else if(window.attachEvent){\n        el.attachEvent('on' + type, fn);\n    }\n}\n</code></pre>\n<p>问题在于我们每当使用一次 addEvent 时都会进行一次判断。</p>\n<p>利用惰性函数，我们可以这样做：</p>\n<pre><code class=\"language-js\">function addEvent (type, el, fn) {\n    if (window.addEventListener) {\n        addEvent = function (type, el, fn) {\n            el.addEventListener(type, fn, false);\n        }\n    }\n    else if(window.attachEvent){\n        addEvent = function (type, el, fn) {\n            el.attachEvent('on' + type, fn);\n        }\n    }\n}\n</code></pre>\n<p>当然我们也可以使用闭包的形式：</p>\n<pre><code class=\"language-js\">var addEvent = (function(){\n    if (window.addEventListener) {\n        return function (type, el, fn) {\n            el.addEventListener(type, fn, false);\n        }\n    }\n    else if(window.attachEvent){\n        return function (type, el, fn) {\n            el.attachEvent('on' + type, fn);\n        }\n    }\n})();\n</code></pre>\n<p>当我们每次都需要进行条件判断，其实只需要判断一次，接下来的使用方式都不会发生改变的时候，想想是否可以考虑使用惰性函数。</p>\n<h2>重要参考</h2>\n<p><a href=\"http://peter.michaux.ca/articles/lazy-function-definition-pattern\">Lazy Function Definition Pattern</a></p>\n<h2>专题系列</h2>\n<p>JavaScript专题系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}