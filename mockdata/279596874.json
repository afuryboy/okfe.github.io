{"code":0,"data":"<h2>partial</h2>\n<p>在<a href=\"https://github.com/mqyqingfeng/Blog/issues/43\">《 JavaScript 专题之偏函数》</a>中，我们写了一个 partial 函数，用来固定函数的部分参数，实现代码如下：</p>\n<pre><code class=\"language-js\">// 这是文章中的第一版\nfunction partial(fn) {\n    var args = [].slice.call(arguments, 1);\n    return function() {\n        var newArgs = args.concat([].slice.call(arguments));\n        return fn.apply(this, newArgs);\n    };\n};\n</code></pre>\n<h2>rest parameter</h2>\n<p>ES6 为我们提供了剩余参数（rest parameter）语法，允许我们将一个不定数量的参数表示为一个数组。</p>\n<pre><code class=\"language-js\">function fn(a, b, ...args) {\n   console.log(args); // [3, 4, 5]\n}\n\nfn(1, 2, 3, 4, 5)\n</code></pre>\n<p>我们可以利用这一特性简化 partial 实现的代码：</p>\n<pre><code class=\"language-js\">function partial(fn, ...args) {\n    return function(...partialArgs) {\n        var newArgs = args.concat(partialArgs);\n        return fn.apply(this, newArgs);\n    };\n};\n</code></pre>\n<p>写个 demo，测试一下：</p>\n<pre><code class=\"language-js\">function add(a, b) {\n    return a + b;\n}\n\nvar addOne = partial(add, 1);\n\nconsole.log(addOne(2)); // 3\n</code></pre>\n<h2>restArgs</h2>\n<p>如果不使用 ... 拓展操作符，仅用 ES5 的内容，该怎么实现呢？</p>\n<p>我们可以写一个 restArgs 函数，传入一个函数，使用函数的最后一个参数储存剩下的函数参数，使用效果如下：</p>\n<pre><code class=\"language-js\">var func = restArgs(function(a, b, c){\n    console.log(c); // [3, 4, 5]\n})\n\nfunc(1, 2, 3, 4, 5)\n</code></pre>\n<p>我们来写一版：</p>\n<pre><code class=\"language-js\">// 第一版\nfunction restArgs(func) {\n    return function(){\n        // startIndex 表示使用哪个位置的参数用于储存剩余的参数\n        var startIndex = func.length - 1;\n        var length = arguments.length - startIndex;\n\n        var rest = Array(length)\n        var index = 0;\n\n        // 使用一个数组储存剩余的参数\n        // 以上面的例子为例，结果为：\n        // rest [3, 4, 5]\n        for (; index &lt; length; index++) {\n            rest[index] = arguments[index + startIndex]\n        }\n\n        // args [1, 2, undefined]\n        var args = Array(startIndex + 1);\n        for (index = 0; index &lt; startIndex; index++) {\n            args[index] = arguments[index]\n        }\n\n        // args [1, 2, [3, 4, 5]]\n        args[startIndex] = rest;\n\n        return func.apply(this, args)\n    }\n}\n</code></pre>\n<h2>优化</h2>\n<p>我们默认使用传入的函数的最后一个参数储存剩余的参数，为了更加灵活，我们可以再增加一个参数，用来指定 startIndex，如果没有指定，就默认使用最后一个参数。</p>\n<p>此外，注意，我们使用 Array(length) 创建数组，而 length 的计算方式是 arguments.length - startIndex，这个值有可能是负数！比如：</p>\n<pre><code class=\"language-js\">var func = restArgs(function(a, b, c, d){\n    console.log(c) // 报错\n})\n\nfunc(1, 2)\n</code></pre>\n<p>所以我们再写一版：</p>\n<pre><code class=\"language-js\">// 第二版\nfunction restArgs(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function(){\n        var length = Math.max(arguments.length - startIndex, 0);\n        var rest = Array(length)\n        var index = 0;\n        for (; index &lt; length; index++) {\n            rest[index] = arguments[index + startIndex]\n        }\n\n        var args = Array(startIndex + 1);\n        for (index = 0; index &lt; startIndex; index++) {\n            args[index] = arguments[index]\n        }\n\n        args[startIndex] = rest;\n        return func.apply(this, args)\n    }\n}\n</code></pre>\n<h2>性能优化</h2>\n<p>如果是正常写业务，可能写到这里就结束了，然而 underscore 考虑的更多，鉴于 call 的性能要高于 apply，所以 underscore 做了一个优化：</p>\n<pre><code class=\"language-js\">// 第三版\nvar restArgs = function(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n        var length = Math.max(arguments.length - startIndex, 0),\n            rest = Array(length),\n            index = 0;\n\n        for (; index &lt; length; index++) {\n            rest[index] = arguments[index + startIndex];\n        }\n\n        // 增加的部分\n        switch (startIndex) {\n            case 0:\n                return func.call(this, rest);\n            case 1:\n                return func.call(this, arguments[0], rest);\n            case 2:\n                return func.call(this, arguments[0], arguments[1], rest);\n        }\n\n        var args = Array(startIndex + 1);\n        for (index = 0; index &lt; startIndex; index++) {\n            args[index] = arguments[index];\n        }\n\n        args[startIndex] = rest;\n        return func.apply(this, args);\n    };\n};\n</code></pre>\n<p>至此，restArgs 函数就完成了，underscore 很多函数比如 invoke、without、union、difference、bind、partial、bindAll、delay 都用到了 restArgs 函数。</p>\n<p>当使用 underscore 的时候，我们可以以 _.restArgs 的形式调用该函数。</p>\n<h2>restArgs 与 partial</h2>\n<p>最后，使用我们的写的 restArgs 函数重写下 partial 函数：</p>\n<pre><code class=\"language-js\">var partial = restArgs(function(fn, args){\n    return restArgs(function(partialArgs) {\n        var newArgs = args.concat(partialArgs);\n        return fn.apply(this, newArgs);\n    })\n})\n\nfunction add(a, b, c) {\n    return a + b + c;\n}\n\nvar addOne = partial(add, 1);\nconsole.log(addOne(2, 3)); // 6\n</code></pre>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}