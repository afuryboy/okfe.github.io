{"code":0,"data":"<h2>写在前面</h2>\n<p>这篇文章讲解创建对象的各种方式，以及优缺点。</p>\n<p>但是注意：</p>\n<p>这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！</p>\n<h2>1. 工厂模式</h2>\n<pre><code class=\"language-js\">function createPerson(name) {\n    var o = new Object();\n    o.name = name;\n    o.getName = function () {\n        console.log(this.name);\n    };\n\n    return o;\n}\n\nvar person1 = createPerson('kevin');\n</code></pre>\n<p>缺点：对象无法识别，因为所有的实例都指向一个原型</p>\n<h2>2. 构造函数模式</h2>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n    this.getName = function () {\n        console.log(this.name);\n    };\n}\n\nvar person1 = new Person('kevin');\n</code></pre>\n<p>优点：实例可以识别为一个特定的类型</p>\n<p>缺点：每次创建实例时，每个方法都要被创建一次</p>\n<h2>2.1 构造函数模式优化</h2>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n    this.getName = getName;\n}\n\nfunction getName() {\n    console.log(this.name);\n}\n\nvar person1 = new Person('kevin');\n</code></pre>\n<p>优点：解决了每个方法都要被重新创建的问题</p>\n<p>缺点：这叫啥封装……</p>\n<h2>3. 原型模式</h2>\n<pre><code class=\"language-js\">function Person(name) {\n\n}\n\nPerson.prototype.name = 'keivn';\nPerson.prototype.getName = function () {\n    console.log(this.name);\n};\n\nvar person1 = new Person();\n</code></pre>\n<p>优点：方法不会重新创建</p>\n<p>缺点：1. 所有的属性和方法都共享 2. 不能初始化参数</p>\n<h2>3.1 原型模式优化</h2>\n<pre><code class=\"language-js\">function Person(name) {\n\n}\n\nPerson.prototype = {\n    name: 'kevin',\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n</code></pre>\n<p>优点：封装性好了一点</p>\n<p>缺点：重写了原型，丢失了constructor属性</p>\n<h2>3.2 原型模式优化</h2>\n<pre><code class=\"language-js\">function Person(name) {\n\n}\n\nPerson.prototype = {\n    constructor: Person,\n    name: 'kevin',\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n</code></pre>\n<p>优点：实例可以通过constructor属性找到所属构造函数</p>\n<p>缺点：原型模式该有的缺点还是有</p>\n<h2>4. 组合模式</h2>\n<p>构造函数模式与原型模式双剑合璧。</p>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    getName: function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\n</code></pre>\n<p>优点：该共享的共享，该私有的私有，使用最广泛的方式</p>\n<p>缺点：有的人就是希望全部都写在一起，即更好的封装性</p>\n<h2>4.1 动态原型模式</h2>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n    if (typeof this.getName != &quot;function&quot;) {\n        Person.prototype.getName = function () {\n            console.log(this.name);\n        }\n    }\n}\n\nvar person1 = new Person();\n</code></pre>\n<p>注意：使用动态原型模式时，不能用对象字面量重写原型</p>\n<p>解释下为什么：</p>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n    if (typeof this.getName != &quot;function&quot;) {\n        Person.prototype = {\n            constructor: Person,\n            getName: function () {\n                console.log(this.name);\n            }\n        }\n    }\n}\n\nvar person1 = new Person('kevin');\nvar person2 = new Person('daisy');\n\n// 报错 并没有该方法\nperson1.getName();\n\n// 注释掉上面的代码，这句是可以执行的。\nperson2.getName();\n\n</code></pre>\n<p>为了解释这个问题，假设开始执行<code>var person1 = new Person('kevin')</code>。</p>\n<p>如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。</p>\n<p>我们回顾下 new 的实现步骤：</p>\n<ol>\n<li>首先新建一个对象</li>\n<li>然后将对象的原型指向 Person.prototype</li>\n<li>然后 Person.apply(obj)</li>\n<li>返回这个对象</li>\n</ol>\n<p>注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！</p>\n<p>如果你就是想用字面量方式写代码，可以尝试下这种：</p>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n    if (typeof this.getName != &quot;function&quot;) {\n        Person.prototype = {\n            constructor: Person,\n            getName: function () {\n                console.log(this.name);\n            }\n        }\n\n        return new Person(name);\n    }\n}\n\nvar person1 = new Person('kevin');\nvar person2 = new Person('daisy');\n\nperson1.getName(); // kevin\nperson2.getName();  // daisy\n\n</code></pre>\n<h3>5.1 寄生构造函数模式</h3>\n<pre><code class=\"language-js\">function Person(name) {\n\n    var o = new Object();\n    o.name = name;\n    o.getName = function () {\n        console.log(this.name);\n    };\n\n    return o;\n\n}\n\nvar person1 = new Person('kevin');\nconsole.log(person1 instanceof Person) // false\nconsole.log(person1 instanceof Object)  // true\n</code></pre>\n<p>寄生构造函数模式，我个人认为应该这样读：</p>\n<p>寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。</p>\n<p>也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！</p>\n<p>这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写：</p>\n<pre><code class=\"language-js\">function SpecialArray() {\n    var values = new Array();\n\n    for (var i = 0, len = arguments.length; i &lt; len; i++) {\n        values.push(arguments[i]);\n    }\n\n    values.toPipedString = function () {\n        return this.join(&quot;|&quot;);\n    };\n    return values;\n}\n\nvar colors = new SpecialArray('red', 'blue', 'green');\nvar colors2 = SpecialArray('red2', 'blue2', 'green2');\n\n\nconsole.log(colors);\nconsole.log(colors.toPipedString()); // red|blue|green\n\nconsole.log(colors2);\nconsole.log(colors2.toPipedString()); // red2|blue2|green2\n</code></pre>\n<p>你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。</p>\n<p>但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。</p>\n<p>在可以使用其他模式的情况下，不要使用这种模式。</p>\n<p>但是值得一提的是，上面例子中的循环：</p>\n<pre><code class=\"language-js\">for (var i = 0, len = arguments.length; i &lt; len; i++) {\n    values.push(arguments[i]);\n}\n</code></pre>\n<p>可以替换成：</p>\n<pre><code class=\"language-js\">values.push.apply(values, arguments);\n</code></pre>\n<h2>5.2 稳妥构造函数模式</h2>\n<pre><code class=\"language-js\">function person(name){\n    var o = new Object();\n    o.sayName = function(){\n        console.log(name);\n    };\n    return o;\n}\n\nvar person1 = person('kevin');\n\nperson1.sayName(); // kevin\n\nperson1.name = &quot;daisy&quot;;\n\nperson1.sayName(); // kevin\n\nconsole.log(person1.name); // daisy\n\n</code></pre>\n<p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。</p>\n<p>与寄生构造函数模式有两点不同：</p>\n<ol>\n<li>新创建的实例方法不引用 this</li>\n<li>不使用 new 操作符调用构造函数</li>\n</ol>\n<p>稳妥对象最适合在一些安全的环境中。</p>\n<p>稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。</p>\n<h2>下一篇文章</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/16\">JavaScript深入之继承的多种方式和优缺点</a></p>\n<h2>相关链接</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">《JavaScript深入之从原型到原型链》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/13\">《JavaScript深入之new的模拟实现》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/11\">《JavaScript深入之call和apply的模拟实现》</a></p>\n<h2>深入系列</h2>\n<p>JavaScript深入系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}