{"code":0,"data":"<h2>前言</h2>\n<ol>\n<li>这里的 &quot;ES6&quot; 泛指 ES5 之后的新语法</li>\n<li>这里的 &quot;完全&quot; 是指本文会不断更新</li>\n<li>这里的 &quot;使用&quot; 是指本文会展示很多 ES6 的使用场景</li>\n<li>这里的 &quot;手册&quot; 是指你可以参照本文将项目更多的重构为 ES6 语法</li>\n</ol>\n<p>此外还要注意这里不一定就是正式进入规范的语法。</p>\n<h2>1. let 和 const</h2>\n<p>在我们开发的时候，可能认为应该默认使用 let 而不是 var，这种情况下，对于需要写保护的变量要使用 const。</p>\n<p>然而另一种做法日益普及：默认使用 const，只有当确实需要改变变量的值的时候才使用 let。这是因为大部分的变量的值在初始化后不应再改变，而预料之外的变量的修改是很多 bug 的源头。</p>\n<pre><code class=\"language-js\">// 例子 1-1\n\n// bad\nvar foo = 'bar';\n\n// good\nlet foo = 'bar';\n\n// better\nconst foo = 'bar';\n</code></pre>\n<h2>2. 模板字符串</h2>\n<h3>1. 模板字符串</h3>\n<p>需要拼接字符串的时候尽量改成使用模板字符串:</p>\n<pre><code class=\"language-js\">// 例子 2-1\n\n// bad\nconst foo = 'this is a' + example;\n\n// good\nconst foo = `this is a ${example}`;\n</code></pre>\n<h3>2. 标签模板</h3>\n<p>可以借助标签模板优化书写方式:</p>\n<pre><code class=\"language-js\">// 例子 2-2\n\nlet url = oneLine `\n    www.taobao.com/example/index.html\n    ?foo=${foo}\n    &amp;bar=${bar}\n`;\n\nconsole.log(url); // www.taobao.com/example/index.html?foo=foo&amp;bar=bar\n</code></pre>\n<p>oneLine 的源码可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/issues/84\">《ES6 系列之模板字符串》</a></p>\n<h2>3. 箭头函数</h2>\n<p>优先使用箭头函数，不过以下几种情况避免使用：</p>\n<h3>1. 使用箭头函数定义对象的方法</h3>\n<pre><code class=\"language-js\">// 例子 3-1\n\n// bad\nlet foo = {\n  value: 1,\n  getValue: () =&gt; console.log(this.value)\n}\n\nfoo.getValue();  // undefined\n</code></pre>\n<h3>2. 定义原型方法</h3>\n<pre><code class=\"language-js\">// 例子 3-2\n\n// bad\nfunction Foo() {\n  this.value = 1\n}\n\nFoo.prototype.getValue = () =&gt; console.log(this.value)\n\nlet foo = new Foo()\nfoo.getValue();  // undefined\n</code></pre>\n<h3>3. 作为事件的回调函数</h3>\n<pre><code class=\"language-js\">// 例子 3-3\n\n// bad\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', () =&gt; {\n    console.log(this === window); // =&gt; true\n    this.innerHTML = 'Clicked button';\n});\n</code></pre>\n<h2>4. Symbol</h2>\n<h3>1. 唯一值</h3>\n<pre><code class=\"language-js\">// 例子 4-1\n\n\n// bad\n// 1. 创建的属性会被 for-in 或 Object.keys() 枚举出来\n// 2. 一些库可能在将来会使用同样的方式，这会与你的代码发生冲突\nif (element.isMoving) {\n  smoothAnimations(element);\n}\nelement.isMoving = true;\n\n// good\nif (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {\n  smoothAnimations(element);\n}\nelement.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;\n\n// better\nvar isMoving = Symbol(&quot;isMoving&quot;);\n\n...\n\nif (element[isMoving]) {\n  smoothAnimations(element);\n}\nelement[isMoving] = true;\n</code></pre>\n<h3>2. 魔术字符串</h3>\n<p>魔术字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。</p>\n<p>魔术字符串不利于修改和维护，风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>\n<pre><code class=\"language-js\">// 例子 4-1\n\n// bad\nconst TYPE_AUDIO = 'AUDIO'\nconst TYPE_VIDEO = 'VIDEO'\nconst TYPE_IMAGE = 'IMAGE'\n\n// good\nconst TYPE_AUDIO = Symbol()\nconst TYPE_VIDEO = Symbol()\nconst TYPE_IMAGE = Symbol()\n\nfunction handleFileResource(resource) {\n  switch(resource.type) {\n    case TYPE_AUDIO:\n      playAudio(resource)\n      break\n    case TYPE_VIDEO:\n      playVideo(resource)\n      break\n    case TYPE_IMAGE:\n      previewImage(resource)\n      break\n    default:\n      throw new Error('Unknown type of resource')\n  }\n}\n</code></pre>\n<h3>3. 私有变量</h3>\n<p>Symbol 也可以用于私有变量的实现。</p>\n<pre><code class=\"language-js\">// 例子 4-3\n\nconst Example = (function() {\n    var _private = Symbol('private');\n\n    class Example {\n        constructor() {\n          this[_private] = 'private';\n        }\n        getName() {\n          return this[_private];\n        }\n    }\n\n    return Example;\n})();\n\nvar ex = new Example();\n\nconsole.log(ex.getName()); // private\nconsole.log(ex.name); // undefined\n</code></pre>\n<h2>5. Set 和 Map</h2>\n<h3>1. 数组去重</h3>\n<pre><code class=\"language-js\">// 例子 5-1\n\n[...new Set(array)]\n</code></pre>\n<h3>2. 条件语句的优化</h3>\n<pre><code class=\"language-js\">// 例子 5-2\n// 根据颜色找出对应的水果\n\n// bad\nfunction test(color) {\n  switch (color) {\n    case 'red':\n      return ['apple', 'strawberry'];\n    case 'yellow':\n      return ['banana', 'pineapple'];\n    case 'purple':\n      return ['grape', 'plum'];\n    default:\n      return [];\n  }\n}\n\ntest('yellow'); // ['banana', 'pineapple']\n</code></pre>\n<pre><code class=\"language-js\">// good\nconst fruitColor = {\n  red: ['apple', 'strawberry'],\n  yellow: ['banana', 'pineapple'],\n  purple: ['grape', 'plum']\n};\n\nfunction test(color) {\n  return fruitColor[color] || [];\n}\n</code></pre>\n<pre><code class=\"language-js\">// better\nconst fruitColor = new Map()\n  .set('red', ['apple', 'strawberry'])\n  .set('yellow', ['banana', 'pineapple'])\n  .set('purple', ['grape', 'plum']);\n\nfunction test(color) {\n  return fruitColor.get(color) || [];\n}\n</code></pre>\n<h2>6. for of</h2>\n<h3>1. 遍历范围</h3>\n<p>for...of 循环可以使用的范围包括：</p>\n<ol>\n<li>数组</li>\n<li>Set</li>\n<li>Map</li>\n<li>类数组对象，如 arguments 对象、DOM NodeList 对象</li>\n<li>Generator 对象</li>\n<li>字符串</li>\n</ol>\n<h3>2. 优势</h3>\n<p>ES2015 引入了 for..of 循环，它结合了 forEach 的简洁性和中断循环的能力：</p>\n<pre><code class=\"language-js\">// 例子 6-1\n\nfor (const v of ['a', 'b', 'c']) {\n  console.log(v);\n}\n// a b c\n\nfor (const [i, v] of ['a', 'b', 'c'].entries()) {\n  console.log(i, v);\n}\n// 0 &quot;a&quot;\n// 1 &quot;b&quot;\n// 2 &quot;c&quot;\n</code></pre>\n<h3>3. 遍历 Map</h3>\n<pre><code class=\"language-js\">// 例子 6-2\n\nlet map = new Map(arr);\n\n// 遍历 key 值\nfor (let key of map.keys()) {\n  console.log(key);\n}\n\n// 遍历 value 值\nfor (let value of map.values()) {\n  console.log(value);\n}\n\n// 遍历 key 和 value 值(一)\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n\n// 遍历 key 和 value 值(二)\nfor (let [key, value] of data) {\n  console.log(key)\n}\n</code></pre>\n<h2>7. Promise</h2>\n<h3>1. 基本示例</h3>\n<pre><code class=\"language-js\">// 例子 7-1\n\n// bad\nrequest(url, function(err, res, body) {\n    if (err) handleError(err);\n    fs.writeFile('1.txt', body, function(err) {\n        request(url2, function(err, res, body) {\n            if (err) handleError(err)\n        })\n    })\n});\n\n// good\nrequest(url)\n.then(function(result) {\n    return writeFileAsynv('1.txt', result)\n})\n.then(function(result) {\n    return request(url2)\n})\n.catch(function(e){\n    handleError(e)\n});\n</code></pre>\n<h3>2. finally</h3>\n<pre><code class=\"language-js\">// 例子 7-2\n\nfetch('file.json')\n.then(data =&gt; data.json())\n.catch(error =&gt; console.error(error))\n.finally(() =&gt; console.log('finished'));\n</code></pre>\n<h2>8. Async</h2>\n<h3>1. 代码更加简洁</h3>\n<pre><code class=\"language-js\">// 例子 8-1\n\n// good\nfunction fetch() {\n  return (\n    fetchData()\n    .then(() =&gt; {\n      return &quot;done&quot;\n    });\n  )\n}\n\n// better\nasync function fetch() {\n  await fetchData()\n  return &quot;done&quot;\n};\n</code></pre>\n<pre><code class=\"language-js\">// 例子 8-2\n\n// good\nfunction fetch() {\n  return fetchData()\n  .then(data =&gt; {\n    if (data.moreData) {\n        return fetchAnotherData(data)\n        .then(moreData =&gt; {\n          return moreData\n        })\n    } else {\n      return data\n    }\n  });\n}\n\n// better\nasync function fetch() {\n  const data = await fetchData()\n  if (data.moreData) {\n    const moreData = await fetchAnotherData(data);\n    return moreData\n  } else {\n    return data\n  }\n};\n</code></pre>\n<pre><code class=\"language-js\">// 例子 8-3\n\n// good\nfunction fetch() {\n  return (\n    fetchData()\n    .then(value1 =&gt; {\n      return fetchMoreData(value1)\n    })\n    .then(value2 =&gt; {\n      return fetchMoreData2(value2)\n    })\n  )\n}\n\n// better\nasync function fetch() {\n  const value1 = await fetchData()\n  const value2 = await fetchMoreData(value1)\n  return fetchMoreData2(value2)\n};\n</code></pre>\n<h3>2. 错误处理</h3>\n<pre><code class=\"language-js\">// 例子 8-4\n\n// good\nfunction fetch() {\n  try {\n    fetchData()\n      .then(result =&gt; {\n        const data = JSON.parse(result)\n      })\n      .catch((err) =&gt; {\n        console.log(err)\n      })\n  } catch (err) {\n    console.log(err)\n  }\n}\n\n// better\nasync function fetch() {\n  try {\n    const data = JSON.parse(await fetchData())\n  } catch (err) {\n    console.log(err)\n  }\n};\n</code></pre>\n<h3>3. &quot;async 地狱&quot;</h3>\n<pre><code class=\"language-js\">// 例子 8-5\n\n// bad\n(async () =&gt; {\n  const getList = await getList();\n  const getAnotherList = await getAnotherList();\n})();\n\n// good\n(async () =&gt; {\n  const listPromise = getList();\n  const anotherListPromise = getAnotherList();\n  await listPromise;\n  await anotherListPromise;\n})();\n\n// good\n(async () =&gt; {\n  Promise.all([getList(), getAnotherList()]).then(...);\n})();\n</code></pre>\n<h2>9. Class</h2>\n<p>构造函数尽可能使用 Class 的形式</p>\n<pre><code class=\"language-js\">// 例子 9-1\n\nclass Foo {\n  static bar () {\n    this.baz();\n  }\n  static baz () {\n    console.log('hello');\n  }\n  baz () {\n    console.log('world');\n  }\n}\n\nFoo.bar(); // hello\n</code></pre>\n<pre><code class=\"language-js\">// 例子 9-2\n\nclass Shape {\n  constructor(width, height) {\n    this._width = width;\n    this._height = height;\n  }\n  get area() {\n    return this._width * this._height;\n  }\n}\n\nconst square = new Shape(10, 10);\nconsole.log(square.area);    // 100\nconsole.log(square._width);  // 10\n</code></pre>\n<h2>10.Decorator</h2>\n<h3>1. log</h3>\n<pre><code class=\"language-js\">// 例子 10-1\n\nclass Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n</code></pre>\n<p>log 的实现可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/issues/109\">《ES6 系列之我们来聊聊装饰器》</a></p>\n<h3>2. autobind</h3>\n<pre><code class=\"language-jsx\">// 例子 10-2\n\nclass Toggle extends React.Component {\n\n  @autobind\n  handleClick() {\n    console.log(this)\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        button\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<p>autobind 的实现可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/issues/109\">《ES6 系列之我们来聊聊装饰器》</a></p>\n<h3>3. debounce</h3>\n<pre><code class=\"language-jsx\">// 例子 10-3\n\nclass Toggle extends React.Component {\n\n  @debounce(500, true)\n  handleClick() {\n    console.log('toggle')\n  }\n\n  render() {\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        button\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<p>debounce 的实现可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/issues/109\">《ES6 系列之我们来聊聊装饰器》</a></p>\n<h3>4. React 与 Redux</h3>\n<pre><code class=\"language-js\">// 例子 10-4\n\n// good\nclass MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n\n// better\n@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {};\n</code></pre>\n<h2>11. 函数</h2>\n<h3>1. 默认值</h3>\n<pre><code class=\"language-js\">// 例子 11-1\n\n// bad\nfunction test(quantity) {\n  const q = quantity || 1;\n}\n\n// good\nfunction test(quantity = 1) {\n  ...\n}\n\n</code></pre>\n<pre><code class=\"language-js\">// 例子 11-2\n\ndoSomething({ foo: 'Hello', bar: 'Hey!', baz: 42 });\n\n// bad\nfunction doSomething(config) {\n  const foo = config.foo !== undefined ? config.foo : 'Hi';\n  const bar = config.bar !== undefined ? config.bar : 'Yo!';\n  const baz = config.baz !== undefined ? config.baz : 13;\n}\n\n// good\nfunction doSomething({ foo = 'Hi', bar = 'Yo!', baz = 13 }) {\n  ...\n}\n\n// better\nfunction doSomething({ foo = 'Hi', bar = 'Yo!', baz = 13 } = {}) {\n  ...\n}\n</code></pre>\n<pre><code class=\"language-jsx\">// 例子 11-3\n\n// bad\nconst Button = ({className}) =&gt; {\n\tconst classname = className || 'default-size';\n\treturn &lt;span className={classname}&gt;&lt;/span&gt;\n};\n\n// good\nconst Button = ({className = 'default-size'}) =&gt; (\n\t&lt;span className={classname}&gt;&lt;/span&gt;\n);\n\n// better\nconst Button = ({className}) =&gt;\n\t&lt;span className={className}&gt;&lt;/span&gt;\n}\n\nButton.defaultProps = {\n\tclassName: 'default-size'\n}\n</code></pre>\n<pre><code class=\"language-js\">// 例子 11-4\n\nconst required = () =&gt; {throw new Error('Missing parameter')};\n\nconst add = (a = required(), b = required()) =&gt; a + b;\n\nadd(1, 2) // 3\nadd(1); // Error: Missing parameter.\n</code></pre>\n<h2>12. 拓展运算符</h2>\n<h3>1. arguments 转数组</h3>\n<pre><code class=\"language-js\">// 例子 12-1\n\n// bad\nfunction sortNumbers() {\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// good\nconst sortNumbers = (...numbers) =&gt; numbers.sort();\n</code></pre>\n<h3>2. 调用参数</h3>\n<pre><code class=\"language-js\">// 例子 12-2\n\n// bad\nMath.max.apply(null, [14, 3, 77])\n\n// good\nMath.max(...[14, 3, 77])\n// 等同于\nMath.max(14, 3, 77);\n</code></pre>\n<h3>3. 构建对象</h3>\n<p>剔除部分属性，将剩下的属性构建一个新的对象</p>\n<pre><code class=\"language-js\">// 例子 12-3\nlet [a, b, ...arr] = [1, 2, 3, 4, 5];\n\nconst { a, b, ...others } = { a: 1, b: 2, c: 3, d: 4, e: 5 };\n</code></pre>\n<p>有条件的构建对象</p>\n<pre><code class=\"language-js\">// 例子 12-4\n\n// bad\nfunction pick(data) {\n  const { id, name, age} = data\n\n  const res = { guid: id }\n\n  if (name) {\n    res.name = name\n  }\n  else if (age) {\n    res.age = age\n  }\n\n  return res\n}\n\n// good\nfunction pick({id, name, age}) {\n  return {\n    guid: id,\n    ...(name &amp;&amp; {name}),\n    ...(age &amp;&amp; {age})\n  }\n}\n</code></pre>\n<p>合并对象</p>\n<pre><code class=\"language-js\">// 例子 12-5\n\nlet obj1 = { a: 1, b: 2,c: 3 }\nlet obj2 = { b: 4, c: 5, d: 6}\nlet merged = {...obj1, ...obj2};\n</code></pre>\n<h3>4. React</h3>\n<p>将对象全部传入组件</p>\n<pre><code class=\"language-jsx\">// 例子 12-6\n\nconst parmas =  {value1: 1, value2: 2, value3: 3}\n\n&lt;Test {...parmas} /&gt;\n</code></pre>\n<h3>13. 双冒号运算符</h3>\n<pre><code class=\"language-js\">// 例子 13-1\n\nfoo::bar;\n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);\n// 等同于\nbar.apply(foo, arguments);\n</code></pre>\n<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>\n<pre><code class=\"language-js\">// 例子 13-2\n\nvar method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n\nlet log = ::console.log;\n// 等同于\nvar log = console.log.bind(console);\n</code></pre>\n<h2>14. 解构赋值</h2>\n<h3>1. 对象的基本解构</h3>\n<pre><code class=\"language-jsx\">// 例子 14-1\n\ncomponentWillReceiveProps(newProps) {\n\tthis.setState({\n\t\tactive: newProps.active\n\t})\n}\n\ncomponentWillReceiveProps({active}) {\n\tthis.setState({active})\n}\n</code></pre>\n<pre><code class=\"language-js\">// 例子 14-2\n\n// bad\nhandleEvent = () =&gt; {\n  this.setState({\n    data: this.state.data.set(&quot;key&quot;, &quot;value&quot;)\n  })\n};\n\n// good\nhandleEvent = () =&gt; {\n  this.setState(({data}) =&gt; ({\n    data: data.set(&quot;key&quot;, &quot;value&quot;)\n  }))\n};\n</code></pre>\n<pre><code class=\"language-js\">// 例子 14-3\n\nPromise.all([Promise.resolve(1), Promise.resolve(2)])\n.then(([x, y]) =&gt; {\n    console.log(x, y);\n});\n</code></pre>\n<h3>2. 对象深度解构</h3>\n<pre><code class=\"language-js\">// 例子 14-4\n\n// bad\nfunction test(fruit) {\n  if (fruit &amp;&amp; fruit.name)  {\n    console.log (fruit.name);\n  } else {\n    console.log('unknown');\n  }\n}\n\n// good\nfunction test({name} = {}) {\n  console.log (name || 'unknown');\n}\n</code></pre>\n<pre><code class=\"language-js\">// 例子 14-5\n\nlet obj = {\n    a: {\n      b: {\n        c: 1\n      }\n    }\n};\n\nconst {a: {b: {c = ''} = ''} = ''} = obj;\n</code></pre>\n<h3>3. 数组解构</h3>\n<pre><code class=\"language-js\">// 例子 14-6\n\n// bad\nconst splitLocale = locale.split(&quot;-&quot;);\nconst language = splitLocale[0];\nconst country = splitLocale[1];\n\n// good\nconst [language, country] = locale.split('-');\n</code></pre>\n<h3>4. 变量重命名</h3>\n<pre><code class=\"language-js\">// 例子 14-8\n\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nconsole.log(baz); // &quot;aaa&quot;\n</code></pre>\n<h3>5. 仅获取部分属性</h3>\n<pre><code class=\"language-js\">// 例子 14-9\n\nfunction test(input) {\n  return [left, right, top, bottom];\n}\nconst [left, __, top] = test(input);\n\nfunction test(input) {\n  return { left, right, top, bottom };\n}\nconst { left, right } = test(input);\n</code></pre>\n<h2>15. 增强的对象字面量</h2>\n<pre><code class=\"language-js\">// 例子 15-1\n\n// bad\nconst something = 'y'\nconst x = {\n  something: something\n}\n\n// good\nconst something = 'y'\nconst x = {\n  something\n};\n</code></pre>\n<p>动态属性</p>\n<pre><code class=\"language-js\">// 例子 15-2\n\nconst x = {\n  ['a' + '_' + 'b']: 'z'\n}\n\nconsole.log(x.a_b); // z\n</code></pre>\n<h2>16. 数组的拓展方法</h2>\n<h3>1. keys</h3>\n<pre><code class=\"language-js\">// 例子 16-1\n\nvar arr = [&quot;a&quot;, , &quot;c&quot;];\n\nvar sparseKeys = Object.keys(arr);\nconsole.log(sparseKeys); // ['0', '2']\n\nvar denseKeys = [...arr.keys()];\nconsole.log(denseKeys);  // [0, 1, 2]\n</code></pre>\n<h3>2. entries</h3>\n<pre><code class=\"language-js\">// 例子 16-2\n\nvar arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\nvar iterator = arr.entries();\n\nfor (let e of iterator) {\n    console.log(e);\n}\n</code></pre>\n<h3>3. values</h3>\n<pre><code class=\"language-js\">// 例子 16-3\n\nlet arr = ['w', 'y', 'k', 'o', 'p'];\nlet eArr = arr.values();\n\nfor (let letter of eArr) {\n  console.log(letter);\n}\n</code></pre>\n<h3>4. includes</h3>\n<pre><code class=\"language-js\">// 例子 16-4\n\n// bad\nfunction test(fruit) {\n  if (fruit == 'apple' || fruit == 'strawberry') {\n    console.log('red');\n  }\n}\n\n// good\nfunction test(fruit) {\n  const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries'];\n  if (redFruits.includes(fruit)) {\n    console.log('red');\n  }\n}\n</code></pre>\n<h3>5. find</h3>\n<pre><code class=\"language-js\">// 例子 16-5\n\nvar inventory = [\n    {name: 'apples', quantity: 2},\n    {name: 'bananas', quantity: 0},\n    {name: 'cherries', quantity: 5}\n];\n\nfunction findCherries(fruit) {\n    return fruit.name === 'cherries';\n}\n\nconsole.log(inventory.find(findCherries)); // { name: 'cherries', quantity: 5 }\n</code></pre>\n<h3>6. findIndex</h3>\n<pre><code class=\"language-js\">// 例子 16-6\n\nfunction isPrime(element, index, array) {\n  var start = 2;\n  while (start &lt;= Math.sqrt(element)) {\n    if (element % start++ &lt; 1) {\n      return false;\n    }\n  }\n  return element &gt; 1;\n}\n\nconsole.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not found\nconsole.log([4, 6, 7, 12].findIndex(isPrime)); // 2\n</code></pre>\n<p>更多的就不列举了。</p>\n<h2>17. <a href=\"https://github.com/tc39/proposal-optional-chaining\">optional-chaining</a></h2>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">// 例子 17-1\n\nconst obj = {\n  foo: {\n    bar: {\n      baz: 42,\n    },\n  },\n};\n\nconst baz = obj?.foo?.bar?.baz; // 42\n</code></pre>\n<p>同样支持函数：</p>\n<pre><code class=\"language-js\">// 例子 17-2\n\nfunction test() {\n  return 42;\n}\ntest?.(); // 42\n\nexists?.(); // undefined\n</code></pre>\n<p>需要添加 <a href=\"https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining#example\">@babel/plugin-proposal-optional-chaining</a> 插件支持</p>\n<h2>18. logical-assignment-operators</h2>\n<pre><code class=\"language-js\">// 例子 18-1\n\na ||= b;\n\nobj.a.b ||= c;\n\na &amp;&amp;= b;\n\nobj.a.b &amp;&amp;= c;\n</code></pre>\n<p>Babel 编译为：</p>\n<pre><code class=\"language-js\">var _obj$a, _obj$a2;\n\na || (a = b);\n\n(_obj$a = obj.a).b || (_obj$a.b = c);\n\na &amp;&amp; (a = b);\n\n(_obj$a2 = obj.a).b &amp;&amp; (_obj$a2.b = c);\n</code></pre>\n<p>出现的原因：</p>\n<pre><code class=\"language-js\">// 例子 18-2\n\nfunction example(a = b) {\n  // a 必须是 undefined\n  if (!a) {\n    a = b;\n  }\n}\n\nfunction numeric(a = b) {\n  // a 必须是 null 或者 undefined\n  if (a == null) {\n    a = b;\n  }\n}\n\n// a 可以是任何 falsy 的值\nfunction example(a = b) {\n  // 可以，但是一定会触发 setter\n  a = a || b;\n\n  // 不会触发 setter，但可能会导致 lint error\n  a || (a = b);\n\n  // 就有人提出了这种写法：\n  a ||= b;\n}\n</code></pre>\n<p>需要 <a href=\"https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators\">@babel/plugin-proposal-logical-assignment-operators</a> 插件支持</p>\n<h2>19. nullish-coalescing-operator</h2>\n<pre><code class=\"language-jsx\">a ?? b\n\n// 相当于\n\n(a !== null &amp;&amp; a !== void 0) ? a : b\n</code></pre>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">var foo = object.foo ?? &quot;default&quot;;\n\n// 相当于\n\nvar foo = (object.foo != null) ? object.foo : &quot;default&quot;;\n</code></pre>\n<p>需要 <a href=\"https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator\">@babel/plugin-proposal-nullish-coalescing-operator</a> 插件支持</p>\n<h2>20. pipeline-operator</h2>\n<pre><code class=\"language-js\">const double = (n) =&gt; n * 2;\nconst increment = (n) =&gt; n + 1;\n\n// 没有用管道操作符\ndouble(increment(double(5))); // 22\n\n// 用上管道操作符之后\n5 |&gt; double |&gt; increment |&gt; double; // 22\n</code></pre>\n<h2>其他</h2>\n<p>新开了 <a href=\"https://zhuanlan.zhihu.com/c_1042806379215601664\">知乎专栏</a>，大家可以在更多的平台上看到我的文章，欢迎关注哦~</p>\n<h2>参考</h2>\n<ol start=\"2\">\n<li><a href=\"https://juejin.im/post/5934ff6d2f301e005861422f\">ES6 实践规范</a></li>\n<li><a href=\"https://juejin.im/post/5b87cab1e51d4538ac05dc54\">babel 7 简单升级指南</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NAbvosbJ4utOgFaM-6wO4Q?\">不得不知的 ES6 小技巧</a></li>\n<li><a href=\"http://bubkoo.com/2015/07/24/es6-in-depth-symbols/\">深入解析 ES6：Symbol</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26540168\">什么时候你不能使用箭头函数？</a></li>\n<li><a href=\"https://www.css88.com/archives/9868\">一些使 JavaScript 更加简洁的小技巧</a></li>\n<li><a href=\"https://www.css88.com/archives/9916\">几分钟内提升技能的 8 个 JavaScript 方法</a></li>\n<li><a href=\"https://juejin.im/post/5bb47db76fb9a05d071953ea\">[译] 如何使用 JavaScript ES6 有条件地构造对象</a></li>\n<li><a href=\"https://www.css88.com/archives/9865\">5 个技巧让你更好的编写 JavaScript(ES6) 中条件语句</a></li>\n<li><a href=\"https://www.css88.com/archives/9958\">ES6 带来的重大特性 – JavaScript 完全手册（2018版）</a></li>\n</ol>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}