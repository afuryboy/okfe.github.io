{"code":0,"data":"<h2>前言</h2>\n<p>本篇我们重点介绍以下四种模块加载规范：</p>\n<ol>\n<li>AMD</li>\n<li>CMD</li>\n<li>CommonJS</li>\n<li>ES6 模块</li>\n</ol>\n<p>最后再延伸讲下 Babel 的编译和 webpack 的打包原理。</p>\n<h2>require.js</h2>\n<p>在了解 AMD 规范之前，我们先来看看 require.js 的使用方式。</p>\n<p>项目目录为：</p>\n<pre><code>* project/\n    * index.html\n    * vender/\n        * main.js\n        * require.js\n        * add.js\n        * square.js\n        * multiply.js\n</code></pre>\n<p><code>index.html</code> 的内容如下：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;require.js&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Content&lt;/h1&gt;\n        &lt;script data-main=&quot;vender/main&quot; src=&quot;vender/require.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><code>data-main=&quot;vender/main&quot;</code> 表示主模块是 <code>vender</code> 下的 <code>main.js</code>。</p>\n<p><code>main.js</code> 的配置如下：</p>\n<pre><code class=\"language-js\">// main.js\nrequire(['./add', './square'], function(addModule, squareModule) {\n    console.log(addModule.add(1, 1))\n    console.log(squareModule.square(3))\n});\n</code></pre>\n<p>require 的第一个参数表示依赖的模块的路径，第二个参数表示此模块的内容。</p>\n<p>由此可以看出，<code>主模块</code>依赖 <code>add 模块</code>和 <code>square 模块</code>。</p>\n<p>我们看下 <code>add 模块</code>即 <code>add.js</code> 的内容：</p>\n<pre><code class=\"language-js\">// add.js\ndefine(function() {\n    console.log('加载了 add 模块');\n    var add = function(x, y) {　\n        return x + y;\n    };\n\n    return {　　　　　　\n        add: add\n    };\n});\n</code></pre>\n<p><code>requirejs</code> 为全局添加了 <code>define</code> 函数，你只要按照这种约定的方式书写这个模块即可。</p>\n<p>那如果依赖的模块又依赖了其他模块呢？</p>\n<p>我们来看看<code>主模块</code>依赖的 <code>square 模块</code>， <code>square 模块</code>的作用是求出一个数字的平方，比如输入 3 就返回 9，该模块依赖一个<code>乘法模块</code>，该乘法模块即 <code>multiply.js</code> 的代码如下：</p>\n<pre><code class=\"language-js\">// multiply.js\ndefine(function() {\n    console.log('加载了 multiply 模块')\n    var multiply = function(x, y) {　\n        return x * y;\n    };\n\n    return {　　　　　　\n        multiply: multiply\n    };\n});\n</code></pre>\n<p>而 <code>square 模块</code>就要用到 <code>multiply 模块</code>，其实写法跟 main.js 添加依赖模块一样：</p>\n<pre><code class=\"language-js\">// square.js\ndefine(['./multiply'], function(multiplyModule) {\n    console.log('加载了 square 模块')\n    return {　　　　　　\n        square: function(num) {\n            return multiplyModule.multiply(num, num)\n        }\n    };\n});\n</code></pre>\n<p>require.js 会自动分析依赖关系，将需要加载的模块正确加载。</p>\n<p>requirejs 项目 Demo 地址：<a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/requirejs\">https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/requirejs</a></p>\n<p>而如果我们在浏览器中打开 <code>index.html</code>，打印的顺序为：</p>\n<pre><code class=\"language-js\">加载了 add 模块\n加载了 multiply 模块\n加载了 square 模块\n2\n9\n</code></pre>\n<h2>AMD</h2>\n<p>在上节，我们说了这样一句话：</p>\n<blockquote>\n<p><code>requirejs</code> 为全局添加了 <code>define</code> 函数，你只要按照这种约定的方式书写这个模块即可。</p>\n</blockquote>\n<p>那这个约定的书写方式是指什么呢？</p>\n<p>指的便是 The Asynchronous Module Definition (AMD) 规范。</p>\n<p>所以其实 <strong>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</strong></p>\n<p>你去看 <a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)\">AMD 规范</a> 的内容，其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析。</p>\n<h2>sea.js</h2>\n<p>在国内，经常与 AMD 被一起提起的还有 CMD，CMD 又是什么呢？我们从 <code>sea.js</code> 的使用开始说起。</p>\n<p>文件目录与 requirejs 项目目录相同:</p>\n<pre><code>* project/\n    * index.html\n    * vender/\n        * main.js\n        * require.js\n        * add.js\n        * square.js\n        * multiply.js\n</code></pre>\n<p><code>index.html</code> 的内容如下：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;sea.js&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Content&lt;/h1&gt;\n    &lt;script src=&quot;vender/sea.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n    // 在页面中加载主模块\n    seajs.use(&quot;./vender/main&quot;);\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<p>main.js 的内容如下：</p>\n<pre><code class=\"language-js\">// main.js\ndefine(function(require, exports, module) {\n    var addModule = require('./add');\n    console.log(addModule.add(1, 1))\n\n    var squareModule = require('./square');\n    console.log(squareModule.square(3))\n});\n</code></pre>\n<p>add.js 的内容如下：</p>\n<pre><code class=\"language-js\">// add.js\ndefine(function(require, exports, module) {\n    console.log('加载了 add 模块')\n    var add = function(x, y) {　\n        return x + y;\n    };\n    module.exports = {　　　　　　\n        add: add\n    };\n});\n</code></pre>\n<p>square.js 的内容如下：</p>\n<pre><code class=\"language-js\">define(function(require, exports, module) {\n    console.log('加载了 square 模块')\n    var multiplyModule = require('./multiply');\n    module.exports = {　　　　　　\n        square: function(num) {\n            return multiplyModule.multiply(num, num)\n        }\n    };\n\n});\n</code></pre>\n<p>multiply.js 的内容如下：</p>\n<pre><code class=\"language-js\">define(function(require, exports, module) {\n    console.log('加载了 multiply 模块')\n    var multiply = function(x, y) {　\n        return x * y;\n    };\n    module.exports = {　　　　　　\n        multiply: multiply\n    };\n});\n</code></pre>\n<p>跟第一个例子是同样的依赖结构，即 main 依赖 add 和 square，square 又依赖 multiply。</p>\n<p>seajs 项目 Demo 地址：<a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/seajs\">https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/seajs</a></p>\n<p>而如果我们在浏览器中打开 <code>index.html</code>，打印的顺序为：</p>\n<pre><code class=\"language-js\">加载了 add 模块\n2\n加载了 square 模块\n加载了 multiply 模块\n9\n</code></pre>\n<h2>CMD</h2>\n<p>与 AMD 一样，CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出。</p>\n<p>你去看 <a href=\"https://github.com/seajs/seajs/issues/242\">CMD 规范</a>的内容，主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析。</p>\n<h2>AMD 与 CMD 的区别</h2>\n<p>从 sea.js 和 require.js 的例子可以看出：</p>\n<p>1.CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。看两个项目中的 main.js：</p>\n<pre><code class=\"language-js\">// require.js 例子中的 main.js\n// 依赖必须一开始就写好\nrequire(['./add', './square'], function(addModule, squareModule) {\n    console.log(addModule.add(1, 1))\n    console.log(squareModule.square(3))\n});\n</code></pre>\n<pre><code class=\"language-js\">// sea.js 例子中的 main.js\ndefine(function(require, exports, module) {\n    var addModule = require('./add');\n    console.log(addModule.add(1, 1))\n\n    // 依赖可以就近书写\n    var squareModule = require('./square');\n    console.log(squareModule.square(3))\n});\n</code></pre>\n<p>2.对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。看两个项目中的打印顺序：</p>\n<pre><code class=\"language-js\">// require.js\n加载了 add 模块\n加载了 multiply 模块\n加载了 square 模块\n2\n9\n</code></pre>\n<pre><code class=\"language-js\">// sea.js\n加载了 add 模块\n2\n加载了 square 模块\n加载了 multiply 模块\n9\n</code></pre>\n<p>AMD 是将需要使用的模块先加载完再执行代码，而 CMD 是在 require 的时候才去加载模块文件，加载完再接着执行。</p>\n<h2>感谢</h2>\n<p>感谢 require.js 和 sea.js 在推动 JavaScript 模块化发展方面做出的贡献。</p>\n<h2>CommonJS</h2>\n<p>AMD 和 CMD 都是用于浏览器端的模块规范，而在服务器端比如 node，采用的则是 CommonJS 规范。</p>\n<p>导出模块的方式：</p>\n<pre><code class=\"language-js\">var add = function(x, y) {　\n    return x + y;\n};\n\nmodule.exports.add = add;\n</code></pre>\n<p>引入模块的方式：</p>\n<pre><code class=\"language-js\">var add = require('./add.js');\nconsole.log(add.add(1, 1));\n</code></pre>\n<p>我们将之前的例子改成 CommonJS 规范：</p>\n<pre><code class=\"language-js\">// main.js\nvar add = require('./add.js');\nconsole.log(add.add(1, 1))\n\nvar square = require('./square.js');\nconsole.log(square.square(3));\n</code></pre>\n<pre><code class=\"language-js\">// add.js\nconsole.log('加载了 add 模块')\n\nvar add = function(x, y) {　\n    return x + y;\n};\n\nmodule.exports.add = add;\n</code></pre>\n<pre><code class=\"language-js\">// multiply.js\nconsole.log('加载了 multiply 模块')\n\nvar multiply = function(x, y) {　\n    return x * y;\n};\n\nmodule.exports.multiply = multiply;\n</code></pre>\n<pre><code class=\"language-js\">// square.js\nconsole.log('加载了 square 模块')\n\nvar multiply = require('./multiply.js');\n\nvar square = function(num) {　\n    return multiply.multiply(num, num);\n};\n\nmodule.exports.square = square;\n</code></pre>\n<p>CommonJS 项目 Demo 地址：<a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/commonJS\">https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/commonJS</a></p>\n<p>如果我们执行 <code>node main.js</code>，打印的顺序为：</p>\n<pre><code class=\"language-js\">加载了 add 模块\n2\n加载了 square 模块\n加载了 multiply 模块\n9\n</code></pre>\n<p>跟 sea.js 的执行结果一致，也是在 require 的时候才去加载模块文件，加载完再接着执行。</p>\n<h2>CommonJS 与 AMD</h2>\n<p>引用阮一峰老师的<a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\">《JavaScript 标准参考教程（alpha）》</a>:</p>\n<blockquote>\n<p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p>\n</blockquote>\n<blockquote>\n<p>AMD规范则是非同步加载模块，允许指定回调函数。</p>\n<p>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。</p>\n</blockquote>\n<blockquote>\n<p>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p>\n</blockquote>\n<h2>ES6</h2>\n<p>ECMAScript2015 规定了新的模块加载方案。</p>\n<p>导出模块的方式：</p>\n<pre><code class=\"language-js\">var firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n</code></pre>\n<p>引入模块的方式：</p>\n<pre><code class=\"language-js\">import {firstName, lastName, year} from './profile';\n</code></pre>\n<p>我们再将上面的例子改成 ES6 规范：</p>\n<p>目录结构与 requirejs 和 seajs 目录结构一致。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;ES6&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Content&lt;/h1&gt;\n        &lt;script src=&quot;vender/main.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>注意！浏览器加载 ES6 模块，也使用 <code>&lt;script&gt;</code> 标签，但是要加入 <code>type=&quot;module&quot;</code> 属性。</p>\n<pre><code class=\"language-js\">// main.js\nimport {add} from './add.js';\nconsole.log(add(1, 1))\n\nimport {square} from './square.js';\nconsole.log(square(3));\n</code></pre>\n<pre><code class=\"language-js\">// add.js\nconsole.log('加载了 add 模块')\n\nvar add = function(x, y) {\n    return x + y;\n};\n\nexport {add}\n</code></pre>\n<pre><code class=\"language-js\">// multiply.js\nconsole.log('加载了 multiply 模块')\n\nvar multiply = function(x, y) {　\n    return x * y;\n};\n\nexport {multiply}\n</code></pre>\n<pre><code class=\"language-js\">// square.js\nconsole.log('加载了 square 模块')\n\nimport {multiply} from './multiply.js';\n\nvar square = function(num) {　\n    return multiply(num, num);\n};\n\nexport {square}\n</code></pre>\n<p>ES6-Module 项目 Demo 地址：<a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/ES6\">https://github.com/mqyqingfeng/Blog/tree/master/demos/ES6/module/ES6</a></p>\n<p>值得注意的，在 Chrome 中，如果直接打开，会报跨域错误，必须开启服务器，保证文件同源才可以有效果。</p>\n<p>为了验证这个效果你可以：</p>\n<pre><code class=\"language-bash\">cnpm install http-server -g\n</code></pre>\n<p>然后进入该目录，执行</p>\n<pre><code class=\"language-bash\">http-server\n</code></pre>\n<p>在浏览器打开 <code>http://localhost:8080/</code> 即可查看效果。</p>\n<p>打印的顺序为：</p>\n<pre><code class=\"language-js\">加载了 add 模块\n加载了 multiply 模块\n加载了 square 模块\n2\n9\n</code></pre>\n<p>跟 require.js 的执行结果是一致的，也就是将需要使用的模块先加载完再执行代码。</p>\n<h2>ES6 与 CommonJS</h2>\n<p>引用阮一峰老师的 <a href=\"http://es6.ruanyifeng.com/#docs/module-loader\">《ECMAScript 6 入门》</a>：</p>\n<blockquote>\n<p>它们有两个重大差异。</p>\n<ol>\n<li>\n<p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>\n</li>\n<li>\n<p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>\n</li>\n</ol>\n</blockquote>\n<p>第二个差异可以从两个项目的打印结果看出，导致这种差别的原因是：</p>\n<blockquote>\n<p>因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n</blockquote>\n<p>重点解释第一个差异。</p>\n<blockquote>\n<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>\n</blockquote>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">// 输出模块 counter.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n    counter: counter,\n    incCounter: incCounter,\n};\n</code></pre>\n<pre><code class=\"language-js\">// 引入模块 main.js\nvar mod = require('./counter');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n</code></pre>\n<p>counter.js 模块加载以后，它的内部变化就影响不到输出的 mod.counter 了。这是因为 mod.counter 是一个原始类型的值，会被缓存。</p>\n<p>但是如果修改 counter 为一个引用类型的话：</p>\n<pre><code class=\"language-js\">// 输出模块 counter.js\nvar counter = {\n    value: 3\n};\n\nfunction incCounter() {\n    counter.value++;\n}\nmodule.exports = {\n    counter: counter,\n    incCounter: incCounter,\n};\n</code></pre>\n<pre><code class=\"language-js\">// 引入模块 main.js\nvar mod = require('./counter.js');\n\nconsole.log(mod.counter.value); // 3\nmod.incCounter();\nconsole.log(mod.counter.value); // 4\n</code></pre>\n<p>value 是会发生改变的。不过也可以说这是 &quot;值的拷贝&quot;，只是对于引用类型而言，值指的其实是引用。</p>\n<p>而如果我们将这个例子改成 ES6:</p>\n<pre><code class=\"language-js\">// counter.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from './counter';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n</code></pre>\n<p>这是因为</p>\n<blockquote>\n<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>\n</blockquote>\n<h2>Babel</h2>\n<p>鉴于浏览器支持度的问题，如果要使用 ES6 的语法，一般都会借助 Babel，可对于 import 和 export 而言，只借助 Babel 就可以吗？</p>\n<p>让我们看看 Babel 是怎么编译 import 和 export 语法的。</p>\n<pre><code class=\"language-js\">// ES6\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n</code></pre>\n<pre><code class=\"language-js\">// Babel 编译后\n'use strict';\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexports.firstName = firstName;\nexports.lastName = lastName;\nexports.year = year;\n</code></pre>\n<p>是不是感觉有那么一点奇怪？编译后的语法更像是 CommonJS 规范，再看 import 的编译结果：</p>\n<pre><code class=\"language-js\">// ES6\nimport {firstName, lastName, year} from './profile';\n</code></pre>\n<pre><code class=\"language-js\">// Babel 编译后\n'use strict';\n\nvar _profile = require('./profile');\n</code></pre>\n<p>你会发现 Babel 只是把 ES6 模块语法转为 CommonJS 模块语法，然而浏览器是不支持这种模块语法的，所以直接跑在浏览器会报错的，如果想要在浏览器中运行，还是需要使用打包工具将代码打包。</p>\n<h2>webpack</h2>\n<p>Babel 将 ES6 模块转为 CommonJS 后， webpack 又是怎么做的打包的呢？它该如何将这些文件打包在一起，从而能保证正确的处理依赖，以及能在浏览器中运行呢？</p>\n<p>首先为什么浏览器中不支持 CommonJS 语法呢？</p>\n<p>这是因为浏览器环境中并没有 module、 exports、 require 等环境变量。</p>\n<p>换句话说，webpack 打包后的文件之所以在浏览器中能运行，就是靠模拟了这些变量的行为。</p>\n<p>那怎么模拟呢？</p>\n<p>我们以 CommonJS 项目中的 square.js 为例，它依赖了 multiply 模块：</p>\n<pre><code class=\"language-js\">console.log('加载了 square 模块')\n\nvar multiply = require('./multiply.js');\n\n\nvar square = function(num) {　\n    return multiply.multiply(num, num);\n};\n\nmodule.exports.square = square;\n</code></pre>\n<p>webpack 会将其包裹一层，注入这些变量：</p>\n<pre><code class=\"language-js\">function(module, exports, require) {\n    console.log('加载了 square 模块');\n\n    var multiply = require(&quot;./multiply&quot;);\n    module.exports = {\n        square: function(num) {\n            return multiply.multiply(num, num);\n        }\n    };\n}\n</code></pre>\n<p>那 webpack 又会将 CommonJS 项目的代码打包成什么样呢？我写了一个精简的例子，你可以直接复制到浏览器中查看效果：</p>\n<pre><code class=\"language-js\">// 自执行函数\n(function(modules) {\n\n    // 用于储存已经加载过的模块\n    var installedModules = {};\n\n    function require(moduleName) {\n\n        if (installedModules[moduleName]) {\n            return installedModules[moduleName].exports;\n        }\n\n        var module = installedModules[moduleName] = {\n            exports: {}\n        };\n\n        modules[moduleName](module, module.exports, require);\n\n        return module.exports;\n    }\n\n    // 加载主模块\n    return require(&quot;main&quot;);\n\n})({\n    &quot;main&quot;: function(module, exports, require) {\n\n        var addModule = require(&quot;./add&quot;);\n        console.log(addModule.add(1, 1))\n\n        var squareModule = require(&quot;./square&quot;);\n        console.log(squareModule.square(3));\n\n    },\n    &quot;./add&quot;: function(module, exports, require) {\n        console.log('加载了 add 模块');\n\n        module.exports = {\n            add: function(x, y) {\n                return x + y;\n            }\n        };\n    },\n    &quot;./square&quot;: function(module, exports, require) {\n        console.log('加载了 square 模块');\n\n        var multiply = require(&quot;./multiply&quot;);\n        module.exports = {\n            square: function(num) {\n                return multiply.multiply(num, num);\n            }\n        };\n    },\n\n    &quot;./multiply&quot;: function(module, exports, require) {\n        console.log('加载了 multiply 模块');\n\n        module.exports = {\n            multiply: function(x, y) {\n                return x * y;\n            }\n        };\n    }\n})\n</code></pre>\n<p>最终的执行结果为：</p>\n<pre><code class=\"language-js\">加载了 add 模块\n2\n加载了 square 模块\n加载了 multiply 模块\n9\n</code></pre>\n<h2>参考</h2>\n<ul>\n<li><a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\">《JavaScript 标准参考教程（alpha）》</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module-loader\">《ECMAScript6 入门》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20731484\">手写一个CommonJS打包工具（一）</a></li>\n</ul>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}