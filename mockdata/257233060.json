{"code":0,"data":"<h2>定义</h2>\n<p>程序调用自身的编程技巧称为递归(recursion)。</p>\n<h2>阶乘</h2>\n<p>以阶乘为例：</p>\n<pre><code class=\"language-js\">function factorial(n) {\n    if (n == 1) return n;\n    return n * factorial(n - 1)\n}\n\nconsole.log(factorial(5)) // 5 * 4 * 3 * 2 * 1 = 120\n</code></pre>\n<p>示意图(图片来自 <a href=\"wwww.penjee.com\">wwww.penjee.com</a>)：</p>\n<p><img src=\"https://github.com/mqyqingfeng/Blog/raw/master/Images/recursion/factorial.gif\" alt=\"阶乘\"></p>\n<h2>斐波那契数列</h2>\n<p>在<a href=\"https://github.com/mqyqingfeng/Blog/issues/46\">《JavaScript专题之函数记忆》</a>中讲到过的斐波那契数列也使用了递归：</p>\n<pre><code class=\"language-js\">function fibonacci(n){\n    return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconsole.log(fibonacci(5)) // 1 1 2 3 5\n</code></pre>\n<h2>递归条件</h2>\n<p>从这两个例子中，我们可以看出：</p>\n<p>构成递归需具备边界条件、递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的 <code>n == 1</code> 和 斐波那契数列中的 <code>n &lt; 2</code> 都是边界条件。</p>\n<p>总结一下递归的特点：</p>\n<ol>\n<li>子问题须与原始问题为同样的事，且更为简单；</li>\n<li>不能无限制地调用本身，须有个出口，化简为非递归状况处理。</li>\n</ol>\n<p>了解这些特点可以帮助我们更好的编写递归函数。</p>\n<h2>执行上下文栈</h2>\n<p>在<a href=\"https://github.com/mqyqingfeng/Blog/issues/4\">《JavaScript深入之执行上下文栈》</a>中，我们知道：</p>\n<p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。</p>\n<p>试着对阶乘函数分析执行的过程，我们会发现，JavaScript 会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文也是一笔不小的开销呐！那么，我们该如何优化呢？</p>\n<p>答案就是尾调用。</p>\n<h2>尾调用</h2>\n<p>尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">// 尾调用\nfunction f(x){\n    return g(x);\n}\n</code></pre>\n<p>然而</p>\n<pre><code class=\"language-js\">// 非尾调用\nfunction f(x){\n    return g(x) + 1;\n}\n</code></pre>\n<p>并不是尾调用，因为 g(x) 的返回值还需要跟 1 进行计算后，f(x)才会返回值。</p>\n<p>两者又有什么区别呢？答案就是执行上下文栈的变化不一样。</p>\n<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>\n<pre><code class=\"language-js\">    ECStack = [];\n</code></pre>\n<p>我们模拟下第一个尾调用函数执行时的执行上下文栈变化：</p>\n<pre><code class=\"language-js\">// 伪代码\nECStack.push(&lt;f&gt; functionContext);\n\nECStack.pop();\n\nECStack.push(&lt;g&gt; functionContext);\n\nECStack.pop();\n</code></pre>\n<p>我们再来模拟一下第二个非尾调用函数执行时的执行上下文栈变化：</p>\n<pre><code class=\"language-js\">ECStack.push(&lt;f&gt; functionContext);\n\nECStack.push(&lt;g&gt; functionContext);\n\nECStack.pop();\n\nECStack.pop();\n</code></pre>\n<p>也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。</p>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>所以我们只用把阶乘函数改造成一个尾递归形式，就可以避免创建那么多的执行上下文。但是我们该怎么做呢？</p>\n<h2>阶乘函数优化</h2>\n<p>我们需要做的就是把所有用到的内部变量改写成函数的参数，以阶乘函数为例：</p>\n<pre><code class=\"language-js\">function factorial(n, res) {\n    if (n == 1) return res;\n    return factorial(n - 1, n * res)\n}\n\nconsole.log(factorial(4, 1)) // 24\n</code></pre>\n<p>然而这个很奇怪呐……我们计算 4 的阶乘，结果函数要传入 4 和 1，我就不能只传入一个 4 吗？</p>\n<p>这个时候就要用到我们在<a href=\"https://github.com/mqyqingfeng/Blog/issues/43\">《JavaScript专题之偏函数》</a>中编写的 partial 函数了：</p>\n<pre><code class=\"language-js\">var newFactorial = partial(factorial, _, 1)\n\nnewFactorial(4) // 24\n</code></pre>\n<h2>应用</h2>\n<p>如果你看过 <a href=\"https://github.com/mqyqingfeng/Blog\">JavaScript 专题系列</a>的文章，你会发现递归有着很多的应用。</p>\n<p>作为专题系列的第十八篇，我们来盘点下之前的文章中都有哪些涉及到了递归：</p>\n<p>1.<a href=\"https://github.com/mqyqingfeng/Blog/issues/36\">《JavaScript 专题之数组扁平化》</a>：</p>\n<pre><code class=\"language-js\">function flatten(arr) {\n    return arr.reduce(function(prev, next){\n        return prev.concat(Array.isArray(next) ? flatten(next) : next)\n    }, [])\n}\n</code></pre>\n<p>2.<a href=\"https://github.com/mqyqingfeng/Blog/issues/32\">《JavaScript 专题之深浅拷贝》</a>：</p>\n<pre><code class=\"language-js\">var deepCopy = function(obj) {\n    if (typeof obj !== 'object') return;\n    var newObj = obj instanceof Array ? [] : {};\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];\n        }\n    }\n    return newObj;\n}\n</code></pre>\n<p>3.<a href=\"https://github.com/mqyqingfeng/Blog/issues/33\">JavaScript 专题之从零实现 jQuery 的 extend</a>：</p>\n<pre><code class=\"language-js\">// 非完整版本，完整版本请点击查看具体的文章\nfunction extend() {\n\n    ...\n\n    // 循环遍历要复制的对象们\n    for (; i &lt; length; i++) {\n        // 获取当前对象\n        options = arguments[i];\n        // 要求不能为空 避免extend(a,,b)这种情况\n        if (options != null) {\n            for (name in options) {\n                // 目标属性值\n                src = target[name];\n                // 要复制的对象的属性值\n                copy = options[name];\n\n                if (deep &amp;&amp; copy &amp;&amp; typeof copy == 'object') {\n                    // 递归调用\n                    target[name] = extend(deep, src, copy);\n                }\n                else if (copy !== undefined){\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    ...\n\n};\n</code></pre>\n<p>4.<a href=\"https://github.com/mqyqingfeng/Blog/issues/41\">《JavaScript 专题之如何判断两个对象相等》</a>：</p>\n<pre><code class=\"language-js\">// 非完整版本，完整版本请点击查看具体的文章\n// 属于间接调用\nfunction eq(a, b, aStack, bStack) {\n\n    ...\n\n    // 更复杂的对象使用 deepEq 函数进行深度比较\n    return deepEq(a, b, aStack, bStack);\n};\n\nfunction deepEq(a, b, aStack, bStack) {\n\n    ...\n\n    // 数组判断\n    if (areArrays) {\n\n        length = a.length;\n        if (length !== b.length) return false;\n\n        while (length--) {\n            if (!eq(a[length], b[length], aStack, bStack)) return false;\n        }\n    }\n    // 对象判断\n    else {\n\n        var keys = Object.keys(a),\n            key;\n        length = keys.length;\n\n        if (Object.keys(b).length !== length) return false;\n        while (length--) {\n\n            key = keys[length];\n            if (!(b.hasOwnProperty(key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false;\n        }\n    }\n\n}\n</code></pre>\n<p>5.<a href=\"https://github.com/mqyqingfeng/Blog/issues/42\">《JavaScript 专题之函数柯里化》</a>：</p>\n<pre><code class=\"language-js\">// 非完整版本，完整版本请点击查看具体的文章\nfunction curry(fn, args) {\n    length = fn.length;\n\n    args = args || [];\n\n    return function() {\n\n        var _args = args.slice(0),\n\n            arg, i;\n\n        for (i = 0; i &lt; arguments.length; i++) {\n\n            arg = arguments[i];\n\n            _args.push(arg);\n\n        }\n        if (_args.length &lt; length) {\n            return curry.call(this, fn, _args);\n        }\n        else {\n            return fn.apply(this, _args);\n        }\n    }\n}\n</code></pre>\n<h2>写在最后</h2>\n<p>递归的内容远不止这些，比如还有汉诺塔、二叉树遍历等递归场景，本篇就不过多展开，真希望未来能写个算法系列。</p>\n<h2>专题系列</h2>\n<p>JavaScript专题系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}