{"code":0,"data":"<h2>前言</h2>\n<p>在了解 Babel 是如何编译 class 前，我们先看看 ES6 的 class 和 ES5 的构造函数是如何对应的。毕竟，ES6 的 class 可以看作一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>\n<h2>constructor</h2>\n<p>ES6 中：</p>\n<pre><code class=\"language-js\">class Person {\n    constructor(name) {\n        this.name = name;\n    }\n\n    sayHello() {\n        return 'hello, I am ' + this.name;\n    }\n}\n\nvar kevin = new Person('Kevin');\nkevin.sayHello(); // hello, I am Kevin\n</code></pre>\n<p>对应到 ES5 中就是:</p>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHello = function () {\n    return 'hello, I am ' + this.name;\n};\n\nvar kevin = new Person('Kevin');\nkevin.sayHello(); // hello, I am Kevin\n</code></pre>\n<p>我们可以看到 ES5 的构造函数 Person，对应 ES6 的 Person 类的 constructor 方法。</p>\n<p>值得注意的是：<strong>类的内部所有定义的方法，都是不可枚举的（non-enumerable）</strong></p>\n<p>以上面的例子为例，在 ES6 中：</p>\n<pre><code class=\"language-js\">Object.keys(Person.prototype); // []\nObject.getOwnPropertyNames(Person.prototype); // [&quot;constructor&quot;, &quot;sayHello&quot;]\n</code></pre>\n<p>然而在 ES5 中：</p>\n<pre><code class=\"language-js\">Object.keys(Person.prototype); // ['sayHello']\nObject.getOwnPropertyNames(Person.prototype); // [&quot;constructor&quot;, &quot;sayHello&quot;]\n</code></pre>\n<h2>实例属性</h2>\n<p>以前，我们定义实例属性，只能写在类的 constructor 方法里面。比如：</p>\n<pre><code class=\"language-js\">class Person {\n    constructor() {\n        this.state = {\n            count: 0\n        };\n    }\n}\n</code></pre>\n<p>然而现在有一个提案，对实例属性和静态属性都规定了新的写法，而且 Babel 已经支持。现在我们可以写成：</p>\n<pre><code class=\"language-js\">class Person {\n    state = {\n        count: 0\n    };\n}\n</code></pre>\n<p>对应到 ES5 都是：</p>\n<pre><code class=\"language-js\">function Person() {\n    this.state = {\n        count: 0\n    };\n}\n</code></pre>\n<h2>静态方法</h2>\n<p>所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>\n<p>ES6 中：</p>\n<pre><code class=\"language-js\">class Person {\n    static sayHello() {\n        return 'hello';\n    }\n}\n\nPerson.sayHello() // 'hello'\n\nvar kevin = new Person();\nkevin.sayHello(); // TypeError: kevin.sayHello is not a function\n</code></pre>\n<p>对应 ES5：</p>\n<pre><code class=\"language-js\">function Person() {}\n\nPerson.sayHello = function() {\n    return 'hello';\n};\n\nPerson.sayHello(); // 'hello'\n\nvar kevin = new Person();\nkevin.sayHello(); // TypeError: kevin.sayHello is not a function\n</code></pre>\n<h2>静态属性</h2>\n<p>静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。以前，我们添加静态属性只可以这样：</p>\n<pre><code class=\"language-js\">class Person {}\n\nPerson.name = 'kevin';\n</code></pre>\n<p>因为上面提到的提案，现在可以写成：</p>\n<pre><code class=\"language-js\">class Person {\n  static name = 'kevin';\n}\n</code></pre>\n<p>对应到 ES5 都是：</p>\n<pre><code class=\"language-js\">function Person() {};\n\nPerson.name = 'kevin';\n</code></pre>\n<h2>new 调用</h2>\n<p>值得注意的是：类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。</p>\n<pre><code class=\"language-js\">class Person {}\n\nPerson(); // TypeError: Class constructor Foo cannot be invoked without 'new'\n</code></pre>\n<h2>getter 和 setter</h2>\n<p>与 ES5 一样，在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<pre><code class=\"language-js\">class Person {\n    get name() {\n        return 'kevin';\n    }\n    set name(newName) {\n        console.log('new name 为：' + newName)\n    }\n}\n\nlet person = new Person();\n\nperson.name = 'daisy';\n// new name 为：daisy\n\nconsole.log(person.name);\n// kevin\n</code></pre>\n<p>对应到 ES5 中：</p>\n<pre><code class=\"language-js\">function Person(name) {}\n\nPerson.prototype = {\n    get name() {\n        return 'kevin';\n    },\n    set name(newName) {\n        console.log('new name 为：' + newName)\n    }\n}\n\nlet person = new Person();\n\nperson.name = 'daisy';\n// new name 为：daisy\n\nconsole.log(person.name);\n// kevin\n</code></pre>\n<h2>Babel 编译</h2>\n<p>至此，我们已经知道了有关“类”的方法中，ES6 与 ES5 是如何对应的，实际上 Babel 在编译时并不会直接就转成这种形式，Babel 会自己生成一些辅助函数，帮助实现 ES6 的特性。</p>\n<p>我们可以在 Babel 官网的<a href=\"https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;targets=&amp;browsers=&amp;builtIns=false&amp;debug=false&amp;code_lz=Q\"> Try it out </a>页面查看 ES6 的代码编译成什么样子。</p>\n<h3>编译（一）</h3>\n<p>ES6 代码为：</p>\n<pre><code class=\"language-js\">class Person {\n    constructor(name) {\n        this.name = name;\n    }\n}\n</code></pre>\n<p>Babel 编译为：</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;;\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(&quot;Cannot call a class as a function&quot;);\n    }\n}\n\nvar Person = function Person(name) {\n    _classCallCheck(this, Person);\n\n    this.name = name;\n};\n</code></pre>\n<p>_classCallCheck 的作用是检查 Person 是否是通过 new 的方式调用，在上面，我们也说过，类必须使用 new 调用，否则会报错。</p>\n<p>当我们使用 <code>var person = Person()</code> 的形式调用的时候，this 指向 window，所以 <code>instance instanceof Constructor</code> 就会为 false，与 ES6 的要求一致。</p>\n<h3>编译（二）</h3>\n<p>ES6 代码为：</p>\n<pre><code class=\"language-js\">class Person {\n    // 实例属性\n    foo = 'foo';\n    // 静态属性\n    static bar = 'bar';\n\n    constructor(name) {\n        this.name = name;\n    }\n}\n</code></pre>\n<p>Babel 编译为：</p>\n<pre><code class=\"language-js\">'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(&quot;Cannot call a class as a function&quot;);\n    }\n}\n\nvar Person = function Person(name) {\n    _classCallCheck(this, Person);\n\n    this.foo = 'foo';\n\n    this.name = name;\n};\n\nPerson.bar = 'bar';\n</code></pre>\n<h3>编译（三）</h3>\n<p>ES6 代码为：</p>\n<pre><code class=\"language-js\">class Person {\n    constructor(name) {\n        this.name = name;\n    }\n\n    sayHello() {\n        return 'hello, I am ' + this.name;\n    }\n\n    static onlySayHello() {\n        return 'hello'\n    }\n\n    get name() {\n        return 'kevin';\n    }\n\n    set name(newName) {\n        console.log('new name 为：' + newName)\n    }\n}\n</code></pre>\n<p>对应到 ES5 的代码应该是：</p>\n<pre><code class=\"language-js\">function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype =  {\n    sayHello: function () {\n        return 'hello, I am ' + this.name;\n    },\n    get name() {\n        return 'kevin';\n    },\n    set name(newName) {\n        console.log('new name 为：' + newName)\n    }\n}\n\nPerson.onlySayHello = function () {\n    return 'hello'\n};\n</code></pre>\n<p>Babel 编译后为：</p>\n<pre><code class=\"language-js\">'use strict';\n\nvar _createClass = function() {\n    function defineProperties(target, props) {\n        for (var i = 0; i &lt; props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (&quot;value&quot; in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(&quot;Cannot call a class as a function&quot;);\n    }\n}\n\nvar Person = function() {\n    function Person(name) {\n        _classCallCheck(this, Person);\n\n        this.name = name;\n    }\n\n    _createClass(Person, [{\n        key: 'sayHello',\n        value: function sayHello() {\n            return 'hello, I am ' + this.name;\n        }\n    }, {\n        key: 'name',\n        get: function get() {\n            return 'kevin';\n        },\n        set: function set(newName) {\n            console.log('new name 为：' + newName);\n        }\n    }], [{\n        key: 'onlySayHello',\n        value: function onlySayHello() {\n            return 'hello';\n        }\n    }]);\n\n    return Person;\n}();\n</code></pre>\n<p>我们可以看到 Babel 生成了一个 _createClass 辅助函数，该函数传入三个参数，第一个是构造函数，在这个例子中也就是 Person，第二个是要添加到原型上的函数数组，第三个是要添加到构造函数本身的函数数组，也就是所有添加 static 关键字的函数。该函数的作用就是将函数数组中的方法添加到构造函数或者构造函数的原型中，最后返回这个构造函数。</p>\n<p>在其中，又生成了一个 defineProperties 辅助函数，使用 Object.defineProperty 方法添加属性。</p>\n<p>默认 enumerable 为 false，configurable 为 true，这个在上面也有强调过，是为了防止 Object.keys() 之类的方法遍历到。然后通过判断 value 是否存在，来判断是否是 getter 和 setter。如果存在 value，就为 descriptor 添加 value 和 writable 属性，如果不存在，就直接使用 get 和 set 属性。</p>\n<h2>写在后面</h2>\n<p>至此，我们已经了解了 Babel 是如何编译一个 Class 的，然而，Class 还有一个重要的特性就是继承，Class 如何继承，Babel 又该如何编译，欢迎期待下一篇《 ES6 系列之 Babel 是如何编译 Class 的(下)》</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}