{"code":0,"data":"<h2>前言</h2>\n<p>我们以<code>查找指定目录下的最大文件</code>为例，感受从</p>\n<p>回调函数 -&gt; Promise -&gt; Generator -&gt; Async</p>\n<p>异步处理方式的改变。</p>\n<h2>API 介绍</h2>\n<p>为了实现这个功能，我们需要用到几个 Nodejs 的 API，所以我们来简单介绍一下。</p>\n<h3>fs.readdir</h3>\n<p>readdir 方法用于读取目录，返回一个包含文件和目录的数组。</p>\n<h3>fs.stat</h3>\n<p>stat 方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。此外，该对象还有一个 isFile() 方法可以判断正在处理的到底是一个文件，还是一个目录。</p>\n<h2>思路分析</h2>\n<p>我们基本的实现思路就是：</p>\n<ol>\n<li>用 <code>fs.readdir</code> 获取指定目录的内容信息</li>\n<li>循环遍历内容信息，使用 <code>fs.stat</code> 获取该文件或者目录的具体信息</li>\n<li>将具体信息储存起来</li>\n<li>当全部储存起来后，筛选其中的是文件的信息</li>\n<li>遍历比较，找出最大文件</li>\n<li>获取并返回最大文件</li>\n</ol>\n<p>然后我们直接上代码吧。</p>\n<h2>回调函数</h2>\n<pre><code class=\"language-js\">var fs = require('fs');\nvar path = require('path');\n\nfunction findLargest(dir, cb) {\n    // 读取目录下的所有文件\n    fs.readdir(dir, function(er, files) {\n        if (er) return cb(er);\n\n        var counter = files.length;\n        var errored = false;\n        var stats = [];\n\n        files.forEach(function(file, index) {\n            // 读取文件信息\n            fs.stat(path.join(dir, file), function(er, stat) {\n\n                if (errored) return;\n\n                if (er) {\n                    errored = true;\n                    return cb(er);\n                }\n\n                stats[index] = stat;\n\n                // 事先算好有多少个文件，读完 1 个文件信息，计数减 1，当为 0 时，说明读取完毕，此时执行最终的比较操作\n                if (--counter == 0) {\n\n                    var largest = stats\n                        .filter(function(stat) { return stat.isFile() })\n                        .reduce(function(prev, next) {\n                            if (prev.size &gt; next.size) return prev\n                            return next\n                        })\n\n                    cb(null, files[stats.indexOf(largest)])\n                }\n            })\n        })\n    })\n}\n</code></pre>\n<p>使用方式为：</p>\n<pre><code class=\"language-js\">// 查找当前目录最大的文件\nfindLargest('./', function(er, filename) {\n    if (er) return console.error(er)\n    console.log('largest file was:', filename)\n});\n</code></pre>\n<h2>Promise</h2>\n<pre><code class=\"language-js\">var fs = require('fs');\nvar path = require('path');\n\nvar readDir = function(dir) {\n    return new Promise(function(resolve, reject) {\n        fs.readdir(dir, function(err, files) {\n            if (err) reject(err);\n            resolve(files)\n        })\n    })\n}\n\nvar stat = function(path) {\n    return new Promise(function(resolve, reject) {\n        fs.stat(path, function(err, stat) {\n            if (err) reject(err)\n            resolve(stat)\n        })\n    })\n}\n\nfunction findLargest(dir) {\n    return readDir(dir)\n        .then(function(files) {\n            let promises = files.map(file =&gt; stat(path.join(dir, file)))\n            return Promise.all(promises).then(function(stats) {\n                return { stats, files }\n            })\n        })\n        .then(data =&gt; {\n\n            let largest = data.stats\n                .filter(function(stat) { return stat.isFile() })\n                .reduce((prev, next) =&gt; {\n                    if (prev.size &gt; next.size) return prev\n                    return next\n                })\n\n            return data.files[data.stats.indexOf(largest)]\n        })\n\n}\n</code></pre>\n<p>使用方式为：</p>\n<pre><code class=\"language-js\">findLargest('./')\n.then(function(filename) {\n    console.log('largest file was:', filename);\n})\n.catch(function() {\n    console.log(error);\n});\n</code></pre>\n<h2>Generator</h2>\n<pre><code class=\"language-js\">var fs = require('fs');\nvar path = require('path');\n\nvar co = require('co')\n\nvar readDir = function(dir) {\n    return new Promise(function(resolve, reject) {\n        fs.readdir(dir, function(err, files) {\n            if (err) reject(err);\n            resolve(files)\n        })\n    })\n}\n\nvar stat = function(path) {\n    return new Promise(function(resolve, reject) {\n        fs.stat(path, function(err, stat) {\n            if (err) reject(err)\n            resolve(stat)\n        })\n    })\n}\n\nfunction* findLargest(dir) {\n    var files = yield readDir(dir);\n    var stats = yield files.map(function(file) {\n        return stat(path.join(dir, file))\n    })\n\n    let largest = stats\n        .filter(function(stat) { return stat.isFile() })\n        .reduce((prev, next) =&gt; {\n            if (prev.size &gt; next.size) return prev\n            return next\n        })\n\n    return files[stats.indexOf(largest)]\n\n}\n</code></pre>\n<p>使用方式为：</p>\n<pre><code class=\"language-js\">co(findLargest, './')\n.then(function(filename) {\n    console.log('largest file was:', filename);\n})\n.catch(function() {\n    console.log(error);\n});\n</code></pre>\n<h2>Async</h2>\n<pre><code class=\"language-js\">var fs = require('fs');\nvar path = require('path');\n\nvar readDir = function(dir) {\n    return new Promise(function(resolve, reject) {\n        fs.readdir(dir, function(err, files) {\n            if (err) reject(err);\n            resolve(files)\n        })\n    })\n}\n\nvar stat = function(path) {\n    return new Promise(function(resolve, reject) {\n        fs.stat(path, function(err, stat) {\n            if (err) reject(err)\n            resolve(stat)\n        })\n    })\n}\n\nasync function findLargest(dir) {\n    var files = await readDir(dir);\n\n    let promises = files.map(file =&gt; stat(path.join(dir, file)))\n    var stats = await Promise.all(promises)\n\n    let largest = stats\n        .filter(function(stat) { return stat.isFile() })\n        .reduce((prev, next) =&gt; {\n            if (prev.size &gt; next.size) return prev\n            return next\n        })\n\n    return files[stats.indexOf(largest)]\n\n}\n</code></pre>\n<p>使用方式为：</p>\n<pre><code class=\"language-js\">findLargest('./')\n.then(function(filename) {\n    console.log('largest file was:', filename);\n})\n.catch(function() {\n    console.log(error);\n});\n</code></pre>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}