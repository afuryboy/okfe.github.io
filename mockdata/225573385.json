{"code":0,"data":"<h2>call</h2>\n<p>一句话介绍 call：</p>\n<blockquote>\n<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>\n</blockquote>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">var foo = {\n    value: 1\n};\n\nfunction bar() {\n    console.log(this.value);\n}\n\nbar.call(foo); // 1\n</code></pre>\n<p>注意两点：</p>\n<ol>\n<li>call 改变了 this 的指向，指向到 foo</li>\n<li>bar 函数执行了</li>\n</ol>\n<h2>模拟实现第一步</h2>\n<p>那么我们该怎么模拟实现这两个效果呢？</p>\n<p>试想当调用 call 的时候，把 foo 对象改造成如下：</p>\n<pre><code class=\"language-js\">var foo = {\n    value: 1,\n    bar: function() {\n        console.log(this.value)\n    }\n};\n\nfoo.bar(); // 1\n</code></pre>\n<p>这个时候 this 就指向了 foo，是不是很简单呢？</p>\n<p>但是这样却给 foo 对象本身添加了一个属性，这可不行呐！</p>\n<p>不过也不用担心，我们用 delete 再删除它不就好了~</p>\n<p>所以我们模拟的步骤可以分为：</p>\n<ol>\n<li>将函数设为对象的属性</li>\n<li>执行该函数</li>\n<li>删除该函数</li>\n</ol>\n<p>以上个例子为例，就是：</p>\n<pre><code class=\"language-js\">// 第一步\nfoo.fn = bar\n// 第二步\nfoo.fn()\n// 第三步\ndelete foo.fn\n</code></pre>\n<p>fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。</p>\n<p>根据这个思路，我们可以尝试着去写第一版的 <strong>call2</strong> 函数：</p>\n<pre><code class=\"language-js\">// 第一版\nFunction.prototype.call2 = function(context) {\n    // 首先要获取调用call的函数，用this可以获取\n    context.fn = this;\n    context.fn();\n    delete context.fn;\n}\n\n// 测试一下\nvar foo = {\n    value: 1\n};\n\nfunction bar() {\n    console.log(this.value);\n}\n\nbar.call2(foo); // 1\n</code></pre>\n<p>正好可以打印 1 哎！是不是很开心！(～￣▽￣)～</p>\n<h2>模拟实现第二步</h2>\n<p>最一开始也讲了，call 函数还能给定参数执行函数。举个例子：</p>\n<pre><code class=\"language-js\">var foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    console.log(name)\n    console.log(age)\n    console.log(this.value);\n}\n\nbar.call(foo, 'kevin', 18);\n// kevin\n// 18\n// 1\n\n</code></pre>\n<p>注意：传入的参数并不确定，这可咋办？</p>\n<p>不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。</p>\n<p>比如这样：</p>\n<pre><code class=\"language-js\">// 以上个例子为例，此时的arguments为：\n// arguments = {\n//      0: foo,\n//      1: 'kevin',\n//      2: 18,\n//      length: 3\n// }\n// 因为arguments是类数组对象，所以可以用for循环\nvar args = [];\nfor(var i = 1, len = arguments.length; i &lt; len; i++) {\n    args.push('arguments[' + i + ']');\n}\n\n// 执行后 args为 [&quot;arguments[1]&quot;, &quot;arguments[2]&quot;, &quot;arguments[3]&quot;]\n</code></pre>\n<p>不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。</p>\n<pre><code class=\"language-js\">// 将数组里的元素作为多个参数放进函数的形参里\ncontext.fn(args.join(','))\n// (O_o)??\n// 这个方法肯定是不行的啦！！！\n</code></pre>\n<p>也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样：</p>\n<pre><code class=\"language-js\">eval('context.fn(' + args +')')\n</code></pre>\n<p>这里 args 会自动调用 Array.toString() 这个方法。</p>\n<p>所以我们的第二版克服了两个大问题，代码如下：</p>\n<pre><code class=\"language-js\">// 第二版\nFunction.prototype.call2 = function(context) {\n    context.fn = this;\n    var args = [];\n    for(var i = 1, len = arguments.length; i &lt; len; i++) {\n        args.push('arguments[' + i + ']');\n    }\n    eval('context.fn(' + args +')');\n    delete context.fn;\n}\n\n// 测试一下\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    console.log(name)\n    console.log(age)\n    console.log(this.value);\n}\n\nbar.call2(foo, 'kevin', 18); \n// kevin\n// 18\n// 1\n</code></pre>\n<p>(๑•̀ㅂ•́)و✧</p>\n<h2>模拟实现第三步</h2>\n<p>模拟代码已经完成 80%，还有两个小点要注意：</p>\n<p><strong>1.this 参数可以传 null，当为 null 的时候，视为指向 window</strong></p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">\nvar value = 1;\n\nfunction bar() {\n    console.log(this.value);\n}\n\nbar.call(null); // 1\n</code></pre>\n<p>虽然这个例子本身不使用 call，结果依然一样。</p>\n<p><strong>2.函数是可以有返回值的！</strong></p>\n<p>举个例子：</p>\n<pre><code class=\"language-js\">\nvar obj = {\n    value: 1\n}\n\nfunction bar(name, age) {\n    return {\n        value: this.value,\n        name: name,\n        age: age\n    }\n}\n\nconsole.log(bar.call(obj, 'kevin', 18));\n// Object {\n//    value: 1,\n//    name: 'kevin',\n//    age: 18\n// }\n</code></pre>\n<p>不过都很好解决，让我们直接看第三版也就是最后一版的代码：</p>\n<pre><code class=\"language-js\">// 第三版\nFunction.prototype.call2 = function (context) {\n    var context = context || window;\n    context.fn = this;\n\n    var args = [];\n    for(var i = 1, len = arguments.length; i &lt; len; i++) {\n        args.push('arguments[' + i + ']');\n    }\n\n    var result = eval('context.fn(' + args +')');\n\n    delete context.fn\n    return result;\n}\n\n// 测试一下\nvar value = 2;\n\nvar obj = {\n    value: 1\n}\n\nfunction bar(name, age) {\n    console.log(this.value);\n    return {\n        value: this.value,\n        name: name,\n        age: age\n    }\n}\n\nbar.call2(null); // 2\n\nconsole.log(bar.call2(obj, 'kevin', 18));\n// 1\n// Object {\n//    value: 1,\n//    name: 'kevin',\n//    age: 18\n// }\n</code></pre>\n<p>到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ</p>\n<h2>apply的模拟实现</h2>\n<p>apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现：</p>\n<pre><code class=\"language-js\">Function.prototype.apply = function (context, arr) {\n    var context = Object(context) || window;\n    context.fn = this;\n\n    var result;\n    if (!arr) {\n        result = context.fn();\n    }\n    else {\n        var args = [];\n        for (var i = 0, len = arr.length; i &lt; len; i++) {\n            args.push('arr[' + i + ']');\n        }\n        result = eval('context.fn(' + args + ')')\n    }\n\n    delete context.fn\n    return result;\n}\n</code></pre>\n<h2>下一篇文章</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/12\">JavaScript深入之bind的模拟实现</a></p>\n<h2>重要参考</h2>\n<p><a href=\"https://www.zhihu.com/question/35787390\">知乎问题 不能使用call、apply、bind，如何用 js 实现 call 或者 apply 的功能？</a></p>\n<h2>深入系列</h2>\n<p>JavaScript深入系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}