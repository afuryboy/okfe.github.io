{"code":0,"data":"<h2>前言</h2>\n<p>本文就是简单介绍下 Generator 语法编译后的代码。</p>\n<h2>Generator</h2>\n<pre><code class=\"language-js\">function* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n</code></pre>\n<p>我们打印下执行的结果：</p>\n<pre><code class=\"language-js\">var hw = helloWorldGenerator();\n\nconsole.log(hw.next()); // {value: &quot;hello&quot;, done: false}\nconsole.log(hw.next()); // {value: &quot;world&quot;, done: false}\nconsole.log(hw.next()); // {value: &quot;ending&quot;, done: true}\nconsole.log(hw.next()); // {value: undefined, done: true}\n</code></pre>\n<h2>Babel</h2>\n<p>具体的执行过程就不说了，我们直接在 Babel 官网的 <a href=\"https://babeljs.io/repl\">Try it out</a> 粘贴上述代码，然后查看代码被编译成了什么样子：</p>\n<pre><code class=\"language-js\">/**\n * 我们就称呼这个版本为简单编译版本吧\n */\nvar _marked = /*#__PURE__*/ regeneratorRuntime.mark(helloWorldGenerator);\n\nfunction helloWorldGenerator() {\n  return regeneratorRuntime.wrap(\n    function helloWorldGenerator$(_context) {\n      while (1) {\n        switch ((_context.prev = _context.next)) {\n          case 0:\n            _context.next = 2;\n            return &quot;hello&quot;;\n\n          case 2:\n            _context.next = 4;\n            return &quot;world&quot;;\n\n          case 4:\n            return _context.abrupt(&quot;return&quot;, &quot;ending&quot;);\n\n          case 5:\n          case &quot;end&quot;:\n            return _context.stop();\n        }\n      }\n    },\n    _marked,\n    this\n  );\n}\n</code></pre>\n<p>猛一看，好像编译后的代码还蛮少的，但是细细一看，编译后的代码肯定是不能用的呀，<code>regeneratorRuntime</code> 是个什么鬼？哪里有声明呀？<code>mark</code> 和 <code>wrap</code> 方法又都做了什么？</p>\n<p>难道就不能编译一个完整可用的代码吗？</p>\n<h2>regenerator</h2>\n<p>如果你想看到完整可用的代码，你可以使用 <a href=\"https://github.com/facebook/regenerator\">regenerator</a>，这是 facebook 下的一个工具，用于编译 ES6 的 generator 函数。</p>\n<p>我们先安装一下 regenerator：</p>\n<pre><code class=\"language-bash\">npm install -g regenerator\n</code></pre>\n<p>然后新建一个 generator.js 文件，里面的代码就是文章最一开始的代码，我们执行命令：</p>\n<pre><code class=\"language-bash\">regenerator --include-runtime generator.js &gt; generator-es5.js\n</code></pre>\n<p>我们就可以在 generator-es5.js 文件看到编译后的完整可用的代码。</p>\n<p>而这一编译就编译了 700 多行…… 编译后的代码可以查看 <a href=\"https://github.com/mqyqingfeng/Blog/blob/master/demos/ES6/generator/generator-es5.js\">generator-es5.js</a></p>\n<p>总之编译后的代码还蛮复杂，我们可以从中抽离出大致的逻辑，至少让简单编译的那段代码能够跑起来。</p>\n<h2>mark 函数</h2>\n<p>简单编译后的代码第一段是这样的：</p>\n<pre><code class=\"language-js\">var _marked = /*#__PURE__*/ regeneratorRuntime.mark(helloWorldGenerator);\n</code></pre>\n<p>我们查看完整编译版本中 mark 函数的源码：</p>\n<pre><code class=\"language-js\">runtime.mark = function(genFun) {\n  genFun.__proto__ = GeneratorFunctionPrototype;\n  genFun.prototype = Object.create(Gp);\n  return genFun;\n};\n</code></pre>\n<p>这其中又涉及了 GeneratorFunctionPrototype 和 Gp 变量，我们也查看下对应的代码：</p>\n<pre><code class=\"language-js\">function Generator() {}\nfunction GeneratorFunction() {}\nfunction GeneratorFunctionPrototype() {}\n\n...\n\nvar Gp = GeneratorFunctionPrototype.prototype =\n  Generator.prototype = Object.create(IteratorPrototype);\n\nGeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\nGeneratorFunctionPrototype.constructor = GeneratorFunction;\n\nGeneratorFunctionPrototype[toStringTagSymbol] =\n  GeneratorFunction.displayName = &quot;GeneratorFunction&quot;;\n</code></pre>\n<p>这段代码构建了一堆看起来很复杂的关系链，其实这是参照着 <a href=\"https://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-constructor\">ES6 规范</a>构建的关系链:</p>\n<p><img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/ES6/regenerator/regenerator.png\" alt=\"regenerator\"></p>\n<p>图中 <code>+@@toStringTag:s = 'Generator'</code> 的就是 Gp，<code>+@@toStringTag:s = 'GeneratorFunction'</code> 的就是 GeneratorFunctionPrototype。</p>\n<p>构建关系链的目的在于判断关系的时候能够跟原生的保持一致，就比如：</p>\n<pre><code class=\"language-js\">function* f() {}\nvar g = f();\nconsole.log(g.__proto__ === f.prototype); // true\nconsole.log(g.__proto__.__proto__ === f.__proto__.prototype); // true\n</code></pre>\n<p>为了简化起见，我们可以把 Gp 先设置为一个空对象，不过正如你在上图中看到的，next()、 throw()、return() 函数都是挂载在 Gp 对象上，实际上，在完整的编译代码中，确实有为 Gp 添加这三个函数的方法：</p>\n<pre><code class=\"language-js\">// 117 行\nfunction defineIteratorMethods(prototype) {\n  [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) {\n    prototype[method] = function(arg) {\n      return this._invoke(method, arg);\n    };\n  });\n}\n\n// 406 行\ndefineIteratorMethods(Gp);\n</code></pre>\n<p>为了简单起见，我们将整个 mark 函数简化为：</p>\n<pre><code class=\"language-js\">runtime.mark = function(genFun) {\n  var generator = Object.create({\n    next: function(arg) {\n      return this._invoke('next', arg)\n    }\n  });\n  genFun.prototype = generator;\n  return genFun;\n};\n</code></pre>\n<h2>wrap 函数</h2>\n<p>除了设置关系链之外，mark 函数的返回值 genFun 还作为了 wrap 函数的第二个参数传入：</p>\n<pre><code class=\"language-js\">function helloWorldGenerator() {\n  return regeneratorRuntime.wrap(\n    function helloWorldGenerator$(_context) {\n      ...\n    },\n    _marked,\n    this\n  );\n}\n</code></pre>\n<p>我们再看下 wrap 函数：</p>\n<pre><code class=\"language-js\">function wrap(innerFn, outerFn, self) {\n  var generator = Object.create(outerFn.prototype);\n  var context = new Context([]);\n  generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n  return generator;\n}\n</code></pre>\n<p>所以当执行 <code>var hw = helloWorldGenerator();</code> 的时候，其实执行的是 wrap 函数，wrap 函数返回了 generator，generator 是一个对象，原型是 <code>outerFn.prototype</code>, <code>outerFn.prototype</code> 其实就是 <code>genFun.prototype</code>， <code>genFun.prototype</code> 是一个空对象，原型上有 next() 方法。</p>\n<p>所以当你执行 <code>hw.next()</code> 的时候，执行的其实是 hw 原型的原型上的 next 函数，next 函数执行的又是 hw 的 _invoke 函数：</p>\n<pre><code class=\"language-js\">generator._invoke = makeInvokeMethod(innerFn, self, context);\n</code></pre>\n<p>innerFn 就是 wrap 包裹的那个函数，其实就是 helloWordGenerato$ 函数，呐，就是这个函数：</p>\n<pre><code class=\"language-js\">function helloWorldGenerator$(_context) {\n  while (1) {\n    switch ((_context.prev = _context.next)) {\n      case 0:\n        _context.next = 2;\n        return &quot;hello&quot;;\n\n      case 2:\n        _context.next = 4;\n        return &quot;world&quot;;\n\n      case 4:\n        return _context.abrupt(&quot;return&quot;, &quot;ending&quot;);\n\n      case 5:\n      case &quot;end&quot;:\n        return _context.stop();\n    }\n  }\n}\n</code></pre>\n<p>而 context 你可以直接理解为这样一个全局对象：</p>\n<pre><code class=\"language-js\">var ContinueSentinel = {};\n\nvar context = {\n  done: false,\n  method: &quot;next&quot;,\n  next: 0,\n  prev: 0,\n  abrupt: function(type, arg) {\n    var record = {};\n    record.type = type;\n    record.arg = arg;\n\n    return this.complete(record);\n  },\n  complete: function(record, afterLoc) {\n    if (record.type === &quot;return&quot;) {\n      this.rval = this.arg = record.arg;\n      this.method = &quot;return&quot;;\n      this.next = &quot;end&quot;;\n    }\n\n    return ContinueSentinel;\n  },\n  stop: function() {\n    this.done = true;\n    return this.rval;\n  }\n};\n</code></pre>\n<p>每次 <code>hw.next</code> 的时候，就会修改 next 和 prev 属性的值，当在 generator 函数中 return 的时候会执行 abrupt，abrupt 中又会执行 complete，执行完 complete，因为 <code>this.next = end</code> 的缘故，再执行就会执行 stop 函数。</p>\n<p>我们来看下 makeInvokeMethod 函数：</p>\n<pre><code class=\"language-js\">var ContinueSentinel = {};\n\nfunction makeInvokeMethod(innerFn, self, context) {\n  var state = 'start';\n\n  return function invoke(method, arg) {\n\n    if (state === 'completed') {\n      return { value: undefined, done: true };\n    }\n\n    context.method = method;\n    context.arg = arg;\n\n    while (true) {\n\n      state = 'executing';\n\n      var record = {\n        type: 'normal',\n        arg: innerFn.call(self, context)\n      };\n      if (record.type === &quot;normal&quot;) {\n\n        state = context.done\n          ? 'completed'\n          : 'yield';\n\n        if (record.arg === ContinueSentinel) {\n          continue;\n        }\n\n        return {\n          value: record.arg,\n          done: context.done\n        };\n\n      }\n    }\n  };\n}\n</code></pre>\n<p>基本的执行过程就不分析了，我们重点看第三次执行 <code>hw.next()</code> 的时候:</p>\n<p>第三次执行 <code>hw.next()</code> 的时候，其实执行了</p>\n<pre><code class=\"language-js\">this._invoke(&quot;next&quot;, undefined);\n</code></pre>\n<p>我们在 invoke 函数中构建了一个 record 对象：</p>\n<pre><code class=\"language-js\">var record = {\n  type: &quot;normal&quot;,\n  arg: innerFn.call(self, context)\n};\n</code></pre>\n<p>而在 <code>innerFn.call(self, context)</code> 中，因为 _context.next 为 4 的缘故，其实执行了:</p>\n<pre><code class=\"language-js\">_context.abrupt(&quot;return&quot;, 'ending');\n</code></pre>\n<p>而在 abrupt 中，我们又构建了一个 record 对象：</p>\n<pre><code class=\"language-js\">var record = {};\nrecord.type = 'return';\nrecord.arg = 'ending';\n</code></pre>\n<p>然后执行了 <code>this.complete(record)</code>，</p>\n<p>在 complete 中，因为 <code>record.type === &quot;return&quot;</code></p>\n<pre><code class=\"language-js\">this.rval = 'ending';\nthis.method = &quot;return&quot;;\nthis.next = &quot;end&quot;;\n</code></pre>\n<p>然后返回了全局对象 ContinueSentinel，其实就是一个全局空对象。</p>\n<p>然后在 invoke 函数中，因为 <code>record.arg === ContinueSentinel</code> 的缘故，没有执行后面的 return 语句，就直接进入下一个循环。</p>\n<p>于是又执行了一遍 <code>innerFn.call(self, context)</code>，此时 <code>_context.next</code> 为 end, 执行了 <code>_context.stop()</code>, 在 stop 函数中：</p>\n<pre><code class=\"language-js\">this.done = true;\nreturn this.rval; // this.rval 其实就是 `ending`\n</code></pre>\n<p>所以最终返回的值为:</p>\n<pre><code class=\"language-js\">{\n  value: 'ending',\n  done: true\n};\n</code></pre>\n<p>之后，我们再执行 hw.next() 的时候，因为 state 已经是 'completed' 的缘故，直接就返回 <code>{ value: undefined, done: true}</code></p>\n<h2>不完整但可用的源码</h2>\n<p>当然这个过程，看文字理解起来可能有些难度，不完整但可用的代码如下，你可以断点调试查看具体的过程：</p>\n<pre><code class=\"language-js\">(function() {\n  var ContinueSentinel = {};\n\n  var mark = function(genFun) {\n    var generator = Object.create({\n      next: function(arg) {\n        return this._invoke(&quot;next&quot;, arg);\n      }\n    });\n    genFun.prototype = generator;\n    return genFun;\n  };\n\n  function wrap(innerFn, outerFn, self) {\n    var generator = Object.create(outerFn.prototype);\n\n    var context = {\n      done: false,\n      method: &quot;next&quot;,\n      next: 0,\n      prev: 0,\n      abrupt: function(type, arg) {\n        var record = {};\n        record.type = type;\n        record.arg = arg;\n\n        return this.complete(record);\n      },\n      complete: function(record, afterLoc) {\n        if (record.type === &quot;return&quot;) {\n          this.rval = this.arg = record.arg;\n          this.method = &quot;return&quot;;\n          this.next = &quot;end&quot;;\n        }\n\n        return ContinueSentinel;\n      },\n      stop: function() {\n        this.done = true;\n        return this.rval;\n      }\n    };\n\n    generator._invoke = makeInvokeMethod(innerFn, context);\n\n    return generator;\n  }\n\n  function makeInvokeMethod(innerFn, context) {\n    var state = &quot;start&quot;;\n\n    return function invoke(method, arg) {\n      if (state === &quot;completed&quot;) {\n        return { value: undefined, done: true };\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        state = &quot;executing&quot;;\n\n        var record = {\n          type: &quot;normal&quot;,\n          arg: innerFn.call(self, context)\n        };\n\n        if (record.type === &quot;normal&quot;) {\n          state = context.done ? &quot;completed&quot; : &quot;yield&quot;;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n      }\n    };\n  }\n\n  window.regeneratorRuntime = {};\n\n  regeneratorRuntime.wrap = wrap;\n  regeneratorRuntime.mark = mark;\n})();\n\nvar _marked = regeneratorRuntime.mark(helloWorldGenerator);\n\nfunction helloWorldGenerator() {\n  return regeneratorRuntime.wrap(\n    function helloWorldGenerator$(_context) {\n      while (1) {\n        switch ((_context.prev = _context.next)) {\n          case 0:\n            _context.next = 2;\n            return &quot;hello&quot;;\n\n          case 2:\n            _context.next = 4;\n            return &quot;world&quot;;\n\n          case 4:\n            return _context.abrupt(&quot;return&quot;, &quot;ending&quot;);\n\n          case 5:\n          case &quot;end&quot;:\n            return _context.stop();\n        }\n      }\n    },\n    _marked,\n    this\n  );\n}\n\nvar hw = helloWorldGenerator();\n\nconsole.log(hw.next());\nconsole.log(hw.next());\nconsole.log(hw.next());\nconsole.log(hw.next());\n</code></pre>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}