{"code":0,"data":"<h2>前言</h2>\n<p>本篇接着上篇 <a href=\"https://github.com/mqyqingfeng/Blog/issues/63\">underscore 系列之实现一个模板引擎(上)</a>。</p>\n<p>鉴于本篇涉及的知识点太多，我们先来介绍下会用到的知识点。</p>\n<h2>反斜杠的作用</h2>\n<pre><code class=\"language-js\">var txt = &quot;We are the so-called &quot;Vikings&quot; from the north.&quot;\nconsole.log(txt);\n</code></pre>\n<p>我们的本意是想打印带 <code>&quot;&quot;</code> 包裹的 <code>Vikings</code> 字符串，但是在 JavaScript 中，字符串使用单引号或者双引号来表示起始或者结束，这段代码会报 <code>Unexpected identifier</code> 错误。</p>\n<p>如果我们就是想要在字符串中使用单引号或者双引号呢？</p>\n<p>我们可以使用反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符：</p>\n<pre><code class=\"language-js\">var txt = &quot;We are the so-called \\&quot;Vikings\\&quot; from the north.&quot;\nconsole.log(txt);\n</code></pre>\n<p>现在 JavaScript 就可以输出正确的文本字符串了。</p>\n<p><strong>这种由反斜杠后接字母或数字组合构成的字符组合就叫做“转义序列”。</strong></p>\n<p>值得注意的是，转义序列会被视为单个字符。</p>\n<p>我们常见的转义序列还有 <code>\\n</code> 表示换行、<code>\\t</code> 表示制表符、<code>\\r</code> 表示回车等等。</p>\n<h2>转义序列</h2>\n<p>在 JavaScript 中，字符串值是一个由零或多个 Unicode 字符（字母、数字和其他字符）组成的序列。</p>\n<p>字符串中的每个字符均可由一个转义序列表示。比如字母 <code>a</code>，也可以用转义序列 <code>\\u0061</code> 表示。</p>\n<blockquote>\n<p>转义序列以反斜杠 <code>\\</code> 开头，它的作用是告知 JavaScript 解释器下一个字符是特殊字符。</p>\n</blockquote>\n<blockquote>\n<p>转义序列的语法为 <code>\\uhhhh</code>，其中 hhhh 是四位十六进制数。</p>\n</blockquote>\n<p>根据这个规则，我们可以算出常见字符的转义序列，以字母 <code>m</code> 为例：</p>\n<pre><code class=\"language-js\">// 1. 求出字符 `m` 对应的 unicode 值\nvar unicode = 'm'.charCodeAt(0) // 109\n// 2. 转成十六进制\nvar result = unicode.toString(16); // &quot;6d&quot;\n</code></pre>\n<p>我们就可以使用 <code>\\u006d</code> 表示 <code>m</code>，不信你可以直接在浏览器命令行中直接输入字符串 <code>'\\u006d'</code>，看下打印结果。</p>\n<p>值得注意的是: <code>\\n</code> 虽然也是一种转义序列，但是也可以使用上面的方式：</p>\n<pre><code class=\"language-js\">var unicode = '\\n'.charCodeAt(0) // 10\nvar result = unicode.toString(16); // &quot;a&quot;\n</code></pre>\n<p>所以我们可以用 <code>\\u000A</code> 来表示换行符 <code>\\n</code>，比如在浏览器命令行中直接输入 <code>'a \\n b'</code> 和 <code>'a \\u000A b'</code> 效果是一样的。</p>\n<p>讲了这么多，我们来看看一些常用字符的转义序列以及含义：</p>\n<p>&lt;table&gt;\n&lt;tr&gt;\n&lt;td&gt;Unicode 字符值&lt;/td&gt;\n&lt;td&gt;转义序列&lt;/td&gt;\n&lt;td&gt;含义&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u0009&lt;/td&gt;\n&lt;td&gt;\\t&lt;/td&gt;\n&lt;td&gt;制表符&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u000A&lt;/td&gt;\n&lt;td&gt;\\n&lt;/td&gt;\n&lt;td&gt;换行&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u000D&lt;/td&gt;\n&lt;td&gt;\\r&lt;/td&gt;\n&lt;td&gt;回车&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u0022&lt;/td&gt;\n&lt;td&gt;&quot;&lt;/td&gt;\n&lt;td&gt;双引号&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u0027&lt;/td&gt;\n&lt;td&gt;'&lt;/td&gt;\n&lt;td&gt;单引号&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u005C&lt;/td&gt;\n&lt;td&gt;\\&lt;/td&gt;\n&lt;td&gt;反斜杠&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u2028&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;行分隔符&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;\\u2029&lt;/td&gt;\n&lt;td&gt;&lt;/td&gt;\n&lt;td&gt;段落分隔符&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;</p>\n<h2>Line Terminators</h2>\n<p>Line Terminators，中文译文<code>行终结符</code>。像空白字符一样，<code>行终结符</code>可用于改善源文本的可读性。</p>\n<p>在 ES5 中，有四个字符被认为是<code>行终结符</code>，其他的折行字符都会被视为空白。</p>\n<p>这四个字符如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>字符编码值</th>\n<th style=\"text-align:center\">名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\u000A</td>\n<td style=\"text-align:center\">换行符</td>\n</tr>\n<tr>\n<td>\\u000D</td>\n<td style=\"text-align:center\">回车符</td>\n</tr>\n<tr>\n<td>\\u2028</td>\n<td style=\"text-align:center\">行分隔符</td>\n</tr>\n<tr>\n<td>\\u2029</td>\n<td style=\"text-align:center\">段落分隔符</td>\n</tr>\n</tbody>\n</table>\n<h2>Function</h2>\n<p>试想我们写这样一段代码，能否正确运行：</p>\n<pre><code class=\"language-js\">var log = new Function(&quot;var a = '1\\t23';console.log(a)&quot;);\nlog()\n</code></pre>\n<p>答案是可以，那下面这段呢：</p>\n<pre><code class=\"language-js\">var log = new Function(&quot;var a = '1\\n23';console.log(a)&quot;);\nlog()\n</code></pre>\n<p>答案是不可以，会报错 <code>Uncaught SyntaxError: Invalid or unexpected token</code>。</p>\n<p>这是为什么呢？</p>\n<p>这是因为在 Function 构造函数的实现中，首先会将函数体代码字符串进行一次 <code>ToString</code> 操作，这时候字符串变成了：</p>\n<pre><code>var a = '1\n23';console.log(a)\n</code></pre>\n<p>然后再检测代码字符串是否符合代码规范，在 JavaScript 中，<strong>字符串表达式中是不允许换行的</strong>，这就导致了报错。</p>\n<p>为了避免这个问题，我们需要将代码修改为：</p>\n<pre><code class=\"language-js\">var log = new Function(&quot;var a = '1\\\\n23';console.log(a)&quot;);\nlog()\n</code></pre>\n<p>其实不止 <code>\\n</code>，其他三种 <code>行终结符</code>，如果你在字符串表达式中直接使用，都会导致报错！</p>\n<p>之所以讲这个问题，是因为在模板引擎的实现中，就是使用了 Function 构造函数，如果我们在模板字符串中使用了 <code>行终结符</code>，便有可能会出现一样的错误，所以我们必须要对这四种 <code>行终结符</code> 进行特殊的处理。</p>\n<h2>特殊字符</h2>\n<p>除了这四种 <code>行终结符</code> 之外，我们还要对两个字符进行处理。</p>\n<p>一个是 <code>\\</code>。</p>\n<p>比如说我们的模板内容中使用了<code>\\</code>:</p>\n<pre><code class=\"language-js\">var log = new Function(&quot;var a = '1\\23';console.log(a)&quot;);\nlog(); // 1\n</code></pre>\n<p>其实我们是想打印 '1\\23'，但是因为把 <code>\\</code> 当成了特殊字符的标记进行处理，所以最终打印了 1。</p>\n<p>同样的道理，如果我们在使用模板引擎的时候，使用了 <code>\\</code> 字符串，也会导致错误的处理。</p>\n<p>第二个是 <code>'</code>。</p>\n<p>如果我们在模板引擎中使用了 <code>'</code>，因为我们会拼接诸如 <code>p.push('</code> <code>')</code> 等字符串，因为 <code>'</code> 的原因，字符串会被错误拼接，也会导致错误。</p>\n<p>所以总共我们需要对六种字符进行特殊处理，处理的方式，就是正则匹配出这些特殊字符，然后比如将 <code>\\n</code> 替换成 <code>\\\\n</code>，<code>\\</code> 替换成 <code>\\\\</code>，<code>'</code> 替换成 <code>\\\\'</code>，处理的代码为：</p>\n<pre><code class=\"language-js\">var escapes = {\n    &quot;'&quot;: &quot;'&quot;,\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n};\n\nvar escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nvar escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n};\n</code></pre>\n<p>我们测试一下：</p>\n<pre><code class=\"language-js\">var str = 'console.log(&quot;I am \\n Kevin&quot;);';\nvar newStr = str.replace(escapeRegExp, escapeChar);\n\neval(newStr)\n// I am \n// Kevin\n</code></pre>\n<h2>replace</h2>\n<p>我们来讲一讲字符串的 replace 函数：</p>\n<p>语法为：</p>\n<pre><code>str.replace(regexp|substr, newSubStr|function)\n</code></pre>\n<p>replace 的第一个参数，可以传一个字符串，也可以传一个正则表达式。</p>\n<p>第二个参数，可以传一个新字符串，也可以传一个函数。</p>\n<p>我们重点看下传入函数的情况，简单举一个例子：</p>\n<pre><code class=\"language-js\">var str = 'hello world';\nvar newStr = str.replace('world', function(match){\n    return match + '!'\n})\nconsole.log(newStr); // hello world!\n</code></pre>\n<p>match 表示匹配到的字符串，但函数的参数其实不止有 match，我们看个更复杂的例子：</p>\n<pre><code class=\"language-js\">function replacer(match, p1, p2, p3, offset, string) {\n    // match，表示匹配的子串 abc12345#$*%\n    // p1，第 1 个括号匹配的字符串 abc\n    // p2，第 2 个括号匹配的字符串 12345\n    // p3，第 3 个括号匹配的字符串 #$*%\n    // offset，匹配到的子字符串在原字符串中的偏移量 0\n    // string，被匹配的原字符串 abc12345#$*%\n    return [p1, p2, p3].join(' - ');\n}\nvar newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); // abc - 12345 - #$*%\n</code></pre>\n<p>另外要注意的是，如果第一个参数是正则表达式，并且其为全局匹配模式， 那么这个方法将被多次调用，每次匹配都会被调用。</p>\n<p>举个例子，如果我们要在一段字符串中匹配出 <code>&lt;%=xxx%&gt;</code> 中的值：</p>\n<pre><code class=\"language-js\">var str = '&lt;li&gt;&lt;a href=&quot;&lt;%=www.baidu.com%&gt;&quot;&gt;&lt;%=baidu%&gt;&lt;/a&gt;&lt;/li&gt;'\n\nstr.replace(/&lt;%=(.+?)%&gt;/g, function(match, p1, offset, string){\n    console.log(match);\n    console.log(p1);\n    console.log(offset);\n    console.log(string);\n})\n</code></pre>\n<p>传入的函数会被执行两次，第一次的打印结果为：</p>\n<pre><code>&lt;%=www.baidu.com%&gt;\nwww.baidu.com\n13\n&lt;li&gt;&lt;a href=&quot;&lt;%=www.baidu.com%&gt;&quot;&gt;&lt;%=baidu%&gt;&lt;/a&gt;&lt;/li&gt;\n</code></pre>\n<p>第二次的打印结果为：</p>\n<pre><code>&lt;%=baidu%&gt;\n'baidu'\n33\n&lt;li&gt;&lt;a href=&quot;&lt;%=www.baidu.com%&gt;&quot;&gt;&lt;%=baidu%&gt;&lt;/a&gt;&lt;/li&gt;\n</code></pre>\n<h2>正则表达式的创建</h2>\n<p>当我们要建立一个正则表达式的时候，我们可以直接创建：</p>\n<pre><code class=\"language-js\">var reg = /ab+c/i;\n</code></pre>\n<p>也可以使用构造函数的方式：</p>\n<pre><code class=\"language-js\">new RegExp('ab+c', 'i');\n</code></pre>\n<p>值得一提的是：每个正则表达式对象都有一个 source 属性，返回当前正则表达式对象的模式文本的字符串：</p>\n<pre><code class=\"language-js\">var regex = /fooBar/ig;\nconsole.log(regex.source); // &quot;fooBar&quot;，不包含 /.../ 和 &quot;ig&quot;。\n</code></pre>\n<h2>正则表达式的特殊字符</h2>\n<p>正则表达式中有一些特殊字符，比如 <code>\\d</code> 就表示了匹配一个数字，等价于 [0-9]。</p>\n<p>在上节，我们使用 <code>/&lt;%=(.+?)%&gt;/g</code> 来匹配 <code>&lt;%=xxx%&gt;</code>，然而在 underscore 的实现中，用的却是 <code>/&lt;%=([\\s\\S]+?)%&gt;/g</code>。</p>\n<p>我们知道 \\s 表示匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格，\\S\n匹配一个非空白符，[\\s\\S]就表示匹配所有的内容，可是为什么我们不直接使用 <code>.</code> 呢？</p>\n<p>我们可能以为 <code>.</code> 匹配任意单个字符，实际上，并不是如此， <code>.</code>匹配除<code>行终结符</code>之外的任何单个字符，不信我们做个试验：</p>\n<pre><code class=\"language-js\">var str = '&lt;%=hello world%&gt;'\n\nstr.replace(/&lt;%=(.+?)%&gt;/g, function(match){\n    console.log(match); // &lt;%=hello world%&gt;\n})\n</code></pre>\n<p>但是如果我们在 hello world 之间加上一个<code>行终结符</code>，比如说 '\\u2029'：</p>\n<pre><code class=\"language-js\">var str = '&lt;%=hello \\u2029 world%&gt;'\n\nstr.replace(/&lt;%=(.+?)%&gt;/g, function(match){\n    console.log(match);\n})\n</code></pre>\n<p>因为匹配不到，所以也不会执行 console.log 函数。</p>\n<p>但是改成 <code>/&lt;%=([\\s\\S]+?)%&gt;/g</code> 就可以正常匹配：</p>\n<pre><code class=\"language-js\">var str = '&lt;%=hello \\u2029 world%&gt;'\n\nstr.replace(/&lt;%=([\\s\\S]+?)%&gt;/g, function(match){\n    console.log(match); // &lt;%=hello   world%&gt;\n})\n</code></pre>\n<h2>惰性匹配</h2>\n<p>仔细看 <code>/&lt;%=([\\s\\S]+?)%&gt;/g</code> 这个正则表达式，我们知道 <code>x+</code> 表示匹配 <code>x</code> 1 次或多次。<code>x?</code>表示匹配 <code>x</code> 0 次或 1 次，但是 <code>+?</code> 是个什么鬼？</p>\n<p>实际上，如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化。反之，默认情况下，是贪婪的（greedy），即匹配次数最大化。</p>\n<p>举个例子：</p>\n<pre><code>console.log(&quot;aaabc&quot;.replace(/a+/g, &quot;d&quot;)); // dbc\n\nconsole.log(&quot;aaabc&quot;.replace(/a+?/g, &quot;d&quot;)); // dddbc\n</code></pre>\n<p>在这里我们应该使用非惰性匹配，举个例子：</p>\n<pre><code class=\"language-js\">var str = '&lt;li&gt;&lt;a href=&quot;&lt;%=www.baidu.com%&gt;&quot;&gt;&lt;%=baidu%&gt;&lt;/a&gt;&lt;/li&gt;'\n\nstr.replace(/&lt;%=(.+?)%&gt;/g, function(match){\n    console.log(match);\n})\n\n// &lt;%=www.baidu.com%&gt;\n// &lt;%=baidu%&gt;\n</code></pre>\n<p>如果我们使用惰性匹配：</p>\n<pre><code class=\"language-js\">var str = '&lt;li&gt;&lt;a href=&quot;&lt;%=www.baidu.com%&gt;&quot;&gt;&lt;%=baidu%&gt;&lt;/a&gt;&lt;/li&gt;'\n\nstr.replace(/&lt;%=(.+)%&gt;/g, function(match){\n    console.log(match);\n})\n\n// &lt;%=www.baidu.com%&gt;&quot;&gt;&lt;%=baidu%&gt;\n</code></pre>\n<h2>template</h2>\n<p>讲完需要的知识点，我们开始讲 underscore 模板引擎的实现。</p>\n<p>与我们上篇使用数组的 push ，最后再 join 的方法不同，underscore 使用的是字符串拼接的方式。</p>\n<p>比如下面这样一段模板字符串：</p>\n<pre><code>&lt;%for ( var i = 0; i &lt; users.length; i++ ) { %&gt;\n    &lt;li&gt;\n        &lt;a href=&quot;&lt;%=users[i].url%&gt;&quot;&gt;\n            &lt;%=users[i].name%&gt;\n        &lt;/a&gt;\n    &lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n<p>我们先将 <code>&lt;%=xxx%&gt;</code> 替换成 <code>'+ xxx +'</code>，再将 <code>&lt;%xxx%&gt;</code> 替换成 <code>'; xxx __p+='</code>:</p>\n<pre><code>';for ( var i = 0; i &lt; users.length; i++ ) { __p+='\n    &lt;li&gt;\n        &lt;a href=&quot;'+ users[i].url + '&quot;&gt;\n            '+ users[i].name +'\n        &lt;/a&gt;\n    &lt;/li&gt;\n';  } __p+='\n</code></pre>\n<p>这段代码肯定会运行错误的，所以我们再添加些头尾代码，然后组成一个完整的代码字符串：</p>\n<pre><code>var __p='';\nwith(obj){\n__p+='\n\n';for ( var i = 0; i &lt; users.length; i++ ) { __p+='\n    &lt;li&gt;\n        &lt;a href=&quot;'+ users[i].url + '&quot;&gt;\n            '+ users[i].name +'\n        &lt;/a&gt;\n    &lt;/li&gt;\n';  } __p+='\n\n';\n};\nreturn __p;\n</code></pre>\n<p>整理下代码就是：</p>\n<pre><code class=\"language-js\">var __p='';\nwith(obj){\n    __p+='';\n    for ( var i = 0; i &lt; users.length; i++ ) { \n        __p+='&lt;li&gt;&lt;a href=&quot;'+ users[i].url + '&quot;&gt; '+ users[i].name +'&lt;/a&gt;&lt;/li&gt;';\n    }\n    __p+='';\n};\nreturn __p\n</code></pre>\n<p>然后我们将 <code>__p</code> 这段代码字符串传入 Function 构造函数中：</p>\n<pre><code class=\"language-js\">var render = new Function(data, __p)\n</code></pre>\n<p>我们执行这个 render 函数，传入需要的 data 数据，就可以返回一段 HTML 字符串：</p>\n<pre><code class=\"language-js\">render(data)\n</code></pre>\n<h2>第五版 - 特殊字符的处理</h2>\n<p>我们接着上篇的<a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template4\">第四版</a>进行书写，不过加入对特殊字符的转义以及使用字符串拼接的方式：</p>\n<pre><code class=\"language-js\">// 第五版\nvar settings = {\n    // 求值\n    evaluate: /&lt;%([\\s\\S]+?)%&gt;/g,\n    // 插入\n    interpolate: /&lt;%=([\\s\\S]+?)%&gt;/g,\n};\n\nvar escapes = {\n    &quot;'&quot;: &quot;'&quot;,\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n};\n\nvar escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nvar template = function(text) {\n\n    var source = &quot;var __p='';\\n&quot;;\n    source = source + &quot;with(obj){\\n&quot;\n    source = source + &quot;__p+='&quot;;\n\n    var main = text\n    .replace(escapeRegExp, function(match) {\n        return '\\\\' + escapes[match];\n    })\n    .replace(settings.interpolate, function(match, interpolate){\n        return &quot;'+\\n&quot; + interpolate + &quot;+\\n'&quot;\n    })\n    .replace(settings.evaluate, function(match, evaluate){\n        return &quot;';\\n &quot; + evaluate + &quot;\\n__p+='&quot;\n    })\n\n    source = source + main + &quot;';\\n }; \\n return __p;&quot;;\n\n    console.log(source)\n\n    var render = new Function('obj',  source);\n\n    return render;\n};\n</code></pre>\n<p>完整的使用代码可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template5\">template 示例五</a>。</p>\n<h2>第六版 - 特殊值的处理</h2>\n<p>不过有一点需要注意的是：</p>\n<p>如果数据中 <code>users[i].url</code> 不存在怎么办？此时取值的结果为 undefined，我们知道：</p>\n<pre><code class=\"language-js\">'1' + undefined // &quot;1undefined&quot;\n</code></pre>\n<p>就相当于拼接了 undefined 字符串，这肯定不是我们想要的。我们可以在代码中加入一点判断：</p>\n<pre><code class=\"language-js\">.replace(settings.interpolate, function(match, interpolate){\n    return &quot;'+\\n&quot; + (interpolate == null ? '' : interpolate) + &quot;+\\n'&quot;\n})\n</code></pre>\n<p>但是吧，我就是不喜欢写两遍 interpolate …… 嗯？那就这样吧：</p>\n<pre><code class=\"language-js\">var source = &quot;var __t, __p='';\\n&quot;;\n\n...\n\n.replace(settings.interpolate, function(match, interpolate){\n    return &quot;'+\\n((__t=(&quot; + interpolate + &quot;))==null?'':__t)+\\n'&quot;\n})\n</code></pre>\n<p>其实就相当于：</p>\n<pre><code class=\"language-js\">var __t;\n\nvar result = (__t = interpolate) == null ? '' : __t;\n</code></pre>\n<p>完整的使用代码可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template6\">template 示例六</a>。</p>\n<h2>第七版</h2>\n<p>现在我们使用的方式是将模板字符串进行多次替换，然而在 underscore 的实现中，只进行了一次替换，我们来看看 underscore 是怎么实现的：</p>\n<pre><code class=\"language-js\">var template = function(text) {\n    var matcher = RegExp([\n        (settings.interpolate).source,\n        (settings.evaluate).source\n    ].join('|') + '|$', 'g');\n\n    var index = 0;\n    var source = &quot;__p+='&quot;;\n\n    text.replace(matcher, function(match, interpolate, evaluate, offset) {\n        source += text.slice(index, offset).replace(escapeRegExp, function(match) {\n            return '\\\\' + escapes[match];\n        });\n\n        index = offset + match.length;\n\n        if (interpolate) {\n            source += &quot;'+\\n((__t=(&quot; + interpolate + &quot;))==null?'':__t)+\\n'&quot;;\n        } else if (evaluate) {\n            source += &quot;';\\n&quot; + evaluate + &quot;\\n__p+='&quot;;\n        }\n\n        return match;\n    });\n\n    source += &quot;';\\n&quot;;\n\n    source = 'with(obj||{}){\\n' + source + '}\\n'\n\n    source = &quot;var __t, __p='';&quot; +\n        source + 'return __p;\\n';\n\n    var render = new Function('obj', source);\n\n    return render;\n};\n</code></pre>\n<p>其实原理也很简单，就是在执行多次匹配函数的时候，不断复制字符串，处理字符串，拼接字符串，最后拼接首尾代码，得到最终的代码字符串。</p>\n<p>不过值得一提的是：在这段代码里，matcher 的表达式最后为：<code>/&lt;%=([\\s\\S]+?)%&gt;|&lt;%([\\s\\S]+?)%&gt;|$/g</code></p>\n<p>问题是为什么还要加个 <code>|$</code> 呢？我们来看下 $：</p>\n<pre><code class=\"language-js\">var str = &quot;abc&quot;;\nstr.replace(/$/g, function(match, offset){\n    console.log(typeof match) // 空字符串\n    console.log(offset) // 3\n    return match\n})\n</code></pre>\n<p>我们之所以匹配 $，是为了获取最后一个字符串的位置，这样当我们 text.slice(index, offset)的时候，就可以截取到最后一个字符。</p>\n<p>完整的使用代码可以参考 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template7\">template 示例七</a>。</p>\n<h2>最终版</h2>\n<p>其实代码写到这里，就已经跟 underscore 的实现很接近了，只是 underscore 加入了更多细节的处理，比如：</p>\n<ol>\n<li>对数据的转义功能</li>\n<li>可传入配置项</li>\n<li>对错误的处理</li>\n<li>添加 source 属性，以方便查看代码字符串</li>\n<li>添加了方便调试的 print 函数</li>\n<li>...</li>\n</ol>\n<p>但是这些内容都还算简单，就不一版一版写了，最后的版本在 <a href=\"https://github.com/mqyqingfeng/Blog/tree/master/demos/template/template8\">template 示例八</a>，如果对其中有疑问，欢迎留言讨论。</p>\n<h2>underscore 系列</h2>\n<p>underscore 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>underscore 系列预计写八篇左右，重点介绍 underscore 中的代码架构、链式调用、内部函数、模板引擎等内容，旨在帮助大家阅读源码，以及写出自己的 undercore。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}