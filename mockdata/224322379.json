{"code":0,"data":"<h1>前言</h1>\n<p>在<a href=\"https://github.com/mqyqingfeng/Blog/issues/4\">《JavaScript深入之执行上下文栈》</a>中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>\n<p>对于每个执行上下文，都有三个重要属性：</p>\n<ul>\n<li>变量对象(Variable object，VO)</li>\n<li>作用域链(Scope chain)</li>\n<li>this</li>\n</ul>\n<p>然后分别在<a href=\"https://github.com/mqyqingfeng/Blog/issues/5\">《JavaScript深入之变量对象》</a>、<a href=\"https://github.com/mqyqingfeng/Blog/issues/6\">《JavaScript深入之作用域链》</a>、<a href=\"https://github.com/mqyqingfeng/Blog/issues/7\">《JavaScript深入之从ECMAScript规范解读this》</a>中讲解了这三个属性。</p>\n<p>阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。</p>\n<p>因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。</p>\n<h2>思考题</h2>\n<p>在<a href=\"https://github.com/mqyqingfeng/Blog/issues/3\">《JavaScript深入之词法作用域和动态作用域》</a>中，提出这样一道思考题：</p>\n<pre><code class=\"language-js\">var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n</code></pre>\n<pre><code class=\"language-js\">var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n</code></pre>\n<p>两段代码都会打印'local scope'。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p>\n<p>紧接着就在下一篇<a href=\"https://github.com/mqyqingfeng/Blog/issues/4\">《JavaScript深入之执行上下文栈》</a>中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。</p>\n<h2>具体执行分析</h2>\n<p>我们分析第一段代码：</p>\n<pre><code class=\"language-js\">var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n</code></pre>\n<p>执行过程如下：</p>\n<p>1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</p>\n<pre><code class=\"language-js\">    ECStack = [\n        globalContext\n    ];\n</code></pre>\n<p>2.全局上下文初始化</p>\n<pre><code class=\"language-js\">    globalContext = {\n        VO: [global],\n        Scope: [globalContext.VO],\n        this: globalContext.VO\n    }\n</code></pre>\n<p>2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</p>\n<pre><code class=\"language-js\">    checkscope.[[scope]] = [\n      globalContext.VO\n    ];\n</code></pre>\n<p>3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>\n<pre><code class=\"language-js\">    ECStack = [\n        checkscopeContext,\n        globalContext\n    ];\n</code></pre>\n<p>4.checkscope 函数执行上下文初始化：</p>\n<ol>\n<li>复制函数 [[scope]] 属性创建作用域链，</li>\n<li>用 arguments 创建活动对象，</li>\n<li>初始化活动对象，即加入形参、函数声明、变量声明，</li>\n<li>将活动对象压入 checkscope 作用域链顶端。</li>\n</ol>\n<p>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</p>\n<pre><code class=\"language-js\">    checkscopeContext = {\n        AO: {\n            arguments: {\n                length: 0\n            },\n            scope: undefined,\n            f: reference to function f(){}\n        },\n        Scope: [AO, globalContext.VO],\n        this: undefined\n    }\n</code></pre>\n<p>5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</p>\n<pre><code class=\"language-js\">    ECStack = [\n        fContext,\n        checkscopeContext,\n        globalContext\n    ];\n</code></pre>\n<p>6.f 函数执行上下文初始化, 以下跟第 4 步相同：</p>\n<ol>\n<li>复制函数 [[scope]] 属性创建作用域链</li>\n<li>用 arguments 创建活动对象</li>\n<li>初始化活动对象，即加入形参、函数声明、变量声明</li>\n<li>将活动对象压入 f 作用域链顶端</li>\n</ol>\n<pre><code class=\"language-js\">    fContext = {\n        AO: {\n            arguments: {\n                length: 0\n            }\n        },\n        Scope: [AO, checkscopeContext.AO, globalContext.VO],\n        this: undefined\n    }\n</code></pre>\n<p>7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p>\n<p>8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p>\n<pre><code class=\"language-js\">    ECStack = [\n        checkscopeContext,\n        globalContext\n    ];\n</code></pre>\n<p>9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</p>\n<pre><code class=\"language-js\">    ECStack = [\n        globalContext\n    ];\n</code></pre>\n<p>第二段代码就留给大家去尝试模拟它的执行过程。</p>\n<pre><code class=\"language-js\">var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n</code></pre>\n<p>不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。</p>\n<h2>下一篇文章</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/9\">《JavaScript深入之闭包》</a></p>\n<h2>相关链接</h2>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/3\">《JavaScript深入之词法作用域和动态作用域》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/4\">《JavaScript深入之执行上下文栈》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/5\">《JavaScript深入之变量对象》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/6\">《JavaScript深入之作用域链》</a></p>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/7\">《JavaScript深入之从ECMAScript规范解读this》</a></p>\n<h2>重要参考</h2>\n<p><a href=\"https://github.com/kuitos/kuitos.github.io/issues/18\">《一道js面试题引发的思考》</a></p>\n<p>本文写的太好，给了我很多启发。感激不尽！</p>\n<h2>深入系列</h2>\n<p>JavaScript深入系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a>。</p>\n<p>JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。</p>\n"}