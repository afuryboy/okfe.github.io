{"code":0,"data":"<h2>单个异步任务</h2>\n<pre><code class=\"language-js\">var fetch = require('node-fetch');\n\nfunction* gen(){\n    var url = 'https://api.github.com/users/github';\n    var result = yield fetch(url);\n    console.log(result.bio);\n}\n</code></pre>\n<p>为了获得最终的执行结果，你需要这样做：</p>\n<pre><code class=\"language-js\">var g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n    return data.json();\n}).then(function(data){\n    g.next(data);\n});\n</code></pre>\n<p>首先执行 Generator 函数，获取遍历器对象。</p>\n<p>然后使用 next 方法，执行异步任务的第一阶段，即 fetch(url)。</p>\n<p>注意，由于 fetch(url) 会返回一个 Promise 对象，所以 result 的值为：</p>\n<pre><code class=\"language-jsx\">{ value: Promise { &lt;pending&gt; }, done: false }\n</code></pre>\n<p>最后我们为这个 Promise 对象添加一个 then 方法，先将其返回的数据格式化(<code>data.json()</code>)，再调用 g.next，将获得的数据传进去，由此可以执行异步任务的第二阶段，代码执行完毕。</p>\n<h2>多个异步任务</h2>\n<p>上节我们只调用了一个接口，那如果我们调用了多个接口，使用了多个 yield，我们岂不是要在 then 函数中不断的嵌套下去……</p>\n<p>所以我们来看看执行多个异步任务的情况：</p>\n<pre><code class=\"language-js\">var fetch = require('node-fetch');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var r2 = yield fetch('https://api.github.com/users/github/followers');\n    var r3 = yield fetch('https://api.github.com/users/github/repos');\n\n    console.log([r1.bio, r2[0].login, r3[0].full_name].join('\\n'));\n}\n</code></pre>\n<p>为了获得最终的执行结果，你可能要写成：</p>\n<pre><code class=\"language-js\">var g = gen();\nvar result1 = g.next();\n\nresult1.value.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value;\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    return g.next(data).value\n})\n.then(function(data){\n    return data.json();\n})\n.then(function(data){\n    g.next(data)\n});\n</code></pre>\n<p>但我知道你肯定不想写成这样……</p>\n<p>其实，利用递归，我们可以这样写：</p>\n<pre><code class=\"language-js\">function run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value.then(function(data) {\n            return data.json();\n        }).then(function(data) {\n            next(data);\n        });\n\n    }\n\n    next();\n}\n\nrun(gen);\n</code></pre>\n<p>其中的关键就是 yield 的时候返回一个 Promise 对象，给这个 Promise 对象添加 then 方法，当异步操作成功时执行 then 中的 onFullfilled 函数，onFullfilled 函数中又去执行 g.next，从而让 Generator 继续执行，然后再返回一个 Promise，再在成功时执行 g.next，然后再返回……</p>\n<h2>启动器函数</h2>\n<p>在 run 这个启动器函数中，我们在 then 函数中将数据格式化 <code>data.json()</code>，但在更广泛的情况下，比如 yield 直接跟一个 Promise，而非一个 fetch 函数返回的 Promise，因为没有 json 方法，代码就会报错。所以为了更具备通用性，连同这个例子和启动器，我们修改为：</p>\n<pre><code class=\"language-js\">var fetch = require('node-fetch');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var json1 = yield r1.json();\n    var r2 = yield fetch('https://api.github.com/users/github/followers');\n    var json2 = yield r2.json();\n    var r3 = yield fetch('https://api.github.com/users/github/repos');\n    var json3 = yield r3.json();\n\n    console.log([json1.bio, json2[0].login, json3[0].full_name].join('\\n'));\n}\n\nfunction run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value.then(function(data) {\n            next(data);\n        });\n\n    }\n\n    next();\n}\n\nrun(gen);\n</code></pre>\n<p>只要 yield 后跟着一个 Promise 对象，我们就可以利用这个 run 函数将 Generator 函数自动执行。</p>\n<h2>回调函数</h2>\n<p>yield 后一定要跟着一个 Promise 对象才能保证 Generator 的自动执行吗？如果只是一个回调函数呢？我们来看个例子：</p>\n<p>首先我们来模拟一个普通的异步请求：</p>\n<pre><code class=\"language-js\">function fetchData(url, cb) {\n    setTimeout(function(){\n        cb({status: 200, data: url})\n    }, 1000)\n}\n</code></pre>\n<p>我们将这种函数改造成：</p>\n<pre><code class=\"language-js\">function fetchData(url) {\n    return function(cb){\n        setTimeout(function(){\n            cb({status: 200, data: url})\n        }, 1000)\n    }\n}\n</code></pre>\n<p>对于这样的 Generator 函数：</p>\n<pre><code class=\"language-js\">function* gen() {\n    var r1 = yield fetchData('https://api.github.com/users/github');\n    var r2 = yield fetchData('https://api.github.com/users/github/followers');\n\n    console.log([r1.data, r2.data].join('\\n'));\n}\n</code></pre>\n<p>如果要获得最终的结果：</p>\n<pre><code class=\"language-js\">var g = gen();\n\nvar r1 = g.next();\n\nr1.value(function(data) {\n    var r2 = g.next(data);\n    r2.value(function(data) {\n        g.next(data);\n    });\n});\n</code></pre>\n<p>如果写成这样的话，我们会面临跟第一节同样的问题，那就是当使用多个 yield 时，代码会循环嵌套起来……</p>\n<p>同样利用递归，所以我们可以将其改造为：</p>\n<pre><code class=\"language-js\">function run(gen) {\n    var g = gen();\n\n    function next(data) {\n        var result = g.next(data);\n\n        if (result.done) return;\n\n        result.value(next);\n    }\n\n    next();\n}\n\nrun(gen);\n</code></pre>\n<h2>run</h2>\n<p>由此可以看到 Generator 函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权。</p>\n<p>而两种方法可以做到这一点。</p>\n<p>（1）回调函数。将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权。</p>\n<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</p>\n<p>在两种方法中，我们各写了一个 run 启动器函数，那我们能不能将这两种方式结合在一些，写一个通用的 run 函数呢？我们尝试一下：</p>\n<pre><code class=\"language-js\">// 第一版\nfunction run(gen) {\n    var gen = gen();\n\n    function next(data) {\n        var result = gen.next(data);\n        if (result.done) return;\n\n        if (isPromise(result.value)) {\n            result.value.then(function(data) {\n                next(data);\n            });\n        } else {\n            result.value(next)\n        }\n    }\n\n    next()\n}\n\nfunction isPromise(obj) {\n    return 'function' == typeof obj.then;\n}\n\nmodule.exports = run;\n</code></pre>\n<p>其实实现的很简单，判断 result.value 是否是 Promise，是就添加 then 函数，不是就直接执行。</p>\n<h2>return Promise</h2>\n<p>我们已经写了一个不错的启动器函数，支持 yield 后跟回调函数或者 Promise 对象。</p>\n<p>现在有一个问题需要思考，就是我们如何获得 Generator 函数的返回值呢？又如果 Generator 函数中出现了错误，就比如 fetch 了一个不存在的接口，这个错误该如何捕获呢？</p>\n<p>这很容易让人想到 Promise，如果这个启动器函数返回一个 Promise，我们就可以给这个 Promise 对象添加 then 函数，当所有的异步操作执行成功后，我们执行 onFullfilled 函数，如果有任何失败，就执行 onRejected 函数。</p>\n<p>我们写一版：</p>\n<pre><code class=\"language-js\">// 第二版\nfunction run(gen) {\n    var gen = gen();\n\n    return new Promise(function(resolve, reject) {\n\n        function next(data) {\n            try {\n                var result = gen.next(data);\n            } catch (e) {\n                return reject(e);\n            }\n\n            if (result.done) {\n                return resolve(result.value)\n            };\n\n            var value = toPromise(result.value);\n\n            value.then(function(data) {\n                next(data);\n            }, function(e) {\n                reject(e)\n            });\n        }\n\n        next()\n    })\n\n}\n\nfunction isPromise(obj) {\n    return 'function' == typeof obj.then;\n}\n\nfunction toPromise(obj) {\n    if (isPromise(obj)) return obj;\n    if ('function' == typeof obj) return thunkToPromise(obj);\n    return obj;\n}\n\nfunction thunkToPromise(fn) {\n    return new Promise(function(resolve, reject) {\n        fn(function(err, res) {\n            if (err) return reject(err);\n            resolve(res);\n        });\n    });\n}\n\nmodule.exports = run;\n</code></pre>\n<p>与第一版有很大的不同：</p>\n<p>首先，我们返回了一个 Promise，当 <code>result.done</code> 为 true 的时候，我们将该值 <code>resolve(result.value)</code>，如果执行的过程中出现错误，被 catch 住，我们会将原因 <code>reject(e)</code>。</p>\n<p>其次，我们会使用 <code>thunkToPromise</code> 将回调函数包装成一个 Promise，然后统一的添加 then 函数。在这里值得注意的是，在 <code>thunkToPromise</code> 函数中，我们遵循了 error first 的原则，这意味着当我们处理回调函数的情况时：</p>\n<pre><code class=\"language-js\">// 模拟数据请求\nfunction fetchData(url) {\n    return function(cb) {\n        setTimeout(function() {\n            cb(null, { status: 200, data: url })\n        }, 1000)\n    }\n}\n</code></pre>\n<p>在成功时，第一个参数应该返回 null，表示没有错误原因。</p>\n<h2>优化</h2>\n<p>我们在第二版的基础上将代码写的更加简洁优雅一点，最终的代码如下：</p>\n<pre><code class=\"language-js\">// 第三版\nfunction run(gen) {\n\n    return new Promise(function(resolve, reject) {\n        if (typeof gen == 'function') gen = gen();\n\n        // 如果 gen 不是一个迭代器\n        if (!gen || typeof gen.next !== 'function') return resolve(gen)\n\n        onFulfilled();\n\n        function onFulfilled(res) {\n            var ret;\n            try {\n                ret = gen.next(res);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function onRejected(err) {\n            var ret;\n            try {\n                ret = gen.throw(err);\n            } catch (e) {\n                return reject(e);\n            }\n            next(ret);\n        }\n\n        function next(ret) {\n            if (ret.done) return resolve(ret.value);\n            var value = toPromise(ret.value);\n            if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n            return onRejected(new TypeError('You may only yield a function, promise ' +\n                'but the following object was passed: &quot;' + String(ret.value) + '&quot;'));\n        }\n    })\n}\n\nfunction isPromise(obj) {\n    return 'function' == typeof obj.then;\n}\n\nfunction toPromise(obj) {\n    if (isPromise(obj)) return obj;\n    if ('function' == typeof obj) return thunkToPromise(obj);\n    return obj;\n}\n\nfunction thunkToPromise(fn) {\n    return new Promise(function(resolve, reject) {\n        fn(function(err, res) {\n            if (err) return reject(err);\n            resolve(res);\n        });\n    });\n}\n\nmodule.exports = run;\n</code></pre>\n<h2>co</h2>\n<p>如果我们再将这个启动器函数写的完善一些，我们就相当于写了一个 co，实际上，上面的代码确实是来自于 co……</p>\n<p>而 co 是什么？ co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。</p>\n<p>如果直接使用 co 模块，这两种不同的例子可以简写为：</p>\n<pre><code class=\"language-js\">// yield 后是一个 Promise\nvar fetch = require('node-fetch');\nvar co = require('co');\n\nfunction* gen() {\n    var r1 = yield fetch('https://api.github.com/users/github');\n    var json1 = yield r1.json();\n    var r2 = yield fetch('https://api.github.com/users/github/followers');\n    var json2 = yield r2.json();\n    var r3 = yield fetch('https://api.github.com/users/github/repos');\n    var json3 = yield r3.json();\n\n    console.log([json1.bio, json2[0].login, json3[0].full_name].join('\\n'));\n}\n\nco(gen);\n</code></pre>\n<pre><code class=\"language-js\">// yield 后是一个回调函数\nvar co = require('co');\n\nfunction fetchData(url) {\n    return function(cb) {\n        setTimeout(function() {\n            cb(null, { status: 200, data: url })\n        }, 1000)\n    }\n}\n\nfunction* gen() {\n    var r1 = yield fetchData('https://api.github.com/users/github');\n    var r2 = yield fetchData('https://api.github.com/users/github/followers');\n\n    console.log([r1.data, r2.data].join('\\n'));\n}\n\nco(gen);\n</code></pre>\n<p>是不是特别的好用？</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}