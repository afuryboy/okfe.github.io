{"code":0,"data":"<h2>前言</h2>\n<p>本文就是简单介绍下 Async 语法编译后的代码。</p>\n<h2>Async</h2>\n<pre><code class=\"language-js\">const fetchData = (data) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 1000, data + 1))\n\nconst fetchValue = async function () {\n    var value1 = await fetchData(1);\n    var value2 = await fetchData(value1);\n    var value3 = await fetchData(value2);\n    console.log(value3)\n};\n\nfetchValue();\n// 大约 3s 后输出 4\n</code></pre>\n<h2>Babel</h2>\n<p>我们直接在 Babel 官网的 <a href=\"https://babeljs.io/repl\">Try it out</a> 粘贴上述代码，然后查看代码编译成什么样子：</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;;\n\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function(resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(\n            function(value) {\n              step(&quot;next&quot;, value);\n            },\n            function(err) {\n              step(&quot;throw&quot;, err);\n            }\n          );\n        }\n      }\n      return step(&quot;next&quot;);\n    });\n  };\n}\n\nvar fetchData = function fetchData(data) {\n  return new Promise(function(resolve) {\n    return setTimeout(resolve, 1000, data + 1);\n  });\n};\n\nvar fetchValue = (function() {\n  var _ref = _asyncToGenerator(\n    /*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n      var value1, value2, value3;\n      return regeneratorRuntime.wrap(\n        function _callee$(_context) {\n          while (1) {\n            switch ((_context.prev = _context.next)) {\n              case 0:\n                _context.next = 2;\n                return fetchData(1);\n\n              case 2:\n                value1 = _context.sent;\n                _context.next = 5;\n                return fetchData(value1);\n\n              case 5:\n                value2 = _context.sent;\n                _context.next = 8;\n                return fetchData(value2);\n\n              case 8:\n                value3 = _context.sent;\n\n                console.log(value3);\n\n              case 10:\n              case &quot;end&quot;:\n                return _context.stop();\n            }\n          }\n        },\n        _callee,\n        this\n      );\n    })\n  );\n\n  return function fetchValue() {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nfetchValue();\n</code></pre>\n<h2>_asyncToGenerator</h2>\n<p>regeneratorRuntime 相关的代码我们在 <a href=\"https://github.com/mqyqingfeng/Blog/issues/102\">《ES6 系列之 Babel 将 Generator 编译成了什么样子》</a> 中已经介绍过了，这次我们重点来看看 _asyncToGenerator 函数：</p>\n<pre><code class=\"language-js\">function _asyncToGenerator(fn) {\n  return function() {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function(resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(\n            function(value) {\n              step(&quot;next&quot;, value);\n            },\n            function(err) {\n              step(&quot;throw&quot;, err);\n            }\n          );\n        }\n      }\n      return step(&quot;next&quot;);\n    });\n  };\n}\n</code></pre>\n<p>以上这段代码主要是用来实现 generator 的自动执行以及返回 Promise。</p>\n<p>当我们执行 <code>fetchValue()</code> 的时候，执行的其实就是 <code>_asyncToGenerator</code> 返回的这个匿名函数，在匿名函数中，我们执行了</p>\n<pre><code class=\"language-js\">var gen = fn.apply(this, arguments);\n</code></pre>\n<p>这一步就相当于执行 Generator 函数，举个例子：</p>\n<pre><code class=\"language-js\">function* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n</code></pre>\n<p><code>var gen = fn.apply(this, arguments)</code> 就相当于 <code>var hw = helloWorldGenerator();</code>，返回的 gen 是一个具有 next()、throw()、return() 方法的对象。</p>\n<p>然后我们返回了一个 Promise 对象，在 Promise 中，我们执行了 step(&quot;next&quot;)，step 函数中会执行：</p>\n<pre><code class=\"language-js\">try {\n  var info = gen[key](arg);\n  var value = info.value;\n} catch (error) {\n  reject(error);\n  return;\n}\n</code></pre>\n<p>step(&quot;next&quot;) 就相当于 <code>var info = gen.next()</code>，返回的 info 对象是一个具有 value 和 done 属性的对象：</p>\n<pre><code class=\"language-jsx\">{value: Promise, done: false}\n</code></pre>\n<p>接下来又会执行：</p>\n<pre><code class=\"language-js\">if (info.done) {\n  resolve(value);\n} else {\n  return Promise.resolve(value).then(\n    function(value) {\n      step(&quot;next&quot;, value);\n    },\n    function(err) {\n      step(&quot;throw&quot;, err);\n    }\n  );\n}\n</code></pre>\n<p>value 此时是一个 Promise，Promise.resolve(value) 依然会返回这个 Promise，我们给这个 Promise 添加了一个 then 函数，用于在 Promise 有结果时执行，有结果时又会执行 <code>step(&quot;next&quot;, value)</code>，从而使得 Generator 继续执行，直到 <code>info.done</code> 为 true，才会 <code>resolve(value)</code>。</p>\n<h2>不完整但可用的代码</h2>\n<pre><code class=\"language-js\">(function() {\n    var ContinueSentinel = {};\n\n    var mark = function(genFun) {\n        var generator = Object.create({\n            next: function(arg) {\n                return this._invoke(&quot;next&quot;, arg);\n            }\n        });\n        genFun.prototype = generator;\n        return genFun;\n    };\n\n    function wrap(innerFn, outerFn, self) {\n        var generator = Object.create(outerFn.prototype);\n\n        var context = {\n            done: false,\n            method: &quot;next&quot;,\n            next: 0,\n            prev: 0,\n            sent: undefined,\n            abrupt: function(type, arg) {\n                var record = {};\n                record.type = type;\n                record.arg = arg;\n\n                return this.complete(record);\n            },\n            complete: function(record, afterLoc) {\n                if (record.type === &quot;return&quot;) {\n                    this.rval = this.arg = record.arg;\n                    this.method = &quot;return&quot;;\n                    this.next = &quot;end&quot;;\n                }\n\n                return ContinueSentinel;\n            },\n            stop: function() {\n                this.done = true;\n                return this.rval;\n            }\n        };\n\n        generator._invoke = makeInvokeMethod(innerFn, context);\n\n        return generator;\n    }\n\n    function makeInvokeMethod(innerFn, context) {\n        var state = &quot;start&quot;;\n\n        return function invoke(method, arg) {\n            if (state === &quot;completed&quot;) {\n                return { value: undefined, done: true };\n            }\n\n            context.method = method;\n            context.arg = arg;\n\n            while (true) {\n                state = &quot;executing&quot;;\n\n                if (context.method === &quot;next&quot;) {\n                    context.sent = context._sent = context.arg;\n                }\n\n                var record = {\n                    type: &quot;normal&quot;,\n                    arg: innerFn.call(self, context)\n                };\n\n                if (record.type === &quot;normal&quot;) {\n                    state = context.done ? &quot;completed&quot; : &quot;yield&quot;;\n\n                    if (record.arg === ContinueSentinel) {\n                        continue;\n                    }\n\n                    return {\n                        value: record.arg,\n                        done: context.done\n                    };\n                }\n            }\n        };\n    }\n\n    window.regeneratorRuntime = {};\n\n    regeneratorRuntime.wrap = wrap;\n    regeneratorRuntime.mark = mark;\n})();\n\n&quot;use strict&quot;;\n\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var gen = fn.apply(this, arguments);\n        return new Promise(function(resolve, reject) {\n            function step(key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    return Promise.resolve(value).then(\n                        function(value) {\n                            step(&quot;next&quot;, value);\n                        },\n                        function(err) {\n                            step(&quot;throw&quot;, err);\n                        }\n                    );\n                }\n            }\n            return step(&quot;next&quot;);\n        });\n    };\n}\n\nvar fetchData = function fetchData(data) {\n    return new Promise(function(resolve) {\n        return setTimeout(resolve, 1000, data + 1);\n    });\n};\n\nvar fetchValue = (function() {\n    var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee() {\n            var value1, value2, value3;\n            return regeneratorRuntime.wrap(\n                function _callee$(_context) {\n                    while (1) {\n                        switch ((_context.prev = _context.next)) {\n                            case 0:\n                                _context.next = 2;\n                                return fetchData(1);\n\n                            case 2:\n                                value1 = _context.sent;\n                                _context.next = 5;\n                                return fetchData(value1);\n\n                            case 5:\n                                value2 = _context.sent;\n                                _context.next = 8;\n                                return fetchData(value2);\n\n                            case 8:\n                                value3 = _context.sent;\n\n                                console.log(value3);\n\n                            case 10:\n                            case &quot;end&quot;:\n                                return _context.stop();\n                        }\n                    }\n                },\n                _callee,\n                this\n            );\n        })\n    );\n\n    return function fetchValue() {\n        return _ref.apply(this, arguments);\n    };\n})();\n\nfetchValue();\n</code></pre>\n<p>请原谅我水了一篇文章……</p>\n<h2>ES6 系列</h2>\n<p>ES6 系列目录地址：<a href=\"https://github.com/mqyqingfeng/Blog\">https://github.com/mqyqingfeng/Blog</a></p>\n<p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p>\n<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>\n"}