{"code":0,"data":"### 1. Promise.all() 批量执行一堆函数\r\n1. Promise.all([p1,p2,p3,...])用于将多个Promise实例，包装成一个新的Promise实例。\r\n2. 返回的实例就是普通Promise。\r\n3. 它接收一个数组作为参数\r\n4. 数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态的改变\r\n5. 当所有子Promise都完成，该Promise完成，返回值是全部值得数组\r\n6. 有任何一个失败，该Promise失败，返回值时第一个失败的子Promise的结果。\r\n\r\n<details>\r\n    <summary><span>示例代码</span></summary>\r\n    \r\n            console.log('here we go'); // eslint-disable-line\r\n        Promise.all([1,2,3]) //(1)\r\n            .then(all=>{\r\n                console.log('1',all); // eslint-disable-line\r\n                return Promise.all([function(){ //(2)\r\n                    console.log('ooxx'); // eslint-disable-line\r\n                },'xxoo',false]);\r\n            })\r\n            .then(all=>{ \r\n                console.log('2',all); // eslint-disable-line\r\n                let p1 = new Promise(resolve => { //(3)\r\n                    setTimeout(()=>{\r\n                        resolve('I\\'m P1');\r\n                    },1500)\r\n                });\r\n                let p2 = new Promise(resolve => { //(4)\r\n                    setTimeout(()=>{ \r\n                        resolve('I\\'m P2');\r\n                    },1450)\r\n                });\r\n                return Promise.all([p1,p2]); //(5)\r\n            })\r\n            .then(all=>{ //(6)\r\n                console.log('3',all); // eslint-disable-line\r\n                let p1=new Promise(resolve => { \r\n                    setTimeout(()=>{\r\n                        resolve('I\\'m P1');\r\n                    },1500);\r\n                });\r\n                let p2 = new Promise((resolve, reject) => { //(7)\r\n                    setTimeout(()=>{\r\n                        reject('I\\'m P2');\r\n                    },1000);\r\n                });\r\n                let p3=new Promise((resolve, reject) => { \r\n                    setTimeout(()=>{\r\n                        reject('I\\'m P3');\r\n                    },3000);\r\n                });\r\n                return Promise.all([p1,p2,p3]); //(8) \r\n            })\r\n            .then(all=>{ //(9)\r\n                console.log('all',all); // eslint-disable-line\r\n            })\r\n            .catch(err =>{ //(10)\r\n                console.log('catch',err); // eslint-disable-line\r\n            })\r\n</details>\r\n\r\n<br>\r\n<p style=\"color:#909090\">执行结果：</p>\r\n\r\n![](https://tva1.sinaimg.cn/large/006y8mN6gy1g78n3mfxtkj315k07ktaq.jpg)\r\n![](https://tva1.sinaimg.cn/large/006y8mN6gy1g78n5htkc7j316407840i.jpg)\r\n![](https://tva1.sinaimg.cn/large/006y8mN6gy1g78o6ed5w3j316207ejtf.jpg)\r\n![]()\r\n\r\n<p style=\"color:#909090\">结果分析：</p>\r\n1. (1)中传入的是[1,2,3]，不是数组，结果会被立刻返回\r\n2. (2)中传入的是function，不是Promise实例，也会被立刻执行\r\n3.（5)中接收到的都是Promise实例，因此会等待1.5s左右返回两个Promise(3)(4)的返回值组成的结果\r\n4. (8)有p1,p2,p3，同时p2,p3都会返回错误，p2会错误的早一些，所以(9)会被跳过，同时(10)catch触发，捕获到错误，是由第一个触发错误的Promise返回的值(7)\r\n\r\n### 2. 错误处理\r\n\r\n##### 在Promise中错误处理有两种做法：\r\n1. `reject('错误信息').then(null,message=>{})`\r\n2. `throw new Errow('错误信息').catch(message =<{})`\r\n推荐使用第二种，更加清晰好读，并且可以捕获前面的错误。\r\n\r\n##### .catch()+.then()会发生什么？\r\n\r\n<details>\r\n    <summary><span>示例代码</span></summary>\r\n    \r\n        console.log('here we go'); // eslint-disable-line\r\n        new Promise( resolve => {\r\n            setTimeout(()=>{\r\n                resolve();\r\n            }, 1000)\r\n        })\r\n           .then( value => {\r\n               console.log('start'); // eslint-disable-line\r\n               throw new Error('test error');\r\n           })\r\n            .catch(err=>{ // (1)\r\n                console.log('I catch',err);\r\n                // throw new Error('another error');\r\n                // eslint-disable-line\r\n            })\r\n            .then(()=>{\r\n                console.log('arrive here'); // eslint-disable-line\r\n            })\r\n            .then(()=>{\r\n                console.log('... and here'); // eslint-disable-line\r\n            })\r\n            .catch(err=>{\r\n                console.log('No,I catch:',err); // eslint-disable-line\r\n            })    \r\n</details>\r\n\r\ncatch也会返回一个Promise实例，并且如果其中没有抛出错误这个Promise实例也是fulfilled的状态。\r\n\r\n打开注释调的代码后执行结果：\r\nanother err会使得catch(1)返回的Promise实例变为rejected状态，绕过下面两个then函数的执行，进入到下一个catch函数。\r\n\r\n注意：建议在所有队列最后都加上.catch(),因为队列的执行全部都是异步的，很可能生成的时候是没问题的，而出问题时却不知道，引发意想不到的问题。\r\n而我们通过捕获，把错误处理一下或记录下来，都会有比较好的效果。\r\n\r\n### 3. 实现队列\r\n有时候我们不希望所有动作一起发生，而是按照一定顺序，逐个进行。\r\n通过Promise.then()返回一个新的Promise实例的特性，串成队列来进行操作。\r\n如果有一组要做的事，有两种方式：\r\n（1）使用.forEach()、for循环\r\n```\r\n    function queue(things){\r\n        let promise = Promise.resolve();\r\n        things.forEach(things=>{\r\n            promise = promise.then(()=>{\r\n                return new Promise(resolve => {\r\n                    doThing(thing,()=>{\r\n                        resolve();\r\n                    });\r\n                });\r\n            });\r\n        });\r\n        return promise;\r\n    }\r\n    queue(['lots','of','things',...]);\r\n```\r\n（2）使用.reduce() 从数组的一端遍历数组，直到另外一端\r\n\r\n```\r\n   function queue(things){\r\n        let promise = Promise.resolve();\r\n        things.reduce(()=>{\r\n            return new Promise(resolve => {\r\n                doThing(thing,()=>{\r\n                    resolve();\r\n                });\r\n            });\r\n        });\r\n        promise.resolve();\r\n    }\r\n    queue(['lots','of','things',...]);\r\n```\r\n#### 两个常见错误：\r\n（1）中与forEach连用时，没有把.then()产生的新Promise实例赋给Promise，没有生成队列，造成当Promise完成时，后面所有的then会同时触发\r\n（2）中与reduce连用时，Promise实例创建之后，会立刻运行执行器代码，所以所有的Promise也会立刻执行，不会等待队列的下一步才执行。\r\n\r\n### 4. 总结\r\n通过学习，发现自己在Promise使用上还是存在很多问题的，对它的可能出现的错误的抛出处理、队列执行的具体顺序还是不能把控的，加上项目中websocket数据的推送，更晕了，这个是要搞定的大事情。"}