{"code":0,"data":"<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>React合成事件</td>\n<td>2019.10.01-2019.10.07</td>\n</tr>\n</tbody>\n</table>\n<h2>React 合成事件</h2>\n<h3>为什么有合成事件</h3>\n<p>如果在 <code>DOM</code> 节点上绑定过多的事件处理函数，会影响页面的性能。<code>React</code> 为了避免这类 <code>DOM</code> 事件的滥用，同时保证跨浏览器兼容性，实现了一个中间层 <code>SyntheticEvent</code>。</p>\n<blockquote>\n<p>绑定过多的事件处理函数影响性能是由多方面原因造成的。首先，函数也是对象，会占用内存，内存中的对象越多，性能就越差；其次，必须事先指定所有事件处理程序需要多次访问 DOM，会延迟页面交互就绪时间。</p>\n</blockquote>\n<p><code>SyntheticEvent</code> 实现原理是通过事件委托，将监听事件绑定在 <code>document</code> 上，当事件冒泡至 <code>document</code> 处，将事件交给对应的处理函数处理。</p>\n<h3>事件池</h3>\n<p><code>SyntheticEvent</code> 是合并而来。这意味着 <code>SyntheticEvent</code> 对象可能会被重用，在事件回调函数被调用后，所有的属性都会被清空，所以不能通过异步访问事件。</p>\n<pre><code>function onClick(event) {\n  console.log(event); // =&gt; nullified object.\n  console.log(event.type); // =&gt; &quot;click&quot;\n  const eventType = event.type; // =&gt; &quot;click&quot;\n\n  setTimeout(function() {\n    console.log(event.type); // =&gt; null\n    console.log(eventType); // =&gt; &quot;click&quot;\n  }, 0);\n\n  // 不起作用，this.state.clickEvent 的值将会只包含 null\n  this.setState({clickEvent: event});\n\n  // 你仍然可以导出事件属性\n  this.setState({eventType: event.type});\n}\n</code></pre>\n<p>如果需要访问事件属性，需在事件上调用 <code>event.persist()</code>，允许用户代码保留对事件的引用。</p>\n<h3>合成事件与原生事件</h3>\n<p><code>React</code> 元素的事件处理和 <code>DOM</code> 元素的类似，但是也有一些区别:</p>\n<ul>\n<li><code>React</code> 事件采用小驼峰式命名。</li>\n<li>使用 <code>JSX</code> 语法时需要传入一个函数作为事件处理函数，而不是一个字符串。</li>\n</ul>\n<pre><code>&lt;!--- 原生 DOM --&gt;\n&lt;button onclick=&quot;activateLasers()&quot;&gt;\n  Activate Lasers\n&lt;/button&gt;\n\n&lt;!--- React --&gt;\n&lt;button onClick={activateLasers}&gt;\n  Activate Lasers\n&lt;/button&gt;\n</code></pre>\n<ul>\n<li><code>React</code> 组件上声明的事件最终都绑定到了 <code>document</code> 节点上，并非组件对应的 <code>DOM</code> 节点。</li>\n</ul>\n<h3>支持的事件</h3>\n<p>详情查看 <a href=\"https://reactjs.org/docs/events.html#supported-events\">Supported Events</a></p>\n<p>这些事件处理函数在冒泡阶段被触发。如需在捕获阶段处理，则应为事件名添加 <code>Capture</code>。例如，处理捕获阶段的点击事件使用 <code>onClickCapture</code>。</p>\n<p>如果需要访问原生事件，在 <code>SyntheticEvent</code> 对象中可以通过 <code>nativeEvent</code> 属性访问到。除此之外，每个 <code>SyntheticEvent</code> 对象都包含以下属性：</p>\n<pre><code>    - boolean bubbles\n    - boolean cancelable\n    - DOMEventTarget currentTarget\n    - boolean defaultPrevented\n    - number eventPhase\n    - boolean isTrusted\n    - DOMEvent nativeEvent\n    - void preventDefault()\n    - boolean isDefaultPrevented()\n    - void stopPropagation()\n    - boolean isPropagationStopped()\n    - DOMEventTarget target\n    - number timeStamp\n    - string type\n</code></pre>\n<p>截止 <code>v0.14</code>，当事件处理函数返回 <code>false</code> 时，不再阻止事件冒泡。你可以选择使用 <code>e.stopPropagation()</code> 或者 <code>e.preventDefault()</code> 替代。</p>\n<h3>在 React 中使用原生事件</h3>\n<p>由于原生事件需要绑定在真实 <code>DOM</code> 上，所以一般是在 <code>componentDidMount</code> 阶段 <code>ref</code> 的函数执行阶段进行绑定操作，在 <code>componentWillUnmount</code> 阶段进行解绑操作以避免内存泄漏。</p>\n<pre><code>class TestEvent extends React.Component {\n  handleClick = e =&gt; {\n    console.log(e);\n  };\n  \n  handleClick\n\n  componentDidMount() {\n    const thisDOM = ReactDOM.findDOMNode(this);\n    thisDOM.addEventListener(&quot;click&quot;, this.handleClick);\n  }\n  \n  componentWillUnmount() {\n    const thisDOM = ReactDOM.findDOMNode(this);\n    thisDOM.removeEventListener(&quot;click&quot;, this.handleClick);\n  }\n\n  render() {\n    return (\n      &lt;button className=&quot;test-event&quot; onClick={this.handleClick}&gt;\n        event\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<p>原生事件与合成事件执行顺序如何？</p>\n<pre><code>class Event extends React.Component {\n  handleSyntheticClick = e =&gt; {\n    e.persist();\n    console.log(&quot;syntheticClick&quot;);\n  };\n\n  handleNativeClick = e =&gt; {\n    console.log(&quot;nativeClick&quot;);\n  };\n\n  componentDidMount() {\n    const thisDOM = ReactDOM.findDOMNode(this);\n    thisDOM.addEventListener(&quot;click&quot;, this.handleNativeClick);\n  }\n\n  componentWillUnmount() {\n    const thisDOM = ReactDOM.findDOMNode(this);\n    thisDOM.removeEventListener(&quot;click&quot;, this.handleNativeClick);\n  }\n\n  render() {\n    return (\n      &lt;button className=&quot;test-event&quot; onClick={this.handleSyntheticClick}&gt;\n        event\n      &lt;/button&gt;\n    );\n  }\n}\n// 控制台输出\n// nativeClick\n// syntheticClick\n</code></pre>\n<p>可以得知原生事件会先执行。</p>\n<p>假如阻止了原生事件的冒泡呢？</p>\n<pre><code>  handleNativeClick = e =&gt; {\n    e.stopPropagation();\n    console.log(&quot;nativeClick&quot;);\n  };\n  \n  // 控制台输出\n  // nativeClick\n</code></pre>\n<p>原生事件被阻止冒泡后，事件无法冒泡至 <code>document</code>，故合成事件无法执行，进一步证实了合成事件是对原生事件的封装。</p>\n<h3>总结</h3>\n<p><code>React</code> 合成事件，通过事件代理的方式，在 <code>document</code> 上添加事件监听程序，并调用事件对应处理程序，而并非在对应的 <code>DOM</code> 节点上处理。节省了一定性能，并解决了跨浏览器兼容性问题。</p>\n<p>合成事件本质上是对原生事件的封装，并保留原生事件相同接口。</p>\n<p>要深入了解具体实现过程还需要去阅读源码，下一步的目标就是试着去阅读一小部分源码。</p>\n"}