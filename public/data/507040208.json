{"code":0,"data":"内容 | 时间\r\n-- | --\r\nReact合成事件 | 2019.10.01-2019.10.07\r\n\r\n## React 合成事件\r\n\r\n### 为什么有合成事件\r\n\r\n如果在 `DOM` 节点上绑定过多的事件处理函数，会影响页面的性能。`React` 为了避免这类 `DOM` 事件的滥用，同时保证跨浏览器兼容性，实现了一个中间层 `SyntheticEvent`。\r\n\r\n> 绑定过多的事件处理函数影响性能是由多方面原因造成的。首先，函数也是对象，会占用内存，内存中的对象越多，性能就越差；其次，必须事先指定所有事件处理程序需要多次访问 DOM，会延迟页面交互就绪时间。\r\n\r\n`SyntheticEvent` 实现原理是通过事件委托，将监听事件绑定在 `document` 上，当事件冒泡至 `document` 处，将事件交给对应的处理函数处理。\r\n\r\n### 事件池\r\n`SyntheticEvent` 是合并而来。这意味着 `SyntheticEvent` 对象可能会被重用，在事件回调函数被调用后，所有的属性都会被清空，所以不能通过异步访问事件。\r\n```\r\nfunction onClick(event) {\r\n  console.log(event); // => nullified object.\r\n  console.log(event.type); // => \"click\"\r\n  const eventType = event.type; // => \"click\"\r\n\r\n  setTimeout(function() {\r\n    console.log(event.type); // => null\r\n    console.log(eventType); // => \"click\"\r\n  }, 0);\r\n\r\n  // 不起作用，this.state.clickEvent 的值将会只包含 null\r\n  this.setState({clickEvent: event});\r\n\r\n  // 你仍然可以导出事件属性\r\n  this.setState({eventType: event.type});\r\n}\r\n```\r\n\r\n如果需要访问事件属性，需在事件上调用 `event.persist()`，允许用户代码保留对事件的引用。\r\n\r\n### 合成事件与原生事件\r\n\r\n`React` 元素的事件处理和 `DOM` 元素的类似，但是也有一些区别:\r\n\r\n- `React` 事件采用小驼峰式命名。\r\n- 使用 `JSX` 语法时需要传入一个函数作为事件处理函数，而不是一个字符串。\r\n\r\n```\r\n<!--- 原生 DOM -->\r\n<button onclick=\"activateLasers()\">\r\n  Activate Lasers\r\n</button>\r\n\r\n<!--- React -->\r\n<button onClick={activateLasers}>\r\n  Activate Lasers\r\n</button>\r\n```\r\n\r\n- `React` 组件上声明的事件最终都绑定到了 `document` 节点上，并非组件对应的 `DOM` 节点。\r\n\r\n### 支持的事件\r\n详情查看 [Supported Events](https://reactjs.org/docs/events.html#supported-events)\r\n\r\n这些事件处理函数在冒泡阶段被触发。如需在捕获阶段处理，则应为事件名添加 `Capture`。例如，处理捕获阶段的点击事件使用 `onClickCapture`。\r\n\r\n如果需要访问原生事件，在 `SyntheticEvent` 对象中可以通过 `nativeEvent` 属性访问到。除此之外，每个 `SyntheticEvent` 对象都包含以下属性：\r\n```\r\n    - boolean bubbles\r\n    - boolean cancelable\r\n    - DOMEventTarget currentTarget\r\n    - boolean defaultPrevented\r\n    - number eventPhase\r\n    - boolean isTrusted\r\n    - DOMEvent nativeEvent\r\n    - void preventDefault()\r\n    - boolean isDefaultPrevented()\r\n    - void stopPropagation()\r\n    - boolean isPropagationStopped()\r\n    - DOMEventTarget target\r\n    - number timeStamp\r\n    - string type\r\n```\r\n\r\n截止 `v0.14`，当事件处理函数返回 `false` 时，不再阻止事件冒泡。你可以选择使用 `e.stopPropagation()` 或者 `e.preventDefault()` 替代。\r\n\r\n### 在 React 中使用原生事件\r\n由于原生事件需要绑定在真实 `DOM` 上，所以一般是在 `componentDidMount` 阶段 `ref` 的函数执行阶段进行绑定操作，在 `componentWillUnmount` 阶段进行解绑操作以避免内存泄漏。\r\n\r\n```\r\nclass TestEvent extends React.Component {\r\n  handleClick = e => {\r\n    console.log(e);\r\n  };\r\n  \r\n  handleClick\r\n\r\n  componentDidMount() {\r\n    const thisDOM = ReactDOM.findDOMNode(this);\r\n    thisDOM.addEventListener(\"click\", this.handleClick);\r\n  }\r\n  \r\n  componentWillUnmount() {\r\n    const thisDOM = ReactDOM.findDOMNode(this);\r\n    thisDOM.removeEventListener(\"click\", this.handleClick);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button className=\"test-event\" onClick={this.handleClick}>\r\n        event\r\n      </button>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n原生事件与合成事件执行顺序如何？\r\n```\r\nclass Event extends React.Component {\r\n  handleSyntheticClick = e => {\r\n    e.persist();\r\n    console.log(\"syntheticClick\");\r\n  };\r\n\r\n  handleNativeClick = e => {\r\n    console.log(\"nativeClick\");\r\n  };\r\n\r\n  componentDidMount() {\r\n    const thisDOM = ReactDOM.findDOMNode(this);\r\n    thisDOM.addEventListener(\"click\", this.handleNativeClick);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    const thisDOM = ReactDOM.findDOMNode(this);\r\n    thisDOM.removeEventListener(\"click\", this.handleNativeClick);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <button className=\"test-event\" onClick={this.handleSyntheticClick}>\r\n        event\r\n      </button>\r\n    );\r\n  }\r\n}\r\n// 控制台输出\r\n// nativeClick\r\n// syntheticClick\r\n```\r\n可以得知原生事件会先执行。\r\n\r\n假如阻止了原生事件的冒泡呢？\r\n```\r\n  handleNativeClick = e => {\r\n    e.stopPropagation();\r\n    console.log(\"nativeClick\");\r\n  };\r\n  \r\n  // 控制台输出\r\n  // nativeClick\r\n```\r\n\r\n原生事件被阻止冒泡后，事件无法冒泡至 `document`，故合成事件无法执行，进一步证实了合成事件是对原生事件的封装。\r\n\r\n### 总结\r\n`React` 合成事件，通过事件代理的方式，在 `document` 上添加事件监听程序，并调用事件对应处理程序，而并非在对应的 `DOM` 节点上处理。节省了一定性能，并解决了跨浏览器兼容性问题。\r\n\r\n合成事件本质上是对原生事件的封装，并保留原生事件相同接口。\r\n\r\n要深入了解具体实现过程还需要去阅读源码，下一步的目标就是试着去阅读一小部分源码。"}