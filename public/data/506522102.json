{"code":0,"data":"<h3>1. Promise.all() 批量执行一堆函数</h3>\n<ol>\n<li>Promise.all([p1,p2,p3,...])用于将多个Promise实例，包装成一个新的Promise实例。</li>\n<li>返回的实例就是普通Promise。</li>\n<li>它接收一个数组作为参数</li>\n<li>数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态的改变</li>\n<li>当所有子Promise都完成，该Promise完成，返回值是全部值得数组</li>\n<li>有任何一个失败，该Promise失败，返回值时第一个失败的子Promise的结果。</li>\n</ol>\n<p>&lt;details&gt;\n&lt;summary&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;/summary&gt;</p>\n<pre><code>        console.log('here we go'); // eslint-disable-line\n    Promise.all([1,2,3]) //(1)\n        .then(all=&gt;{\n            console.log('1',all); // eslint-disable-line\n            return Promise.all([function(){ //(2)\n                console.log('ooxx'); // eslint-disable-line\n            },'xxoo',false]);\n        })\n        .then(all=&gt;{ \n            console.log('2',all); // eslint-disable-line\n            let p1 = new Promise(resolve =&gt; { //(3)\n                setTimeout(()=&gt;{\n                    resolve('I\\'m P1');\n                },1500)\n            });\n            let p2 = new Promise(resolve =&gt; { //(4)\n                setTimeout(()=&gt;{ \n                    resolve('I\\'m P2');\n                },1450)\n            });\n            return Promise.all([p1,p2]); //(5)\n        })\n        .then(all=&gt;{ //(6)\n            console.log('3',all); // eslint-disable-line\n            let p1=new Promise(resolve =&gt; { \n                setTimeout(()=&gt;{\n                    resolve('I\\'m P1');\n                },1500);\n            });\n            let p2 = new Promise((resolve, reject) =&gt; { //(7)\n                setTimeout(()=&gt;{\n                    reject('I\\'m P2');\n                },1000);\n            });\n            let p3=new Promise((resolve, reject) =&gt; { \n                setTimeout(()=&gt;{\n                    reject('I\\'m P3');\n                },3000);\n            });\n            return Promise.all([p1,p2,p3]); //(8) \n        })\n        .then(all=&gt;{ //(9)\n            console.log('all',all); // eslint-disable-line\n        })\n        .catch(err =&gt;{ //(10)\n            console.log('catch',err); // eslint-disable-line\n        })\n</code></pre>\n<p>&lt;/details&gt;</p>\n<p>&lt;br&gt;\n&lt;p style=&quot;color:#909090&quot;&gt;执行结果：&lt;/p&gt;</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006y8mN6gy1g78n3mfxtkj315k07ktaq.jpg\" alt=\"\">\n<img src=\"https://tva1.sinaimg.cn/large/006y8mN6gy1g78n5htkc7j316407840i.jpg\" alt=\"\">\n<img src=\"https://tva1.sinaimg.cn/large/006y8mN6gy1g78o6ed5w3j316207ejtf.jpg\" alt=\"\">\n<img src=\"\" alt=\"\"></p>\n<p>&lt;p style=&quot;color:#909090&quot;&gt;结果分析：&lt;/p&gt;</p>\n<ol>\n<li>(1)中传入的是[1,2,3]，不是数组，结果会被立刻返回</li>\n<li>(2)中传入的是function，不是Promise实例，也会被立刻执行\n3.（5)中接收到的都是Promise实例，因此会等待1.5s左右返回两个Promise(3)(4)的返回值组成的结果</li>\n<li>(8)有p1,p2,p3，同时p2,p3都会返回错误，p2会错误的早一些，所以(9)会被跳过，同时(10)catch触发，捕获到错误，是由第一个触发错误的Promise返回的值(7)</li>\n</ol>\n<h3>2. 错误处理</h3>\n<h5>在Promise中错误处理有两种做法：</h5>\n<ol>\n<li><code>reject('错误信息').then(null,message=&gt;{})</code></li>\n<li><code>throw new Errow('错误信息').catch(message =&lt;{})</code>\n推荐使用第二种，更加清晰好读，并且可以捕获前面的错误。</li>\n</ol>\n<h5>.catch()+.then()会发生什么？</h5>\n<p>&lt;details&gt;\n&lt;summary&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;/summary&gt;</p>\n<pre><code>    console.log('here we go'); // eslint-disable-line\n    new Promise( resolve =&gt; {\n        setTimeout(()=&gt;{\n            resolve();\n        }, 1000)\n    })\n       .then( value =&gt; {\n           console.log('start'); // eslint-disable-line\n           throw new Error('test error');\n       })\n        .catch(err=&gt;{ // (1)\n            console.log('I catch',err);\n            // throw new Error('another error');\n            // eslint-disable-line\n        })\n        .then(()=&gt;{\n            console.log('arrive here'); // eslint-disable-line\n        })\n        .then(()=&gt;{\n            console.log('... and here'); // eslint-disable-line\n        })\n        .catch(err=&gt;{\n            console.log('No,I catch:',err); // eslint-disable-line\n        })    \n</code></pre>\n<p>&lt;/details&gt;</p>\n<p>catch也会返回一个Promise实例，并且如果其中没有抛出错误这个Promise实例也是fulfilled的状态。</p>\n<p>打开注释调的代码后执行结果：\nanother err会使得catch(1)返回的Promise实例变为rejected状态，绕过下面两个then函数的执行，进入到下一个catch函数。</p>\n<p>注意：建议在所有队列最后都加上.catch(),因为队列的执行全部都是异步的，很可能生成的时候是没问题的，而出问题时却不知道，引发意想不到的问题。\n而我们通过捕获，把错误处理一下或记录下来，都会有比较好的效果。</p>\n<h3>3. 实现队列</h3>\n<p>有时候我们不希望所有动作一起发生，而是按照一定顺序，逐个进行。\n通过Promise.then()返回一个新的Promise实例的特性，串成队列来进行操作。\n如果有一组要做的事，有两种方式：\n（1）使用.forEach()、for循环</p>\n<pre><code>    function queue(things){\n        let promise = Promise.resolve();\n        things.forEach(things=&gt;{\n            promise = promise.then(()=&gt;{\n                return new Promise(resolve =&gt; {\n                    doThing(thing,()=&gt;{\n                        resolve();\n                    });\n                });\n            });\n        });\n        return promise;\n    }\n    queue(['lots','of','things',...]);\n</code></pre>\n<p>（2）使用.reduce() 从数组的一端遍历数组，直到另外一端</p>\n<pre><code>   function queue(things){\n        let promise = Promise.resolve();\n        things.reduce(()=&gt;{\n            return new Promise(resolve =&gt; {\n                doThing(thing,()=&gt;{\n                    resolve();\n                });\n            });\n        });\n        promise.resolve();\n    }\n    queue(['lots','of','things',...]);\n</code></pre>\n<h4>两个常见错误：</h4>\n<p>（1）中与forEach连用时，没有把.then()产生的新Promise实例赋给Promise，没有生成队列，造成当Promise完成时，后面所有的then会同时触发\n（2）中与reduce连用时，Promise实例创建之后，会立刻运行执行器代码，所以所有的Promise也会立刻执行，不会等待队列的下一步才执行。</p>\n<h3>4. 总结</h3>\n<p>通过学习，发现自己在Promise使用上还是存在很多问题的，对它的可能出现的错误的抛出处理、队列执行的具体顺序还是不能把控的，加上项目中websocket数据的推送，更晕了，这个是要搞定的大事情。</p>\n"}